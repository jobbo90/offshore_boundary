mapview(points1, col.regions = c("red"), layer.name = c("set1")) +
mapview(points2, col.regions = c("green"), layer.name = c("set2")) +
mapview(points3, col.regions = c("yellow"), layer.name = c("set3")) +
mapview(lines_sf,xcol = "x", ycol = "y")
test1 <- Map$addLayer(image20090912, vizParams, "Landsat 8 20090912")
test2 <- Map$addLayer(image20091115, vizParams, "Landsat 8 20091115")
test1 + test2 +
mapview(pointsLand2,col.regions = c("blue")) +
mapview(points1, col.regions = c("red"), layer.name = c("set1")) +
mapview(points2, col.regions = c("green"), layer.name = c("set2")) +
mapview(points3, col.regions = c("yellow"), layer.name = c("set3")) +
mapview(lines_sf,xcol = "x", ycol = "y")
(0.177 - 0.309)/0.309
(0.496-0.694)/0.694
0.496-0.694
0.177 - 0.309
## ---------------------------
#'
#' Script name: Plot offshore boundary results
#'
#' Short Description:
#'
#'
#' Author: Job de Vries
#'
#' Date Created: 2020-11-16
#'
#' Copyright (c) Job de Vries, 2020
#' Email: j.devries4@uu.nl
#'
## ---------------------------
#'
#' Description
#'
#'
#'
## ---------------------------
rm(list = ls())
#' set working directory for Mac and PC
wd<-getwd()
# setwd("D:/BackUp_D_mangroMud_202001/Research/Software/Projects/offshore_boundary")
## ---------------------------
options(scipen = 6, digits = 4) # I prefer to view outputs in non-scientific notation
memory.limit(30000000)     # this is needed on some PCs to increase memory allowance, but has no impact on macs.
#  Map view options:
# https://r-spatial.github.io/mapview/articles/articles/mapview_02-advanced.html
## ---------------------------
#' load up the packages
source("./src/packages.R")       # loads up all the packages we need
## ---------------------------
source("./src/functions.R")
## ---------------------------
mapviewOptions(basemaps = c( "Esri.WorldImagery","Esri.WorldShadedRelief", "OpenStreetMap.DE"))
dataFolder <- './data/raw'
years <- c('2018', '2019')
# transect  <- readOGR(paste0(dataFolder, '/transects'), '2009_WnZ_transect')
# select folders
folderSelect <- as.matrix(list.files(paste0(dataFolder, '/GEE_exports'), full.names = T))
df <- rewrite(folderSelect);
# only csv's
df <- df[grep('.csv', folderSelect, ignore.case = T),]
filtered <- vector('list', 100)
for (q in seq_along(years)) {
# q <- 1
year = years[q]
filters = c(year)
filtered = rbind(filtered, df %>%
dplyr::filter(
filters %>%
# apply the filter of all the text rows for each pattern
# you'll get one list of logical by pattern ignored_string
purrr::map(~ to_keep(.x, text = text)) %>%
# get a logical vector of rows to keep
purrr::pmap_lgl(all)
))
}
filtered <- unique(filtered)[1:2,]
allFiles <- do.call(rbind, lapply(as.matrix(filtered)[,1], function(x) read.csv(x, stringsAsFactors = FALSE,
sep = ',', na.strings=c("","NA")
)))
col_dates <- col_of_interest(allFiles, 'DATE_ACQUIRED$')
col_coastDist <- col_of_interest(allFiles, 'coastDist$')
# all unique dates
uniqueDates <- unique(allFiles[,col_dates]);
# all unique transect (id's)
pos <- unique(allFiles[, col_of_interest(allFiles, 'pos$')]);
uniqueX<- unique(allFiles[, col_of_interest(allFiles, 'originX$')]);
uniqueY<- unique(allFiles[, col_of_interest(allFiles, 'originY$')]);
geo<- unique(allFiles[, col_of_interest(allFiles, '.geo')]);
# test simple 2d plot coastline dist
pos_to_test <- c('121000')
# testPos <- subset(allFiles, allFiles[,col_of_interest(allFiles, 'pos')] == pos_to_test
#                     & allFiles[,col_of_interest(allFiles, 'coastDist$')] >= 0 )
# testPos <- testPos[order(testPos$DATE_ACQUIRED),] #order by date
# or on all entries
allFiles_gt0 <- subset(arrange(allFiles, pos, DATE_ACQUIRED), coastDist >=0)
# make groups of 3 months per transect
test_allFiles <- allFiles_gt0 %>%
mutate(date_col = as.POSIXct(cut(lubridate::date(allFiles_gt0$DATE_ACQUIRED), "3 months"))) %>%
mutate(year_col = as.POSIXct(cut(lubridate::date(allFiles_gt0$DATE_ACQUIRED), "1 year")))
group_dates<-unique(test_allFiles$year_col)
group_pos <- unique(test_allFiles$pos)
# assume nothing is outlier
test_allFiles$outlier <- 1
# assume nothing is outlier
test_allFiles$outlier <- 1
# estimate outliers
for(i in group_dates){
# i<-group_dates[1]
for(q in group_pos){
# q <- group_pos[15]
subsets <- subset(test_allFiles, year_col == i & pos == q)
# plot(as.Date(subsets$DATE_ACQUIRED), subsets$coastDist)
rownr <- strtoi(rownames(subset(test_allFiles, year_col == i & pos == q)))
# detect outliers (give them a 0!!!)
test_allFiles[rownr, 'outlier'] <- rosner(subsets$coastDist)
}
}
# plot per group after removing outliers
# check i group_by actually removes the outliers!
test_allFiles_mn <- test_allFiles %>% group_by(pos, date_col, outlier) %>%
mutate(mn = median(coastDist)) #%>%
testSubset <- subset(test_allFiles_mn,
pos == pos_to_test)
outliers <- subset(testSubset, outlier == 0)
nonOutliers <- subset(testSubset, outlier == 1)
plot(as.Date(nonOutliers$DATE_ACQUIRED), nonOutliers$coastDist, ylim = c(min(outliers$coastDist)-30,max(nonOutliers$coastDist)+ 30))
points(as.Date(outliers$DATE_ACQUIRED), outliers$coastDist, col = 'red')
# median values with steps per 3 months ()
points(as.Date(nonOutliers$DATE_ACQUIRED), nonOutliers$mn, col = 'blue')
View(test_allFiles_mn)
# # get for all transects an oldest coastline observation as baseline
test_allFiles_mn$baseline <- 0
# # get for all transects an oldest coastline observation as baseline
test_allFiles_mn$baseline <- 0
sid = 297000
# sid = 297000
# print(sid)
i <- test_allFiles_mn$pos == sid # create a logical index
i
# get min date with an observation
subsetTemp2 <- subset(test_allFiles_mn, test_allFiles_mn$pos == sid &
test_allFiles_mn$coastDist >= 0 &
test_allFiles_mn$outlier != 0) # exclude detected outliers
subsetTemp2
outliers <- subset(subsetTemp2, outlier == 0)
nonOutliers <- subset(subsetTemp2, outlier == 1)
plot(as.Date(nonOutliers$DATE_ACQUIRED), nonOutliers$coastDist, ylim = c(min(outliers$coastDist)-30,max(nonOutliers$coastDist)+ 30))
nonOutliers$DATE_ACQUIRED)
as.Date(nonOutliers$DATE_ACQUIRED)
nonOutliers$coastDist
outliers$coastDist
min(subsetTemp2$coastDist)
plot(as.Date(nonOutliers$DATE_ACQUIRED), nonOutliers$coastDist, ylim = c(min(subsetTemp2$coastDist)-30,max(subsetTemp2$coastDist)+ 30))
points(as.Date(outliers$DATE_ACQUIRED), outliers$coastDist, col = 'red')
outliers
# median values with steps per 3 months ()
points(as.Date(nonOutliers$DATE_ACQUIRED), nonOutliers$mn, col = 'blue')
outliers$date_col
plot(as.Date(nonOutliers$DATE_ACQUIRED), nonOutliers$coastDist, ylim = c(min(subsetTemp2$coastDist)-30,max(subsetTemp2$coastDist)+ 30))
points(as.Date(outliers$DATE_ACQUIRED), outliers$coastDist, col = 'red')
# median values with steps per 3 months ()
points(as.Date(nonOutliers$date_col), nonOutliers$mn, col = 'blue')
# get first date after reference date
index <- which.min(abs(as.Date(subsetTemp2$DATE_ACQUIRED)-reference_date))
reference_date <- as.Date("2018-09-01")
# get first date after reference date
index <- which.min(abs(as.Date(subsetTemp2$DATE_ACQUIRED)-reference_date))
nrow(subsetTemp2) == 0)
nrow(subsetTemp2)
# get first date after reference date
# excluding outlier values
index <- which.min(abs(as.Date(nonOutliers$DATE_ACQUIRED)-reference_date))
index
# get first date after reference date
index <- which.min(abs(as.Date(subsetTemp2$DATE_ACQUIRED)-reference_date))
index
if(nrow(subsetTemp2) == 0){
coastObs <- 0
} else {
coastObs <- subsetTemp2[index, 'coastDist']
# coastObs <- subsetTemp2[subsetTemp2$DATE_ACQUIRED == min(subsetTemp2[, 'DATE_ACQUIRED']), 'coastDist']
}
coastObs
# # get for all transects an oldest coastline observation as baseline
test_allFiles_mn$baseline <- 0
reference_date <- as.Date("2018-09-01")
for (sid in pos) {
# sid = 297000
# print(sid)
i <- test_allFiles_mn$pos == sid # create a logical index
# get min date with an observation
subsetTemp2 <- subset(test_allFiles_mn, test_allFiles_mn$pos == sid &
test_allFiles_mn$coastDist >= 0 &
test_allFiles_mn$outlier != 0) # exclude detected outliers
outliers <- subset(subsetTemp2, outlier == 0)
nonOutliers <- subset(subsetTemp2, outlier == 1)
plot(as.Date(nonOutliers$DATE_ACQUIRED), nonOutliers$coastDist, ylim = c(min(subsetTemp2$coastDist)-30,max(subsetTemp2$coastDist)+ 30))
points(as.Date(outliers$DATE_ACQUIRED), outliers$coastDist, col = 'red')
# median values with steps per 3 months ()
points(as.Date(nonOutliers$date_col), nonOutliers$mn, col = 'blue')
# get first date after reference date
index <- which.min(abs(as.Date(nonOutliers$DATE_ACQUIRED)-reference_date))
# you'd want to normalize for the mean position around the reference date to avoid
# outliers have to much effect
# option 1: filter outliers
# option 2: moving average
if(nrow(subsetTemp2) == 0){
coastObs <- 0
} else {
coastObs <- subsetTemp2[index, 'coastDist']
# coastObs <- subsetTemp2[subsetTemp2$DATE_ACQUIRED == min(subsetTemp2[, 'DATE_ACQUIRED']), 'coastDist']
}
test_allFiles_mn$baseline[i] <- coastObs
}
sid
i
# sid = 297000
# print(sid)
i <- test_allFiles_mn$pos == sid # create a logical index
# get min date with an observation
subsetTemp2 <- subset(test_allFiles_mn, test_allFiles_mn$pos == sid &
test_allFiles_mn$coastDist >= 0 &
test_allFiles_mn$outlier != 0) # exclude detected outliers
outliers <- subset(subsetTemp2, outlier == 0)
outliers
nonOutliers
# # get for all transects an oldest coastline observation as baseline
test_allFiles_mn$baseline <- 0
outliers
nonOutliers
# get first date after reference date
index <- which.min(abs(as.Date(nonOutliers$DATE_ACQUIRED)-reference_date))
index
nrow(subsetTemp2)
if(nrow(subsetTemp2) == 0){
coastObs <- 0
} else {
coastObs <- subsetTemp2[index, 'coastDist']
# coastObs <- subsetTemp2[subsetTemp2$DATE_ACQUIRED == min(subsetTemp2[, 'DATE_ACQUIRED']), 'coastDist']
}
test_allFiles_mn$baseline[i] <- coastObs
# # get for all transects an oldest coastline observation as baseline
test_allFiles_mn$baseline <- 0
reference_date <- as.Date("2018-09-01")
for (sid in pos) {
# sid = 297000
# print(sid)
i <- test_allFiles_mn$pos == sid # create a logical index
# get min date with an observation
subsetTemp2 <- subset(test_allFiles_mn, test_allFiles_mn$pos == sid &
test_allFiles_mn$coastDist >= 0 &
test_allFiles_mn$outlier != 0) # exclude detected outliers
outliers <- subset(subsetTemp2, outlier == 0)
nonOutliers <- subset(subsetTemp2, outlier == 1)
# plot(as.Date(nonOutliers$DATE_ACQUIRED), nonOutliers$coastDist, ylim = c(min(subsetTemp2$coastDist)-30,max(subsetTemp2$coastDist)+ 30))
# points(as.Date(outliers$DATE_ACQUIRED), outliers$coastDist, col = 'red')
# # median values with steps per 3 months ()
# points(as.Date(nonOutliers$date_col), nonOutliers$mn, col = 'blue')
# get first date after reference date
index <- which.min(abs(as.Date(nonOutliers$DATE_ACQUIRED)-reference_date))
# you'd want to normalize for the mean position around the reference date to avoid
# outliers have to much effect
# option 1: filter outliers
# option 2: moving average
if(nrow(subsetTemp2) == 0){
coastObs <- 0
} else {
coastObs <- subsetTemp2[index, 'coastDist']
# coastObs <- subsetTemp2[subsetTemp2$DATE_ACQUIRED == min(subsetTemp2[, 'DATE_ACQUIRED']), 'coastDist']
}
test_allFiles_mn$baseline[i] <- coastObs
}
# subtract each that values from each obs (ensure positive values)
# to normalize
test_allFiles_mn$normalized <- test_allFiles_mn$coastDist - test_allFiles_mn$baseline
test_allFiles_mn$coastDist
test_allFiles_mn$baseline
coastObs
View(test_allFiles_mn)
# subtract each that values from each obs (ensure positive values)
# to normalize
test_allFiles_mn$normalized <- test_allFiles_mn$coastDist - test_allFiles_mn$baseline
class(test_allFiles_mn$coastDist)
class(test_allFiles_mn$baseline)
class(coastObs)
as.numeric(coastObs)
# # get for all transects an oldest coastline observation as baseline
test_allFiles_mn$baseline <- 0
reference_date <- as.Date("2018-09-01")
for (sid in pos) {
# sid = 297000
# print(sid)
i <- test_allFiles_mn$pos == sid # create a logical index
# get min date with an observation
subsetTemp2 <- subset(test_allFiles_mn, test_allFiles_mn$pos == sid &
test_allFiles_mn$coastDist >= 0 &
test_allFiles_mn$outlier != 0) # exclude detected outliers
outliers <- subset(subsetTemp2, outlier == 0)
nonOutliers <- subset(subsetTemp2, outlier == 1)
# plot(as.Date(nonOutliers$DATE_ACQUIRED), nonOutliers$coastDist, ylim = c(min(subsetTemp2$coastDist)-30,max(subsetTemp2$coastDist)+ 30))
# points(as.Date(outliers$DATE_ACQUIRED), outliers$coastDist, col = 'red')
# # median values with steps per 3 months ()
# points(as.Date(nonOutliers$date_col), nonOutliers$mn, col = 'blue')
# get first date after reference date
index <- which.min(abs(as.Date(nonOutliers$DATE_ACQUIRED)-reference_date))
# you'd want to normalize for the mean position around the reference date to avoid
# outliers have to much effect
# option 1: filter outliers
# option 2: moving average
if(nrow(subsetTemp2) == 0){
coastObs <- 0
} else {
coastObs <- subsetTemp2[index, 'coastDist']
# coastObs <- subsetTemp2[subsetTemp2$DATE_ACQUIRED == min(subsetTemp2[, 'DATE_ACQUIRED']), 'coastDist']
}
test_allFiles_mn$baseline[i] <- as.numeric(coastObs)
}
# subtract each that values from each obs (ensure positive values)
# to normalize
test_allFiles_mn$normalized <- test_allFiles_mn$coastDist - test_allFiles_mn$baseline
allFiles_mutate <- allFiles %>% mutate(year = year(DATE_ACQUIRED),
month = month(DATE_ACQUIRED, label=TRUE),
day = day(DATE_ACQUIRED),
full_date= date(DATE_ACQUIRED))
allFiles_mutate <- test_allFiles_mn %>% mutate(year = year(DATE_ACQUIRED),
month = month(DATE_ACQUIRED, label=TRUE),
day = day(DATE_ACQUIRED),
full_date= date(DATE_ACQUIRED))
allFiles_mutate <- allFiles_mutate %>%
select(pos,day,month,year,full_date,coastDist, normalized) %>%
filter(!(coastDist == -1)) # & contbr_city == 'APO AE'
colnames(allFiles_mutate)
View(allFiles_mutate)
allFiles_mutate <- allFiles_mutate %>%
select(pos,day,month,year,full_date,coastDist, normalized)# %>%
allFiles_mutate <- allFiles_mutate %>%
select(pos) %>%
filter(!(coastDist == -1)) # & contbr_city == 'APO AE'
allFiles_mutate <- allFiles_mutate %>%
# select(pos,day,month,year,full_date,coastDist, normalized) %>%
filter(!(coastDist == -1)) # & contbr_city == 'APO AE'
labeled.dat <- allFiles_mutate[allFiles_mutate$pos %in% c('151000') ,]
p <-ggplot(allFiles_mutate,aes(x = pos,y = full_date, fill=normalized))+
geom_tile(color= "white",size=0.1) +
# scale_fill_gradientn(colours=topo.colors(7),#na.value = "transparent",
#                      breaks=c(0,median(allFiles_mutate$coastDist)),
#                      labels=c("Minimum","Maximum"),
#                      limits=c(0,median(allFiles_mutate$coastDist)))
scale_fill_viridis(name="Max Distance",option ="C", limits = c(-500, 500), oob = scales::squish)
p
test_allFiles$date_col
allFiles_mutate <- test_allFiles_mn %>% mutate(year = year(DATE_ACQUIRED),
month = month(DATE_ACQUIRED, label=TRUE),
day = day(DATE_ACQUIRED),
full_date= date(DATE_ACQUIRED),
full_date2= date(date_col))
test_allFiles_mn$mn_normalized <- test_allFiles_mn$mn - test_allFiles_mn$baseline
allFiles_mutate <- test_allFiles_mn %>% mutate(year = year(DATE_ACQUIRED),
month = month(DATE_ACQUIRED, label=TRUE),
day = day(DATE_ACQUIRED),
full_date= date(DATE_ACQUIRED),
full_date2= date(date_col))
allFiles_mutate <- allFiles_mutate %>%
# select(pos,day,month,year,full_date,coastDist, normalized) %>%
filter(!(coastDist == -1)) # & contbr_city == 'APO AE'
p <-ggplot(allFiles_mutate,aes(x = pos,y = full_date2, fill=mn_normalized))+
geom_tile(color= "white",size=0.1) +
# scale_fill_gradientn(colours=topo.colors(7),#na.value = "transparent",
#                      breaks=c(0,median(allFiles_mutate$coastDist)),
#                      labels=c("Minimum","Maximum"),
#                      limits=c(0,median(allFiles_mutate$coastDist)))
scale_fill_viridis(name="Max Distance",option ="C", limits = c(-500, 500), oob = scales::squish)
p
allFiles_mutate <- allFiles_mutate %>%
# select(pos,day,month,year,full_date,coastDist, normalized) %>%
filter(!(coastDist == -1) & outlier == 0) # & contbr_city == 'APO AE'
labeled.dat <- allFiles_mutate[allFiles_mutate$pos %in% c('151000') ,]
p <-ggplot(allFiles_mutate,aes(x = pos,y = full_date2, fill=mn_normalized))+
geom_tile(color= "white",size=0.1) +
# scale_fill_gradientn(colours=topo.colors(7),#na.value = "transparent",
#                      breaks=c(0,median(allFiles_mutate$coastDist)),
#                      labels=c("Minimum","Maximum"),
#                      limits=c(0,median(allFiles_mutate$coastDist)))
scale_fill_viridis(name="Max Distance",option ="C", limits = c(-500, 500), oob = scales::squish)
p
library(plotly)
ggplotly(p)
ggplotly(p)
library(grid)
x <- 1:10
y <- x^3
qplot(x, y)
downViewport('panel-3-4')
downViewport('panel-1-1')
pushViewport(dataViewport(x,y))
tmp <- grid.locator('in')
tmp.n <- as.numeric(tmp)
tmp2.x <- as.numeric(convertX( unit(x,'native'), 'in' ))
tmp2.y <- as.numeric(convertY( unit(y,'native'), 'in' ))
w <- which.min( (tmp2.x-tmp.n[1])^2 + (tmp2.y-tmp.n[2])^2 )
grid.text(w, tmp$x, tmp$y )
# downViewport('panel-1-1')
pushViewport(dataViewport(x,y))
tmp <- grid.locator('in')
tmp
tmp.n <- as.numeric(tmp)
tmp2.x <- as.numeric(convertX( unit(x,'native'), 'in' ))
tmp2.y <- as.numeric(convertY( unit(y,'native'), 'in' ))
w <- which.min( (tmp2.x-tmp.n[1])^2 + (tmp2.y-tmp.n[2])^2 )
grid.text(w, tmp$x, tmp$y )
downViewport('panel.3-4-3-4')
# downViewport('panel.3-4-3-4')
pushViewport(dataViewport(x, y, c(0,10), c(0.1, 0.5)))
view.x <- as.numeric(convertX( unit(x,'native'), 'in' ))
view.y <- as.numeric(convertY( unit(y,'native'), 'in' ))
w <- which.min((view.x-pick.n[1])^2 + (view.y-pick.n[2])^2)
pick.n <- as.numeric(pick)
pick<-grid.locator('in')
pick.n <- as.numeric(pick)
view.x <- as.numeric(convertX( unit(x,'native'), 'in' ))
view.y <- as.numeric(convertY( unit(y,'native'), 'in' ))
w <- which.min((view.x-pick.n[1])^2 + (view.y-pick.n[2])^2)
w
ggidentify <- function (x, y, labels, xscale=NULL, yscale=NULL) {
depth <- downViewport('panel.3-4-3-4')
pushViewport(dataViewport(x,y, xscale, yscale))
pick <- grid.locator('in')
while(!is.null(pick)) {
pick.n <- as.numeric(pick)
view.x <- as.numeric(convertX( unit(x,'native'), 'in' ))
view.y <- as.numeric(convertY( unit(y,'native'), 'in' ))
d <- min( (view.x-pick.n[1])^2 + (view.y-pick.n[2])^2 )
w <- which.min((view.x-pick.n[1])^2 + (view.y-pick.n[2])^2)
if (d>0.1) {
print("Closest point is too far")
} else {
popViewport(n=1)
upViewport(depth)
print(last_plot() + annotate("text", label=labels[w], x = x[w], y = y[w],
size = 5, hjust=-0.5, vjust=-0.5))
depth <- downViewport('panel.3-4-3-4')
pushViewport(dataViewport(x,y, xscale, yscale))
}
pick <- grid.locator('in')
}
popViewport(n=1)
upViewport(depth)
}
depth <- downViewport('panel.3-4-3-4')
pushViewport(dataViewport(x,y, xscale, yscale))
pick <- grid.locator('in')
while(!is.null(pick)) {
pick.n <- as.numeric(pick)
view.x <- as.numeric(convertX( unit(x,'native'), 'in' ))
view.y <- as.numeric(convertY( unit(y,'native'), 'in' ))
d <- min( (view.x-pick.n[1])^2 + (view.y-pick.n[2])^2 )
w <- which.min((view.x-pick.n[1])^2 + (view.y-pick.n[2])^2)
if (d>0.1) {
print("Closest point is too far")
} else {
popViewport(n=1)
upViewport(depth)
print(last_plot() + annotate("text", label=labels[w], x = x[w], y = y[w],
size = 5, hjust=-0.5, vjust=-0.5))
depth <- downViewport('panel.3-4-3-4')
pushViewport(dataViewport(x,y, xscale, yscale))
}
pick <- grid.locator('in')
}
dataViewport(x, y, c(0,10), c(0.1, 0.5))
# downViewport('panel.3-4-3-4')
pushViewport(dataViewport(x, y, c(0,10), c(0.1, 0.5)))
pushViewport
pick<-grid.locator('in')
current.viewport()
depth <- downViewport('GRID.VP.66')
current.viewport()
depth <- downViewport('ROOT')
current.parent()
current.parent(n=1)
sid = 297000
# sid = 297000
# print(sid)
i <- test_allFiles_mn$pos == sid # create a logical index
# get min date with an observation
subsetTemp2 <- subset(test_allFiles_mn, test_allFiles_mn$pos == sid &
test_allFiles_mn$coastDist >= 0 &
test_allFiles_mn$outlier != 0) # exclude detected outliers
outliers <- subset(subsetTemp2, outlier == 0)
nonOutliers <- subset(subsetTemp2, outlier == 1)
plot(as.Date(nonOutliers$DATE_ACQUIRED), nonOutliers$coastDist, ylim = c(min(subsetTemp2$coastDist)-30,max(subsetTemp2$coastDist)+ 30))
points(as.Date(outliers$DATE_ACQUIRED), outliers$coastDist, col = 'red')
nonOutliers
outliers
lm(nonOutliers$coastDist)
colnames(nonOutliers)
form = as.formula(paste(colnames(nonOutliers)[6], "~ ."))
form
lm.out <- lm(form, nonOutliers[, c(6, 3)])
lm.out
lm.out <- lm(form, nonOutliers[, c( 3)])
lm.out <- lm(form, nonOutliers[, c(6)])
lm.out
lm.out$model
lm.out$residuals
lm.out$fitted.values
lm(nonOutliers$coastDist ~ nonOutliers$DATE_ACQUIRED)
lm.out <- lm(nonOutliers$coastDist ~ nonOutliers$DATE_ACQUIRED)
lm.out
summary(lm.out)
lm.out$coefficients
