csv[,col_of_interest(csv, 'coastDist$')
]
test1transect <- subset(csv,csv[,col_of_interest(csv, 'originX$')]== uniqueX[1]
& csv[,col_of_interest(csv, 'coastDist$')] >= 0 )
plot(test1transect[,6])
?plot
plot(test1transect[,3], test1transect[,6])
as.Date(test1transect[,3])
plot(as.Date(test1transect[,3]), test1transect[,6])
View(test1transect)
test1transect <- subset(csv,csv[,col_of_interest(csv, 'originX$')]== uniqueX[1]
)
View(test1transect)
plot(as.Date(test1transect[,3]), test1transect[,6])
max(csv[,col_of_interest(csv, 'coastDist$')])
test1transect <- subset(csv,csv[,col_of_interest(csv, 'originX$')]== uniqueX[1]
& csv[,col_of_interest(csv, 'coastDist$')] >= 0 )
max(test1transect[,col_of_interest(csv, 'coastDist$')
])
test1transect[,col_of_interest(csv, 'coastDist$')]
max(test1transect[,col_of_interest(csv, 'coastDist$')])
max(test1transect[,col_of_interest(csv, 'coastDist$')])
min(test1transect[,col_of_interest(csv, 'coastDist$')])
?max
typeof(test1transect[,6])
as.numeric(test1transect[,6])
max(as.numeric(test1transect[,6]))
?which
test1transect[which.max(as.numeric(test1transect[,6])),]
test <- test1transect[which.max(as.numeric(test1transect[,6])),]
test
which.max(test1transect[,6])
test <- test1transect[which.max(test1transect[,6]),]
test
install.packages("ggplot2")
install.packages("rgdal")
install.packages("raster")
data.frame(test1transect[,col_of_interest(csv, 'originX$')])
data.frame(x = test1transect[,col_of_interest(csv, 'originX$')])
geom_point(data = data.frame(x = test1transect[,col_of_interest(csv, 'originX$')])
y = test1transect[,col_of_interest(csv, 'originY$')])
data.frame(x = test1transect[,col_of_interest(csv, 'originX$')],
y = test1transect[,col_of_interest(csv, 'originY$')])
geom_point(data = data.frame(x = test1transect[,col_of_interest(csv, 'originX$')],
y = test1transect[,col_of_interest(csv, 'originY$')]))
View(csv)
coods <- data.frame(x = test1transect[,col_of_interest(csv, 'coastX$')],
y = test1transect[,col_of_interest(csv, 'coastY$')])
install.packages("raster")
install.packages("rgdal")
# # library(plyr)
# # library(ggridges)
library(ggplot2)
# library(tidyverse)
# library(dplyr)
# library(reshape2)
# library(stringr)
#
library(rgdal)  # for reading/creating shapefiles
library(raster) # for stack & reading raster
# library(cowplot)
# library(cowplot)
# library(ggspatial) # for north arrow annotation ggRGB
# library(cowplot)
# library(ggspatial) # for north arrow annotation ggRGB
# # library(ggtern)
# library(cowplot)
# library(ggspatial) # for north arrow annotation ggRGB
# # library(ggtern)
# library(RStoolbox) # for ggRGB
# library(cowplot)
# library(ggspatial) # for north arrow annotation ggRGB
# # library(ggtern)
# library(RStoolbox) # for ggRGB
# library(data.table) # for fread
# library(cowplot)
# library(ggspatial) # for north arrow annotation ggRGB
# # library(ggtern)
# library(RStoolbox) # for ggRGB
# library(data.table) # for fread
# library(reshape2) # data melt
# library(cowplot)
# library(ggspatial) # for north arrow annotation ggRGB
# # library(ggtern)
# library(RStoolbox) # for ggRGB
# library(data.table) # for fread
# library(reshape2) # data melt
# library(maptools) # elide spatial line (rotate)
# library(plyr)
# library(plyr)
# library(egg) # for tagging facets
# library(plyr)
# library(egg) # for tagging facets
# library( rasterVis ) # for gPlot
# library(plyr)
# library(egg) # for tagging facets
# library( rasterVis ) # for gPlot
# library( gridExtra )
# library(plyr)
# library(egg) # for tagging facets
# library( rasterVis ) # for gPlot
# library( gridExtra )
# library(plyr)
# library(egg) # for tagging facets
# library( rasterVis ) # for gPlot
# library( gridExtra )
install.packages("sp")
# library(tidyverse)
# library(dplyr)
# library(reshape2)
# library(stringr)
library(sp)
coords <- data.frame(x = test1transect[,col_of_interest(csv, 'coastX$')],
y = test1transect[,col_of_interest(csv, 'coastY$')])
points <- SpatialPoints(coords)
coords
coords <- data.frame(x = as.numeric(test1transect[,col_of_interest(csv, 'coastX$')]),
y = as.numeric(test1transect[,col_of_interest(csv, 'coastY$')]))
points <- SpatialPoints(coords)
plot(points)
plot(as.Date(test1transect[,3]), test1transect[,6])
as.numeric(uniqueY)
colnames(csv)
end_coords <- data.frame(lon = as.numeric(uniqueX),
lat = as.numeric(uniqueY))
# all unique transect (id's)
uniqueX<- unique(csv[, col_of_interest(csv, 'originX$')])
uniqueY<- unique(csv[, col_of_interest(csv, 'originY$')])
begin_coords <- data.frame(lon = as.numeric(uniqueX),
lat = as.numeric(uniqueY))
uniqueX<- unique(csv[, col_of_interest(csv, 'endX$')])
uniqueY<- unique(csv[, col_of_interest(csv, 'endY$')])
# Coordinates on the original line
end_coords <- data.frame(lon = as.numeric(uniqueX),
lat = as.numeric(uniqueY))
# all unique transect (id's)
uniqueX<- unique(csv[, col_of_interest(csv, 'originX$')])
uniqueY<- unique(csv[, col_of_interest(csv, 'originY$')])
begin_coords <- data.frame(lon = as.numeric(uniqueX),
lat = as.numeric(uniqueY))
uniqueX<- unique(csv[, col_of_interest(csv, 'endX$')])
uniqueX
uniqueY<- unique(csv[, col_of_interest(csv, 'endY$')])
uniqueY
csv = as.matrix(read.csv2(as.character(df[3,1]),
header = T, sep = ',', na.strings=c("","NA"))) # rewrite as matrix to read columns as numeric values
dates <- col_of_interest(csv, 'DATE_ACQUIRED$')
coastDist <- col_of_interest(csv, 'coastDist$')
# all unique dates
uniqueDates <- unique(csv[,dates])
uniqueDates
source('D:/BackUp_D_mangroMud_202001/Research/Software/Projects/offshore_boundary/src/test.R', echo=TRUE)
uniqueX
uniqueXend
colnames()
colnames(csv)
geo<- unique(csv[, col_of_interest(csv, '.geo')])
geo
geo[1]
str_match(geo[1], ":[\\s*(.*?)\\s*]}")
install.packages("stringr")
# library(tidyverse)
# library(dplyr)
# library(reshape2)
library(stringr)
str_match(geo[1], ":[\\s*(.*?)\\s*]}")
geo[1]
as.char(geo[1])
as.character(geo[1])
str_match(as.character(geo[1]), ":[\\s*(.*?)\\s*]}")
# str_match(as.character(geo[1]), ":[\\s*(.*?)\\s*]}")
gsub(".*:[ (.+) ]}.*", "\\1", a)
# str_match(as.character(geo[1]), ":[\\s*(.*?)\\s*]}")
gsub(".*:[ (.+) ]}.*", "\\1", as.character(geo[1]))
# str_match(as.character(geo[1]), ":[\\s*(.*?)\\s*]}")
gsub(".*:[ (.+) ]}.*", "\\1", as.character(geo[1]))
as.character(geo[1])
as.character(geo[1,1])
typeof(as.character(geo[1]))
qdapRegex::ex_between(as.character(geo[1]), ":[", "]}")
install.packages("qdapRegex")
library(qdapRegex)
qdapRegex::ex_between(as.character(geo[1]), ":[", "]}")
# str_match(as.character(geo[1]), ":[\\s*(.*?)\\s*]}")
qdapRegex::ex_between(as.character(geo[1]), ":[", "]}")
# str_match(as.character(geo[1]), ":[\\s*(.*?)\\s*]}")
qdapRegex::ex_between(as.character(geo[1]), ":[", "]}")[[1]]
install.packages("readr")
library(readr)
parse_number(coords)
# str_match(as.character(geo[1]), ":[\\s*(.*?)\\s*]}")
coords <- qdapRegex::ex_between(as.character(geo[1]), ":[", "]}")[[1]]
parse_number(coords)
coords
regmatches(coords, gregexpr("[[:digit:]]+", coords))
all_digits <- regmatches(coords, gregexpr("[^[:digit:].]+", coords))
all_digits
all_digits <- regmatches(coords, gregexpr("[[:digit:].]+", coords))
all_digits
all_digits <- regmatches(coords, gregexpr("[[:digit:].]+", coords))[[1]]
all_digits
all_digits[1]
begin_coords <- data.frame(lon = as.numeric(all_digits[1]),
lat = as.numeric(all_digits[2]))
begin_coords
all_digits
# Coordinates on the original line
end_coords <- data.frame(lon = as.numeric(all_digits[3]),
lat = as.numeric(all_digits[4]))
x <- as.matrix(rbind(begin_coords, end_coords))
x
Line(x)
ID = as.character(AllTransects[n, 1])
list(Line(x))
Lines(list(Line(x)), ID = 1)
nrow(begin_coords)
lines <- vector('list', nrow(uniqueX)
)
uniqueX
length(uniqueX)
lines <- vector('list', length(uniqueX))
n = 1
lines[[n]] <- Lines(list(Line(x)), ID = n)
lines_sf <- SpatialLines(lines, proj4string = CRS(as.character(line@proj4string)))
lines[[n]] <- Lines(list(Line(x)), ID = n)
lines
n = 1
lines <- vector('list', n) #length(uniqueX)
lines[[n]] <- Lines(list(Line(x)), ID = n)
lines_sf <- SpatialLines(lines, proj4string = CRS(as.character(line@proj4string)))
lines_sf <- SpatialLines(lines) #, proj4string = CRS(as.character(line@proj4string))
lines[[n]] <- Lines(list(Line(x)), ID = n)
lines_sf <- SpatialLines(lines) #, proj4string = CRS(as.character(line@proj4string))
lines_sf
plot(lines_sf)
plot(points, add = T, col = 'red')
points <- SpatialPoints(coords, proj4string=CRS(as.character(NA)))
coords <- data.frame(x = as.numeric(test1transect[,col_of_interest(csv, 'coastX$')]),
y = as.numeric(test1transect[,col_of_interest(csv, 'coastY$')]))
test1transect
test1transect <- subset(csv,csv[,col_of_interest(csv, 'originX$')]== uniqueX[1]
& csv[,col_of_interest(csv, 'coastDist$')] >= 0 )
maxCoastDist <- test1transect[max(test1transect[,col_of_interest(csv, 'coastDist$')]),]
testMax <- test1transect[which.max(test1transect[,6]),]
coords <- data.frame(x = as.numeric(test1transect[,col_of_interest(csv, 'coastX$')]),
y = as.numeric(test1transect[,col_of_interest(csv, 'coastY$')]))
points <- SpatialPoints(coords, proj4string=CRS(as.character(NA)))
plot(points, add = T, col = 'red')
plot(points)
View(points)
head(points)
head(lines)
geo
coords
all_digits
# str_match(as.character(geo[1]), ":[\\s*(.*?)\\s*]}")
coords <- qdapRegex::ex_between(as.character(geo[1]), ":[", "]}")[[1]]
coords
all_digits
all_digits <- regmatches(coords, gregexpr("[-[:digit:].]+", coords))[[1]]
all_digits
begin_coords <- data.frame(lon = as.numeric(all_digits[1]),
lat = as.numeric(all_digits[2]))
# Coordinates on the original line
end_coords <- data.frame(lon = as.numeric(all_digits[3]),
lat = as.numeric(all_digits[4]))
x <- as.matrix(rbind(begin_coords, end_coords))
n = 1
lines <- vector('list', n) #length(uniqueX)
lines[[n]] <- Lines(list(Line(x)), ID = n)
lines_sf <- SpatialLines(lines) #, proj4string = CRS(as.character(line@proj4string))
plot(lines_sf)
test1transect <- subset(csv,csv[,col_of_interest(csv, 'originX$')]== uniqueX[1]
& csv[,col_of_interest(csv, 'coastDist$')] >= 0 )
testMax <- test1transect[which.max(test1transect[,6]),]
coords <- data.frame(x = as.numeric(test1transect[,col_of_interest(csv, 'coastX$')]),
y = as.numeric(test1transect[,col_of_interest(csv, 'coastY$')]))
points <- SpatialPoints(coords, proj4string=CRS(as.character(NA)))
plot(points, add = T, col = 'red')
length(uniqueX)
1:length(uniqueX)
geo
lines <- vector('list', length(uniqueX))
lines
coords <- qdapRegex::ex_between(as.character(geo[n]), ":[", "]}")[[1]]
for (n in 1:length(uniqueX)){
coords <- qdapRegex::ex_between(as.character(geo[n]), ":[", "]}")[[1]]
all_digits <- regmatches(coords, gregexpr("[-[:digit:].]+", coords))[[1]]
begin_coords <- data.frame(lon = as.numeric(all_digits[1]),
lat = as.numeric(all_digits[2]))
end_coords <- data.frame(lon = as.numeric(all_digits[3]),
lat = as.numeric(all_digits[4]))
x <- as.matrix(rbind(begin_coords, end_coords))
lines[[n]] <- Lines(list(Line(x)), ID = n)
# lines_sf <- SpatialLines(lines)
}
lines
lines_sf <- SpatialLines(lines)
lines_sf
plot(lines_sf)
uniqueX[1]
test1transect <- subset(csv,csv[,col_of_interest(csv, 'originX$')]== uniqueX[n]
& csv[,col_of_interest(csv, 'coastDist$')] >= 0 )
test1transect
# lines_sf <- SpatialLines(lines)
coords <- data.frame(x = as.numeric(test1transect[,col_of_interest(csv, 'coastX$')]),
y = as.numeric(test1transect[,col_of_interest(csv, 'coastY$')]))
points <- SpatialPoints(coords, proj4string=CRS(as.character(NA)))
plot(points, add = T, col = 'red')
n
test1transect <- subset(csv,csv[,col_of_interest(csv, 'originX$')]== uniqueX[1]
& csv[,col_of_interest(csv, 'coastDist$')] >= 0 )
# lines_sf <- SpatialLines(lines)
coords <- data.frame(x = as.numeric(test1transect[,col_of_interest(csv, 'coastX$')]),
y = as.numeric(test1transect[,col_of_interest(csv, 'coastY$')]))
points <- SpatialPoints(coords, proj4string=CRS(as.character(NA)))
plot(points, add = T, col = 'red')
length(csv)
points <- vector('list', length(csv))
allPoints <- vector('list', length(csv))
# lines_sf <- SpatialLines(lines)
coords <- data.frame(x = as.numeric(test1transect[,col_of_interest(csv, 'coastX$')]),
y = as.numeric(test1transect[,col_of_interest(csv, 'coastY$')]))
allPoints <- rowbind(allPoints, coords)
allPoints <- rbind(allPoints, coords)
allPoints <- rbind(allPoints, coords)
points <- SpatialPoints(allPoints, proj4string=CRS(as.character(NA)))
plot(points, add = T, col = 'red')
rm(list = ls())
#' set working directory for Mac and PC
wd<-getwd()
setwd("D:/BackUp_D_mangroMud_202001/Research/Software/Projects/offshore_boundary")
## ---------------------------
options(scipen = 6, digits = 4) # I prefer to view outputs in non-scientific notation
memory.limit(30000000)     # this is needed on some PCs to increase memory allowance, but has no impact on macs.
## ---------------------------
#' load up the packages
source("./src/packages.R")       # loads up all the packages we need
## ---------------------------
source("./src/functions.R")
## ---------------------------
dataFolder <- './data/raw'
# transect  <- readOGR(paste0(dataFolder, '/transects'), '2009_WnZ_transect')
# select folders
folderSelect <- as.matrix(list.files(paste0(dataFolder, '/GEE_exports'), full.names = T))
# metaMatrix <- as.matrix(list.files(folderSelect, pattern=".csv", full.names = T))
df <- rewrite(folderSelect)
csv = as.matrix(read.csv2(as.character(df[3,1]),
header = T, sep = ',', na.strings=c("","NA"))) # rewrite as matrix to read columns as numeric values
dates <- col_of_interest(csv, 'DATE_ACQUIRED$')
coastDist <- col_of_interest(csv, 'coastDist$')
# all unique dates
uniqueDates <- unique(csv[,dates])
# all unique transect (id's)
uniqueX<- unique(csv[, col_of_interest(csv, 'originX$')])
uniqueY<- unique(csv[, col_of_interest(csv, 'originY$')])
geo<- unique(csv[, col_of_interest(csv, '.geo')])
lines <- vector('list', length(uniqueX))
allPoints <- vector('list', length(csv))
for (n in 1:length(uniqueX)){
coords <- qdapRegex::ex_between(as.character(geo[n]), ":[", "]}")[[1]]
all_digits <- regmatches(coords, gregexpr("[-[:digit:].]+", coords))[[1]]
begin_coords <- data.frame(lon = as.numeric(all_digits[1]),
lat = as.numeric(all_digits[2]))
end_coords <- data.frame(lon = as.numeric(all_digits[3]),
lat = as.numeric(all_digits[4]))
x <- as.matrix(rbind(begin_coords, end_coords))
lines[[n]] <- Lines(list(Line(x)), ID = n)
test1transect <- subset(csv,csv[,col_of_interest(csv, 'originX$')]== uniqueX[1]
& csv[,col_of_interest(csv, 'coastDist$')] >= 0 )
# lines_sf <- SpatialLines(lines)
coords <- data.frame(x = as.numeric(test1transect[,col_of_interest(csv, 'coastX$')]),
y = as.numeric(test1transect[,col_of_interest(csv, 'coastY$')]))
allPoints <- rbind(allPoints, coords)
}
points <- SpatialPoints(allPoints, proj4string=CRS(as.character(NA)))
lines_sf <- SpatialLines(lines)
plot(lines_sf)
plot(points, add = T, col = 'red')
points <- SpatialPoints(allPoints, proj4string=CRS(as.character(NA)))
plot(points, add = T, col = 'red')
View(allPoints)
lines <- vector('list', length(uniqueX))
allPoints <- vector('list', length(csv))
for (n in 1:length(uniqueX)){
coords <- qdapRegex::ex_between(as.character(geo[n]), ":[", "]}")[[1]]
all_digits <- regmatches(coords, gregexpr("[-[:digit:].]+", coords))[[1]]
begin_coords <- data.frame(lon = as.numeric(all_digits[1]),
lat = as.numeric(all_digits[2]))
end_coords <- data.frame(lon = as.numeric(all_digits[3]),
lat = as.numeric(all_digits[4]))
x <- as.matrix(rbind(begin_coords, end_coords))
lines[[n]] <- Lines(list(Line(x)), ID = n)
test1transect <- subset(csv,csv[,col_of_interest(csv, 'originX$')]== uniqueX[n]
& csv[,col_of_interest(csv, 'coastDist$')] >= 0 )
# lines_sf <- SpatialLines(lines)
coords <- data.frame(x = as.numeric(test1transect[,col_of_interest(csv, 'coastX$')]),
y = as.numeric(test1transect[,col_of_interest(csv, 'coastY$')]))
allPoints <- rbind(allPoints, coords)
}
points <- SpatialPoints(allPoints, proj4string=CRS(as.character(NA)))
lines_sf <- SpatialLines(lines)
plot(lines_sf)
plot(points, add = T, col = 'red')
i
rm(list = ls())
#' set working directory for Mac and PC
wd<-getwd()
setwd("I:/BackUp_D_mangroMud_202001/Research/Software/Projects/offshore_boundary")
options(scipen = 6, digits = 4) # I prefer to view outputs in non-scientific notation
memory.limit(30000000)     # this is needed on some PCs to increase memory allowance, but has no impact on macs.
#' load up the packages
source("./src/packages.R")       # loads up all the packages we need
## ---------------------------
source("./src/functions.R")
dataFolder <- './data/raw'
# select folders
folderSelect <- as.matrix(list.files(paste0(dataFolder, '/GEE_exports'), full.names = T))
df <- rewrite(folderSelect)
df
df
csv = as.matrix(read.csv2(as.character(df[3,1]),
header = T, sep = ',', na.strings=c("","NA"))) # rewrite as matrix to read columns as numeric values
dates <- col_of_interest(csv, 'DATE_ACQUIRED$')
coastDist <- col_of_interest(csv, 'coastDist$')
# all unique dates
uniqueDates <- unique(csv[,dates])
# all unique transect (id's)
uniqueX<- unique(csv[, col_of_interest(csv, 'originX$')])
uniqueY<- unique(csv[, col_of_interest(csv, 'originY$')])
geo<- unique(csv[, col_of_interest(csv, '.geo')])
lines <- vector('list', length(uniqueX))
allPoints <- vector('list', length(csv))
qdapRegex::ex_between(as.character(geo[n]), ":[", "]}")[[1]]
install.packages("qdapRegex")
coords <- qdapRegex::ex_between(as.character(geo[n]), ":[", "]}")[[1]]
library(qdapRegex)
n<-1
coords <- qdapRegex::ex_between(as.character(geo[n]), ":[", "]}")[[1]]
coords
geo[n]
all_digits <- regmatches(coords, gregexpr("[-[:digit:].]+", coords))[[1]]
all_digits
begin_coords <- data.frame(lon = as.numeric(all_digits[1]),
lat = as.numeric(all_digits[2]))
begin_coords
end_coords <- data.frame(lon = as.numeric(all_digits[3]),
lat = as.numeric(all_digits[4]))
end_coords
x <- as.matrix(rbind(begin_coords, end_coords))
x
lines[[n]] <- Lines(list(Line(x)), ID = n)
test1transect <- subset(csv,csv[,col_of_interest(csv, 'originX$')]== uniqueX[n]
& csv[,col_of_interest(csv, 'coastDist$')] >= 0 )
rm(list = ls())
#' set working directory for Mac and PC
wd<-getwd()
setwd("I:/BackUp_D_mangroMud_202001/Research/Software/Projects/offshore_boundary")
## ---------------------------
options(scipen = 6, digits = 4) # I prefer to view outputs in non-scientific notation
memory.limit(30000000)     # this is needed on some PCs to increase memory allowance, but has no impact on macs.
## ---------------------------
#' load up the packages
source("./src/packages.R")       # loads up all the packages we need
## ---------------------------
source("./src/functions.R")
## ---------------------------
dataFolder <- './data/raw'
# transect  <- readOGR(paste0(dataFolder, '/transects'), '2009_WnZ_transect')
# select folders
folderSelect <- as.matrix(list.files(paste0(dataFolder, '/GEE_exports'), full.names = T))
# metaMatrix <- as.matrix(list.files(folderSelect, pattern=".csv", full.names = T))
df <- rewrite(folderSelect)
csv = as.matrix(read.csv2(as.character(df[3,1]),
header = T, sep = ',', na.strings=c("","NA"))) # rewrite as matrix to read columns as numeric values
dates <- col_of_interest(csv, 'DATE_ACQUIRED$')
coastDist <- col_of_interest(csv, 'coastDist$')
# all unique dates
uniqueDates <- unique(csv[,dates])
# all unique transect (id's)
uniqueX<- unique(csv[, col_of_interest(csv, 'originX$')])
uniqueY<- unique(csv[, col_of_interest(csv, 'originY$')])
geo<- unique(csv[, col_of_interest(csv, '.geo')])
lines <- vector('list', length(uniqueX))
allPoints <- vector('list', length(csv))
for (n in 1:length(uniqueX)){
#n<-1
coords <- qdapRegex::ex_between(as.character(geo[n]), ":[", "]}")[[1]]
all_digits <- regmatches(coords, gregexpr("[-[:digit:].]+", coords))[[1]]
begin_coords <- data.frame(lon = as.numeric(all_digits[1]),
lat = as.numeric(all_digits[2]))
end_coords <- data.frame(lon = as.numeric(all_digits[3]),
lat = as.numeric(all_digits[4]))
x <- as.matrix(rbind(begin_coords, end_coords))
lines[[n]] <- Lines(list(Line(x)), ID = n)
test1transect <- subset(csv,csv[,col_of_interest(csv, 'originX$')]== uniqueX[n]
& csv[,col_of_interest(csv, 'coastDist$')] >= 0 )
# lines_sf <- SpatialLines(lines)
coords <- data.frame(x = as.numeric(test1transect[,col_of_interest(csv, 'coastX$')]),
y = as.numeric(test1transect[,col_of_interest(csv, 'coastY$')]))
allPoints <- rbind(allPoints, coords)
}
points <- SpatialPoints(allPoints, proj4string=CRS(as.character(NA)))
lines_sf <- SpatialLines(lines)
plot(lines_sf)
plot(points, add = T, col = 'red')
install.packages("rgeos")
library(rgeos)
?gProject()
rm(list=ls())
rm(list=ls())
library(zoo)
