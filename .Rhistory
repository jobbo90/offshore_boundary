#   end <- length(trajx)
#
#   if(end==2){
#     index <- 1
#     dmax <- 0
#   }else{
#     for(i in 2:(end-1)){ # for each point but the first and last
#       i <- 2
#       # calculate the distance
#       d <- shortestDistanceToLines(Mx=trajx[i],My=trajy[i], Ax=trajx[1],Ay=trajy[1], Bx=trajx[end],By=trajy[end])
#       if ( d < dmax ) {
#         # update dmax & index with the distance
#         # in the end only the max distance is included (due to the if(d>dmax))
#         index <- i
#         dmax <- d
#       }else{} # don't do anything
#     }
#   }
#
#   output <- c(index, dmax)
#   names(output) <- c('index', 'dmax')
#
#   return(output)
#   # return(c(index=index,dmax=dmax))
# }
# nearestPoint <- findClosestPoint_manual(geom_ordered[range,1],geom_ordered[range,2])
# points( geom_ordered[nearestPoint['index'],1], geom_ordered[nearestPoint['index'],2],type="p", col = 'green')
# segments(trajx[1],trajy[1],  trajx[end], trajy[end])
# farestPoint <- findFarestPoint_manual(geom_ordered[range,1], geom_ordered[range,2])
# points(geom_ordered[farestPoint['index'],1], geom_ordered[farestPoint['index'],2],type="p", col = 'green')
}
first+mapview(coastlines_selection, col.regions = c("red"), layer.name = i) +
mapview(mudbanks_selection, col.regions = c("green"), layer.name = 'non outlier' ) +
mapview(mudbank_selection_Outlier, col.regions = c("orange"), layer.name = 'outlier' )
#' implement workflow
#' 1) filter outliers
#'     - Filter on neighborhood (previous 2, current and next two points)
#'     Use distance to see if the point is deviating
#'     Consider using fraction..
#' 2) Apply douglas pecker algorithm
#'      - Requires to define subsections (see https://www.tandfonline.com/doi/pdf/10.1559/152304099782424901?casa_token=9wn9uSUp3zYAAAAA:XYDB0pKcZcH69STl6eOAlKoMPEwIbvxtlwUwzZ00q4V-z8yOfAREUCePnd4fiZbS9H2A-woJqt0mIg  )
#'      to ensure separate mudbanks are recognized
#'
# all unique dates
uniqueDates <- unique(allFiles[,col_dates]);
# or get around a reference date
reference_date <- as.Date("2009-11-15")
test <- which.min(abs(as.Date(uniqueDates) - reference_date))
uniqueDates <- uniqueDates[1:length(uniqueDates) == test]
uniqueDates
first+mapview(coastlines_selection, col.regions = c("red"), layer.name = i) +
mapview(mudbanks_selection, col.regions = c("green"), layer.name = 'non outlier' ) +
mapview(mudbank_selection_Outlier, col.regions = c("orange"), layer.name = 'outlier' )
#' implement workflow
#' 1) filter outliers
#'     - Filter on neighborhood (previous 2, current and next two points)
#'     Use distance to see if the point is deviating
#'     Consider using fraction..
#' 2) Apply douglas pecker algorithm
#'      - Requires to define subsections (see https://www.tandfonline.com/doi/pdf/10.1559/152304099782424901?casa_token=9wn9uSUp3zYAAAAA:XYDB0pKcZcH69STl6eOAlKoMPEwIbvxtlwUwzZ00q4V-z8yOfAREUCePnd4fiZbS9H2A-woJqt0mIg  )
#'      to ensure separate mudbanks are recognized
#'
# all unique dates
uniqueDates <- unique(allFiles[,col_dates]);
for (i in uniqueDates){
# i <- uniqueDates[3]
# i <- uniqueDates[uniqueDates == as.Date(id)]
# select relevant observations
coastlines_selection <-subset(coastlines, coastlines$DATE_ACQUIRED == i &
coastlines$coastDist >= 0)
mudbanks_selection <-subset(mudbanks, mudbanks$DATE_ACQUIRED == i &
mudbanks$axisDist >= 0 &
mudbanks$distance >= 0) # still to test....
# give all excluded observation an 1 for outlier in original
# to keep track of all outliers.
mudbanks[which(mudbanks$DATE_ACQUIRED == i &
mudbanks$axisDist < 0 &
mudbanks$distance < 0), "outlier"] <-
as.data.frame(mudbanks[
which(mudbanks$DATE_ACQUIRED == i &
mudbanks$axisDist < 0 &
mudbanks$distance < 0),"outlier"])[,1] + 1
# order
coastlines_selection[order(as.character(coastlines_selection$pos)),]
mudbanks_selection<-mudbanks_selection[order(as.numeric(as.character(mudbanks_selection$pos))),]
# collection for testing
filtCollect <- collection$filterDate(as.character(as.Date(i)-1), as.character(as.Date(i)+1))
dates <- ee_get_date_ic(filtCollect, time_end = FALSE)
first <- Map$addLayer(filtCollect$first(), visParams, paste0(i))
Map$centerObject(filtCollect$first())
# # plot
# first+mapview(coastlines_selection, col.regions = c("red"), layer.name = 'coastline') +
# mapview(mudbanks_selection, col.regions = c("green"), layer.name = 'mudbanks' )
# outlier test full set of points:
positions_all <- as.numeric(as.character(mudbanks_selection$pos))
distances_all <-mudbanks_selection$distance # grab the normalized distances
# second order polynomial fit: alongshore position & polynomial fit
lm_out_all <-lm(distances_all ~ poly(as.numeric(positions_all),2))
predicted.intervals <- predict(lm_out_all,
data.frame(x=as.numeric(positions_all)),
interval='confidence', level=0.99)
# Bonferroni-adjusted outlier test (test largest absolute standardized residual)
outlier_test <- car::outlierTest(lm_out_all)
outlier_ind<-as.numeric(names(outlier_test$rstudent))
# Give outlier +1 in the source file to keep track
mudbanks[which(mudbanks$DATE_ACQUIRED == i &
mudbanks$pos %in% positions_all[outlier_ind]), "outlier"] <-
as.data.frame(mudbanks[
which(mudbanks$DATE_ACQUIRED == i &
mudbanks$pos %in% positions_all[outlier_ind]),"outlier"])[,1] + 1
# drop the most obvious outliers from the selection
mudbanks_selection <- mudbanks_selection[-outlier_ind, ]
# plot
# plot(positions_all, distances_all)
# lines(positions_all, predicted.intervals[,1],col='green',lwd=3)
# points(positions_all[outlier_ind],distances_all[outlier_ind], col = 'red')
# sanity check:
# points( as.numeric(as.character(mudbanks_selection$pos)), mudbanks_selection$distance, col = 'blue')
for (pnt in 1:nrow(mudbanks_selection)){
# pos_of_interst <- 91000 #130000
# selected_point <-mudbanks_selection[which(mudbanks_selection$pos == pos_of_interst),]
selected_point <-mudbanks_selection[pnt,]
# select nearby points
# a) nearest 2?
# b) based on pos
ajoining_points <- subset(mudbanks_selection, as.character(pos) <=  as.numeric(as.character(selected_point$pos))+4000 &
as.character(pos) >= as.numeric(as.character(selected_point$pos))-4000 &
as.character(pos) != as.numeric(as.character(selected_point$pos)))
combined <- rbind(selected_point,ajoining_points)
# order by pos
combined_ordered <-combined[order(as.numeric(as.character(combined$pos))),]
# plot selected points
# first +
# mapview(mudbanks_selection, col.regions = c("blue"), layer.name = c('mudbanks_selection')) +
# mapview(selected_point, col.regions = c("red"), layer.name = c('selected_point')) +
# mapview(ajoining_points, col.regions = c("green"), layer.name = c('ajoining_points'))
positions<- as.numeric(as.character(combined_ordered$pos))
distances <-combined_ordered$distance # grap the normalized distances
fractions <- combined_ordered$mudFract
datatest <- data.frame(positions=positions,distances=distances, fractions = fractions)
# test <- loess(distances ~ a +(positions*b) + (c*positions) + (d*positions*distances) + e*positions^2 + f*distances^2,
#               data = datatest,
#               start = list(a=1, b = 1, c = 1, d = 1, e = 1, f =1), span=.75)
# # https://stats.stackexchange.com/questions/176361/trouble-in-fitting-data-to-a-curve-nls?noredirect=1&lq=1
# plot(positions,fractions, col ='red')
# abline(lm(datatest$fractions~as.numeric(datatest$positions)),lty = 2)
# plot(fractions, distances, col = 'blue')
# abline(lm(datatest$distances~as.numeric(datatest$fractions)),lty = 2)
#
# when sufficient observations calculate second order polynomial
if (length(unique(datatest$distances)) > 2) {
# # calculate linear fit
lm.out_lin <- lm(datatest$distances~as.numeric(datatest$positions))
# calculate second order polynomial
lm.out<-lm(datatest$distances ~ poly(as.numeric(datatest$positions),2))
r2 <- summary(lm.out)$r.squared # or adjusted r2?
p <- summary(lm.out)                # should be <0.05?
fstat <- summary(lm.out)$fstatistic #
# summary(lm.out)
# plot
# plot(positions, distances)
# abline(lm(datatest$distances~as.numeric(datatest$positions)),lty = 2)
# plot(fitted(lm.out),residuals(lm.out))
# or B-splines?
# splines <- lm(datatest$distances ~ bs(as.numeric(datatest$positions), df = 10))
pred.int <- predict(lm.out,data.frame(x=positions),
interval='confidence',level=0.99)
# lines(positions, pred.int[,1],col='green',lwd=3)
intercept <-lm.out$coefficients[1]
slope <- lm.out$coefficients[2]
# potential benefit: slope says something about direction; negative slope; front of mudbank
# low pos > further east, decreasing distance ==> front of mud bank.
# only in case of mudbank
# residuals
resid <- lm.out$residuals
maxResid <- which.max(abs(resid))
# # cookds distance > 1 considered as outlier?
# cooksd <- cooks.distance(lm.out)
# plot(cooksd, pch="*", cex=2, main="Influential Obs by Cooks distance")
# abline(h = 4*mean(cooksd, na.rm=T), col="red")
#
# influential <- as.numeric(names(cooksd)[(cooksd > (4/nrow(datatest)))])
# # outliers test
# # https://statsandr.com/blog/how-to-do-a-t-test-or-anova-for-many-variables-at-once-in-r-and-communicate-the-results-in-a-better-way/
# outlier_test <- car::outlierTest(lm.out) # Bonferroni-adjusted outlier test (test largest absolute standardized residual)
test2 <- has_error(car::outlierTest(lm.out), silent = !interactive())
test3 <- has_warning(car::outlierTest(lm.out))
outlier_test <- if(test2|test3){car::outlierTest(lm.out_lin)} else{car::outlierTest(lm.out)}
# if no outliers detected:
# allways returns one point to ensure continuation of worklfow
# point with a Pos outside the range is selected
outlierIndex <- ifelse(length(outlier_test$rstudent) > 0,
as.numeric(as.character(combined_ordered[as.numeric(names(outlier_test$rstudent)),]$pos)),
min(as.numeric(as.character(mudbanks_selection$pos)))-1000)
# drop outlier ==> not sure if necessary
# might be necessary if re-run this script for second sweep
# new_dataTest <- datatest[-outlierIndex,]
# for (ind in 1:length(outlierIndex)){
#   corresponding_pos <- as.numeric(as.character(combined_ordered[outlierIndex,]$pos))
#
#
#   mudbanks[which(mudbanks$pos == corresponding_pos &
#                    mudbanks$DATE_ACQUIRED == i), "outlier"] <-
#     as.data.frame(mudbanks[which(row.names(mudbanks) == row.names(selected_point)),"outlier"])[,1] + 1
#
# }
} else { # stop("'degree' must be less than number of unique points")
# if only 1 observation; cannot determine if outlier based on neighbours
outlierIndex <- min(as.numeric(as.character(mudbanks_selection$pos)))-1000
}
if (outlierIndex == as.numeric(as.character(selected_point$pos))){
mudbanks[which(row.names(mudbanks) == row.names(selected_point)), "outlier"] <-
as.data.frame(mudbanks[
which(row.names(mudbanks) ==
row.names(selected_point)),"outlier"])[,1] + 1
}
}
# redefine mudbank selection
mudbanks_selection <-subset(mudbanks, mudbanks$DATE_ACQUIRED == i &
mudbanks$axisDist >= 0 &
outlier == 0)
mudbank_selection_Outlier <- subset(mudbanks, mudbanks$DATE_ACQUIRED == i &
mudbanks$axisDist >= 0 &
outlier >= 1)
# geom <- st_coordinates(ajoining_points)
# test_spline<-smooth.spline(geom[,1] ~ geom[,2], spar=0.50)
#
# SpatialPoints <- SpatialPointsDataFrame(data.frame(test_spline$y, test_spline$x ),
#                                         data = data.frame(DATE_ACQUIRED = ajoining_points$DATE_ACQUIRED,
#                                                           mudFract = ajoining_points$mudFract),
#                                         proj4string=CRS("+proj=longlat +datum=WGS84"))
# points_sf <- st_as_sf(SpatialPoints)
# https://gis.stackexchange.com/questions/68359/creating-average-polygon
# if dist < threshold (e.g. 0.01?) then keep
# else check for index value, if sufficient: keep it
# http://www.scielo.br/scielo.php?script=sci_arttext&pid=S0104-65002004000100006
# http://www.geoinfo.info/proceedings_geoinfo2006.split/paper1.pdf
# https://www.tandfonline.com/doi/pdf/10.1559/152304099782424901?casa_token=9wn9uSUp3zYAAAAA:XYDB0pKcZcH69STl6eOAlKoMPEwIbvxtlwUwzZ00q4V-z8yOfAREUCePnd4fiZbS9H2A-woJqt0mIg
# test douglasPeuckerEpsilon
# library(kmlShape)
# plot(combined_ordered$x, combined_ordered$y)
# functionD <- DouglasPeuckerEpsilon(trajx = combined_ordered$x,trajy = combined_ordered$y, epsilon = 0.0001, spar = NA)
# testD <- DouglasPeuckerNbPoints( geom_ordered[range,1], trajy = geom_ordered[range,2], 2, spar=NA)
# points( testD[,1], testD[,2],type="p", col = 'red')
# points( functionD[,1], functionD[,2],type="p", col = 'red')
# douglas pecker algorithm looks at the points that are furthest away from line, if large enough: included as vertext.
# this assumes outliers are filtered sufficiently
# e.g. first filter (e.g. by using a spline function (spar in Douglas function))
# or manual filter that looks at a combination of distance on a line, and the fraction (within a range)
# Alternatively; inverse of douglas filtering.
# Look at point, if it's distance is to far away exclude it
# But that will only work if whe apply it on sub polylines that are on a imaginary line that corresponds to a boundary
# http://www.scielo.br/scielo.php?script=sci_arttext&pid=S0104-65002004000100006
#   findClosestPoint_manual <- function(trajx,trajy){
#
#   trajx <- geom_ordered[range,1]
#   trajy <- geom_ordered[range,2]
#
#   dmax <- 1
#   index <- 1
#   end <- length(trajx)
#
#   if(end==2){
#     index <- 1
#     dmax <- 0
#   }else{
#     for(i in 2:(end-1)){ # for each point but the first and last
#       i <- 2
#       # calculate the distance
#       d <- shortestDistanceToLines(Mx=trajx[i],My=trajy[i], Ax=trajx[1],Ay=trajy[1], Bx=trajx[end],By=trajy[end])
#       if ( d < dmax ) {
#         # update dmax & index with the distance
#         # in the end only the max distance is included (due to the if(d>dmax))
#         index <- i
#         dmax <- d
#       }else{} # don't do anything
#     }
#   }
#
#   output <- c(index, dmax)
#   names(output) <- c('index', 'dmax')
#
#   return(output)
#   # return(c(index=index,dmax=dmax))
# }
# nearestPoint <- findClosestPoint_manual(geom_ordered[range,1],geom_ordered[range,2])
# points( geom_ordered[nearestPoint['index'],1], geom_ordered[nearestPoint['index'],2],type="p", col = 'green')
# segments(trajx[1],trajy[1],  trajx[end], trajy[end])
# farestPoint <- findFarestPoint_manual(geom_ordered[range,1], geom_ordered[range,2])
# points(geom_ordered[farestPoint['index'],1], geom_ordered[farestPoint['index'],2],type="p", col = 'green')
}
mudbanks_selection <-subset(mudbanks, mudbanks$DATE_ACQUIRED == reference_date &
mudbanks$axisDist >= 0 &
mudbanks$distance >= 0)
mudbanks$DATE_ACQUIRED == reference_date
mudbanks_selection
mudbanks_selection <-subset(mudbanks, as.Date(mudbanks$DATE_ACQUIRED) == reference_date &
mudbanks$axisDist >= 0 &
mudbanks$distance >= 0)
mudbanks_selection
mudbanks_selection <-subset(mudbanks, as.Date(mudbanks$DATE_ACQUIRED) == reference_date &
mudbanks$axisDist >= 0 &
outlier == 0)
mudbank_selection_Outlier <- subset(mudbanks, as.Date(mudbanks$DATE_ACQUIRED) == reference_date &
mudbanks$axisDist >= 0 &
outlier >= 1)
first+mapview(coastlines_selection, col.regions = c("red"), layer.name = i) +
mapview(mudbanks_selection, col.regions = c("green"), layer.name = 'non outlier' ) +
mapview(mudbank_selection_Outlier, col.regions = c("orange"), layer.name = 'outlier' )
plot(mudbanks_selection$DATE_ACQUIRED, mudbanks_selection$distance)
plot(mudbanks_selection$pos, mudbanks_selection$distance)
mudbanks_selection <-subset(mudbanks, as.Date(mudbanks$DATE_ACQUIRED) == reference_date &
mudbanks$axisDist >= 0 &
mudbanks$distance >= 0 &
outlier == 0)
mudbank_selection_Outlier <- subset(mudbanks, as.Date(mudbanks$DATE_ACQUIRED) == reference_date &
mudbanks$axisDist >= 0 &
outlier >= 1)
first+mapview(coastlines_selection, col.regions = c("red"), layer.name = i) +
mapview(mudbanks_selection, col.regions = c("green"), layer.name = 'non outlier' ) +
mapview(mudbank_selection_Outlier, col.regions = c("orange"), layer.name = 'outlier' )
plot(mudbanks_selection$pos, mudbanks_selection$distance)
points(mudbank_selection_Outlier$pos, mudbanks_selection$distance, col = 'red')
points(mudbank_selection_Outlier$pos, mudbank_selection_Outlier$distance, col = 'red')
plot(mudbanks_selection$pos, mudbanks_selection$distance)
points(mudbank_selection_Outlier$pos, mudbank_selection_Outlier$distance, col = 'red')
plot(mudbanks_selection$pos, mudbanks_selection$distance)
points(coastlines_selection$pos, coastlines_selection$coastDist)
plot(mudbanks_selection$pos, mudbanks_selection$distance)
points(mudbank_selection_Outlier$pos, mudbank_selection_Outlier$distance, col = 'red')
plot(mudbanks_selection$pos, mudbanks_selection$distance)
# plot one example
reference_date <- as.Date("2009-09-15")
# plot one example
reference_date <- as.Date("2009-09-12")
test <- which.min(abs(as.Date(uniqueDates) - reference_date))
test
mudbanks_selection <-subset(mudbanks, as.Date(mudbanks$DATE_ACQUIRED) == reference_date &
mudbanks$axisDist >= 0 &
mudbanks$distance >= 0 &
outlier == 0)
mudbank_selection_Outlier <- subset(mudbanks, as.Date(mudbanks$DATE_ACQUIRED) == reference_date &
mudbanks$axisDist >= 0 &
outlier >= 1)
plot(mudbanks_selection$pos, mudbanks_selection$distance)
points(mudbank_selection_Outlier$pos, mudbank_selection_Outlier$distance, col = 'red')
plot(mudbanks_selection$pos, mudbanks_selection$distance)
mudbanks_selection <-subset(mudbanks, as.Date(mudbanks$DATE_ACQUIRED) == reference_date &
mudbanks$axisDist >= 0 &
mudbanks$distance >= 0 &
outlier == 0)
mudbanks_selection <-subset(mudbanks[order(mudbanks$pos),], as.Date(mudbanks$DATE_ACQUIRED) == reference_date &
mudbanks$axisDist >= 0 &
mudbanks$distance >= 0 &
outlier == 0)
View(mudbanks_selection)
mudbanks_selection <-subset(mudbanks, as.Date(mudbanks$DATE_ACQUIRED) == reference_date &
mudbanks$axisDist >= 0 &
mudbanks$distance >= 0 &
outlier == 0)
mudbanks_selection <- mudbanks_selection[order(mudbanks_selection$pos),]
View(mudbanks_selection)
mudbanks$pos
mudbanks_selection <-subset(mudbanks[order(as.numeric(as.character(mudbanks$pos))),],
as.Date(mudbanks$DATE_ACQUIRED) == reference_date &
mudbanks$axisDist >= 0 &
mudbanks$distance >= 0 &
outlier == 0)
View(mudbanks_selection)
mudbank_selection_Outlier <- subset(mudbanks[order(as.numeric(as.character(mudbanks$pos))),],
as.Date(mudbanks$DATE_ACQUIRED) == reference_date &
mudbanks$axisDist >= 0 &
outlier >= 1)
plot(mudbanks_selection$pos, mudbanks_selection$distance)
points(mudbank_selection_Outlier$pos, mudbank_selection_Outlier$distance, col = 'red')
mudbanks_selection <-subset(mudbanks[order(as.numeric(as.character(mudbanks$pos))),],
as.Date(mudbanks$DATE_ACQUIRED) == reference_date &
mudbanks$axisDist >= 0 &
mudbanks$distance >= 0 &
outlier == 0)
plot(mudbanks_selection$pos, mudbanks_selection$distance)
View(mudbanks_selection)
mudbanks_selection <-subset(mudbanks,
as.Date(mudbanks$DATE_ACQUIRED) == reference_date &
mudbanks$axisDist >= 0 &
mudbanks$distance >= 0 &
outlier == 0)
View(mudbanks_selection)
mudbanks_selection <- mudbanks_selection[order(as.numeric(as.character(mudbanks$pos))),]
plot(mudbanks_selection$pos, mudbanks_selection$distance)
order(as.numeric(as.character(mudbanks$pos)))
mudbanks_selection <- mudbanks_selection[order(as.numeric(as.character(mudbanks_selection$pos))),]
mudbanks_selection <-subset(mudbanks,
as.Date(mudbanks$DATE_ACQUIRED) == reference_date &
mudbanks$axisDist >= 0 &
mudbanks$distance >= 0 &
outlier == 0)
mudbanks_selection <- mudbanks_selection[order(as.numeric(as.character(mudbanks_selection$pos))),]
mudbanks_selection
plot(mudbanks_selection$pos, mudbanks_selection$distance)
View(mudbanks_selection)
plot(as.numeric(as.character(mudbanks_selection$pos)), mudbanks_selection$distance)
mudbanks_selection <-subset(mudbanks,
as.Date(mudbanks$DATE_ACQUIRED) == reference_date &
mudbanks$axisDist >= 0 &
mudbanks$distance >= 0 &
outlier == 0)
plot(as.numeric(as.character(mudbanks_selection$pos)), mudbanks_selection$distance)
mudbank_selection_Outlier <- subset(mudbanks[order(as.numeric(as.character(mudbanks$pos))),],
as.Date(mudbanks$DATE_ACQUIRED) == reference_date &
mudbanks$axisDist >= 0 &
outlier >= 1)
points(as.numeric(as.character(mudbank_selection_Outlier$pos)), mudbank_selection_Outlier$distance, col = 'red')
mudbanks_selection <-subset(mudbanks,
as.Date(DATE_ACQUIRED) == reference_date &
axisDist >= 0 &
distance >= 0 &
outlier == 0)
mudbanks_selection2 <-subset(mudbanks,
as.Date(DATE_ACQUIRED) == c('2009-09-12') &
axisDist >= 0 &
distance >= 0 &
outlier == 0)
reference_date
mudbanks_selection2 <-subset(mudbanks,
as.Date(DATE_ACQUIRED) == c('2009-11-15') &
axisDist >= 0 &
distance >= 0 &
outlier == 0)
ponts(as.numeric(as.character(mudbanks_selection2$pos)), mudbanks_selection2$distance, col = 'blue')
points(as.numeric(as.character(mudbanks_selection2$pos)), mudbanks_selection2$distance, col = 'blue')
mudbanks_selection <-subset(coastlines,
as.Date(DATE_ACQUIRED) == reference_date &
axisDist >= 0 &
distance >= 0 &
outlier == 0)
first+mapview(coastlines_selection, col.regions = c("red"), layer.name = i) +
mapview(mudbanks_selection, col.regions = c("green"), layer.name = 'non outlier' ) +
mapview(mudbank_selection_Outlier, col.regions = c("orange"), layer.name = 'outlier' )+
mapview(mudbanks_selection2, col.regions = c("blue"), layer.name = 'outlier' )
reference_date
mudbanks_selection <-subset(coastlines,
as.Date(DATE_ACQUIRED) == reference_date &
axisDist >= 0 &
distance >= 0 &
outlier == 0)
mudbanks_selection <-subset(mudbanks,
as.Date(DATE_ACQUIRED) == reference_date &
axisDist >= 0 &
distance >= 0 &
outlier == 0)
mudbank_selection_Outlier <- subset(mudbanks[order(as.numeric(as.character(mudbanks$pos))),],
as.Date(DATE_ACQUIRED) == reference_date &
mudbanks$axisDist >= 0 &
outlier >= 1)
first+mapview(coastlines_selection, col.regions = c("red"), layer.name = reference_date) +
mapview(mudbanks_selection, col.regions = c("green"), layer.name = 'non outlier' ) +
mapview(mudbank_selection_Outlier, col.regions = c("orange"), layer.name = 'outlier' )+
mapview(mudbanks_selection2, col.regions = c("blue"), layer.name = '2009-11-15' )
reference_date
first+mapview(coastlines_selection, col.regions = c("red"), layer.name = paste0(reference_date)) +
mapview(mudbanks_selection, col.regions = c("green"), layer.name = 'non outlier' ) +
mapview(mudbank_selection_Outlier, col.regions = c("orange"), layer.name = 'outlier' )+
mapview(mudbanks_selection2, col.regions = c("blue"), layer.name = '2009-11-15' )
# collection for testing
filtCollect <- collection$filterDate(as.character(as.Date(reference_date)-1),
as.character(as.Date(reference_date)+1))
dates <- ee_get_date_ic(filtCollect, time_end = FALSE)
dates
first <- Map$addLayer(filtCollect$first(), visParams, paste0(i))
Map$centerObject(filtCollect$first())
first+mapview(coastlines_selection, col.regions = c("red"), layer.name = paste0(reference_date)) +
mapview(mudbanks_selection, col.regions = c("green"), layer.name = 'non outlier' ) +
mapview(mudbank_selection_Outlier, col.regions = c("orange"), layer.name = 'outlier' )+
mapview(mudbanks_selection2, col.regions = c("blue"), layer.name = '2009-11-15' )
reference_date
reference_date
dates
coastlines_selection <-subset(coastlines, coastlines$DATE_ACQUIRED == reference_date &
coastlines$coastDist >= 0)
coastlines_selection <-subset(coastlines, coastlines$DATE_ACQUIRED == reference_date &
coastlines$coastDist >= 0)
coastlines_selection <-subset(coastlines, as.Date(DATE_ACQUIRED) == reference_date &
coastlines$coastDist >= 0)
mudbanks_selection <-subset(mudbanks,
as.Date(DATE_ACQUIRED) == reference_date &
axisDist >= 0 &
distance >= 0 &
outlier == 0)
mudbank_selection_Outlier <- subset(mudbanks[order(as.numeric(as.character(mudbanks$pos))),],
as.Date(DATE_ACQUIRED) == reference_date &
mudbanks$axisDist >= 0 &
outlier >= 1)
# collection for testing
filtCollect <- collection$filterDate(as.character(as.Date(reference_date)-1),
as.character(as.Date(reference_date)+1))
dates <- ee_get_date_ic(filtCollect, time_end = FALSE)
first <- Map$addLayer(filtCollect$first(), visParams, paste0(i))
Map$centerObject(filtCollect$first())
reference_date
first+mapview(coastlines_selection, col.regions = c("red"),
layer.name = paste0('coastlines',reference_date)) +
mapview(mudbanks_selection, col.regions = c("green"), layer.name = 'non outlier' ) +
mapview(mudbank_selection_Outlier, col.regions = c("orange"), layer.name = 'outlier' )+
mapview(mudbanks_selection2, col.regions = c("blue"), layer.name = '2009-11-15' )
first <- Map$addLayer(filtCollect$first(), visParams, paste0('landsat: ',reference_date))
Map$centerObject(filtCollect$first())
first + mapview(coastlines_selection, col.regions = c("red"),
layer.name = paste0('coastlines ',reference_date)) +
mapview(mudbanks_selection, col.regions = c("green"), layer.name = 'non outlier' ) +
mapview(mudbank_selection_Outlier, col.regions = c("orange"), layer.name = 'outlier' )+
mapview(mudbanks_selection2, col.regions = c("blue"), layer.name = '2009-11-15' )
