# plot all cross shore distances
# plot(positions_all, distances_all, main = paste0(i),
#      xlab = 'alongshore position', ylab = 'cross shore dist')
# points(positions_all, distance_all_abs,  col = 'red')
# lines(positions_all, predicted.intervals[,1],col='green',lwd=3)
# points(positions_all[outlier_ind],distances_all[outlier_ind], col = 'red')
# # points(positions_all, mudbanks_selection$axisDistAbs, col = 'blue')
# points(positions_all, mudbanks_selection$axisDistSlope, col = 'red')
################
#' best case scenario of defining no mudbank transects is the values related to super smoothed
#' peak height and distance and same for extent height and distance
#' these values are smoothed and therefore relatively stable
#'
#' So assuming the fraction values corresponding to maxExtent and SuperSmoothed peak are
#' representative increase between them or relative flat decrease in fraction
#' represents no mudbank scenario
#'
#' risks:
#' part of the transect over land, the shorter the less likely the SuperSmoothed peak is correct
#' the longer, less likely the drop comming after the super smoothed peak is representing mudbank boundary
# calculate slope between supersmoothed peak and max Extent
# you'd expect a negative slope value for the fraction
slopes <- mudbanks_selection$SmoothedSlopes
# hist(slopes,  xlim=c(floor(min(slopes)), ceiling(max(slopes))),
#      breaks =c(seq(floor(min(slopes)),ceiling(max(slopes)),0.01)))
# Value should be in the range of -0.15 and 0 ==> not sure yet if using median is the best way
median_slope <- median(slopes)
indicesSlopes <- which(slopes > -0.15) # indices of the subset
pos_slopes <- sp_pnt_ee(mudbanks_selection[indicesSlopes, ]$axisDistAbsX, # &  mudbanks_selection$SmoothedPeak > 0
mudbanks_selection[indicesSlopes, ]$axisDistAbsY,
'positive_slopes',
"#3182bd")
# mudbanks_selection[which(slopes > median_slope)
# Give mudbank_outlier +1 in the source file to keep track
mudbanks[which(mudbanks$DATE_ACQUIRED == i &
mudbanks$pos %in% positions_all[indicesSlopes]), "mudbank_outlier"] <-
as.data.frame(mudbanks[
which(mudbanks$DATE_ACQUIRED == i &
mudbanks$pos %in% positions_all[indicesSlopes]),"mudbank_outlier"])[,1] + 1
#' Very similar to the slope, also the smoothed peak fraction could in theory be used to
#' indicate no-mudbank cases: very low values can be a sign of NO mudbank
#'
# hist(mudbanks_selection$SmoothedPeakFract,
#      breaks =c(seq(min( mudbanks_selection$SmoothedPeakFract),
#                    ceiling(max(mudbanks_selection$SmoothedPeakFract))+0.1,0.01)))
threshold <- median(mudbanks_selection$SmoothedPeakFract) - sd(mudbanks_selection$SmoothedPeakFract)
lowPeakOutlier <-  which(mudbanks_selection$SmoothedPeakFract < threshold) #& mudbanks_selection$SmoothedPeakFract > 0
noMudBankTest <- mudbanks_selection[lowPeakOutlier , ] # 0 is an artefact of GEE export in the super smoothed peaks?
noBankSp <- sp_pnt_ee(noMudBankTest$x,
noMudBankTest$y,
'noBankSp_rel',
"#e0f3db")
# again update mudbank Selection
mudbanks_selection <- mudbanks_selection[-unique(c(indicesSlopes,lowPeakOutlier)), ]
# Make distances compatible (get x,y) with rgee for plotting
SpatialPointsAbs <- sp_pnt_ee(mudbanks_selection$axisDistAbsX,
mudbanks_selection$axisDistAbsY, 'abs_drop',
"FF0000")
SpatialPointsSlope<- sp_pnt_ee(mudbanks_selection$axisDistSlopeX,
mudbanks_selection$axisDistSlopeY, 'slope_drop',
"#31a354")
SpatialPointsRel <- sp_pnt_ee(mudbanks_selection$x,
mudbanks_selection$y, 'rel_drop',
"#d95f0e")
first + SpatialPointsRel + SpatialPointsAbs + SpatialPointsSlope + pos_slopes + noBankSp
# select relevant observations
mudbanks_selection <-subset(mudbanks, mudbanks$DATE_ACQUIRED == i &
mudbanks$axisDist >= 0 &
!(pos %in% posToExclude) &
mudbanks$mudbank_distance >= 0)
mudbanks[which(mudbanks$DATE_ACQUIRED == i &
mudbanks$axisDist < 0 &
mudbanks$mudbank_distance < 0), "mudbank_outlier"] <-
as.data.frame(mudbanks[
which(mudbanks$DATE_ACQUIRED == i &
mudbanks$axisDist < 0 &
mudbanks$mudbank_distance < 0),"mudbank_outlier"])[,1] + 1
# order by position
mudbanks_selection<-mudbanks_selection[order(mudbanks_selection$pos),]
positions_all <- as.numeric(as.character(mudbanks_selection$pos))
distances_all <-mudbanks_selection$mudbank_distance # grab the normalized distances
# abs distance
distance_all_abs <- mudbanks_selection$mudbank_distance_abs
# second order polynomial fit: alongshore position & polynomial fit
lm_out_all <-lm(distances_all ~ poly(as.numeric(positions_all),2))
predicted.intervals <- predict(lm_out_all,
data.frame(x=as.numeric(positions_all)),
interval='confidence', level=0.99)
# Bonferroni-adjusted mudbank_outlier test (test largest absolute standardized residual)
outlier_test <- car::outlierTest(lm_out_all)
outlier_ind<-as.numeric(names(outlier_test$rstudent))
# Give mudbank_outlier +1 in the source file to keep track
mudbanks[which(mudbanks$DATE_ACQUIRED == i &
mudbanks$pos %in% positions_all[outlier_ind]), "mudbank_outlier"] <-
as.data.frame(mudbanks[
which(mudbanks$DATE_ACQUIRED == i &
mudbanks$pos %in% positions_all[outlier_ind]),"mudbank_outlier"])[,1] + 1
outlier_selection <- mudbanks_selection[outlier_ind,]
# drop the most obvious outliers from the selection
mudbanks_selection <- mudbanks_selection[-outlier_ind, ]
slopes <- mudbanks_selection$SmoothedSlopes
# Value should be in the range of -0.15 and 0 ==> not sure yet if using median is the best way
median_slope <- median(slopes)
hist(slopes,  xlim=c(floor(min(slopes)), ceiling(max(slopes))),
breaks =c(seq(floor(min(slopes)),ceiling(max(slopes)),0.01)))
View(mudbanks_selection)
i
outlier_ind
positions_all[outlier_ind]
outlier_selection
outlier_selection$pos
# select relevant observations
mudbanks_selection <-subset(mudbanks, mudbanks$DATE_ACQUIRED == i &
mudbanks$axisDist >= 0 &
!(pos %in% posToExclude) &
mudbanks$mudbank_distance >= 0)
posToExclude
i
# plot histogram - fraction smoothed peak
hist(mudbanks_selection$SmoothedPeakFract,
xlim=c(0,1), breaks =c(seq(0,1,0.01)))
# fraction of detected offshore boundary
hist(mudbanks_selection$mudFractAbs,
xlim=c(0,1), breaks =c(seq(0,1,0.05)))
hist(mudbanks_selection$mudFract,
xlim=c(0,1), breaks =c(seq(0,1,0.05)))
hist(mudbanks_selection$mudFractSlope,
xlim=c(0,1), breaks =c(seq(0,1,0.05)))
# distance of detected offshore boundary (abs)
hist(mudbanks_selection$axisDistAbs,
xlim=c(0,20000), breaks =c(seq(0,30000,100)))
plot(mudbanks_selection$axisDistAbs,
mudbanks_selection$mudFractAbs)
# refine thresholds?
lowPeakFractsSmoothed<- mudbanks_selection[which(mudbanks_selection$SmoothedPeakFract < 0.1),]
lowPeakFractsSmoothed
# contrasting fractions for abs drop / re drop
contrastingFractAbs <- mudbanks_selection[which(mudbanks_selection$mudFractAbs > 0.4 &
mudbanks_selection$mudFract < 0.6 &
mudbanks_selection$mudFract != mudbanks_selection$mudFractAbs), ]
plot(mudbanks_selection$mudFract,
mudbanks_selection$mudFractAbs)
points(contrastingFractAbs$mudFract,
contrastingFractAbs$mudFractAbs,
col = 'red')
# contrasting distances for abs drop / rel drop
# shows nicely which RELATIVE distances are wrong! (if tresholds can be finetuned)
axisDist_boundary <- median(mudbanks_selection$axisDist) + sd(mudbanks_selection$axisDist)
axisDist_boundary_abs <- median(mudbanks_selection$axisDistAbs) - sd(mudbanks_selection$axisDistAbs)
contrastingDist <- mudbanks_selection[which(mudbanks_selection$axisDist > axisDist_boundary &
# mudbanks_selection$axisDistAbs < 14000 &
mudbanks_selection$axisDist != mudbanks_selection$axisDistAbs), ]
contrastingDist_abs <- mudbanks_selection[which(mudbanks_selection$axisDistAbs < axisDist_boundary_abs &
# mudbanks_selection$axisDistAbs < 14000 &
mudbanks_selection$axisDist != mudbanks_selection$axisDistAbs), ]
plot(mudbanks_selection$axisDist,
mudbanks_selection$axisDistAbs)
points(contrastingDist$axisDist,
contrastingDist$axisDistAbs,
col = 'red')
abline(v=as.numeric(axisDist_boundary))
abline(h=as.numeric(axisDist_boundary_abs))
contrastingD <- sp_pnt_ee(contrastingDist$x,
contrastingDist$y,
'contrasting_dist_abs_rel',
"#e0f3db")
first + SpatialPointsRel + contrastingD
axisDist_boundary
axisDist_boundary_abs
axisDist_boundary
plot(mudbanks_selection$axisDist,
mudbanks_selection$axisDistAbs)
points(contrastingDist$axisDist,
contrastingDist$axisDistAbs,
col = 'red')
plot(mudbanks_selection$mudFract,
mudbanks_selection$mudFractAbs)
points(contrastingFractAbs$mudFract,
contrastingFractAbs$mudFractAbs,
col = 'red')
# contrasting distances for abs drop / rel drop
# shows nicely which RELATIVE distances are wrong! (if tresholds can be finetuned)
# Allthough this throuws ouy far awway points +=> methodology already has a bias on nearshore observations being detected
# ncie thing about relative drops are that they are in general further away
axisDist_boundary <- median(mudbanks_selection$axisDist) + sd(mudbanks_selection$axisDist)
axisDist_boundary_abs <- median(mudbanks_selection$axisDistAbs) - sd(mudbanks_selection$axisDistAbs)
axisDist_boundary
axisDist_boundary_abs <- median(mudbanks_selection$axisDistAbs) - sd(mudbanks_selection$axisDistAbs)
axisDist_boundary_abs
contrastingDist <- mudbanks_selection[which(mudbanks_selection$axisDist > axisDist_boundary &
# mudbanks_selection$axisDistAbs < 14000 &
mudbanks_selection$axisDist != mudbanks_selection$axisDistAbs), ]
contrastingDist_abs <- mudbanks_selection[which(mudbanks_selection$axisDistAbs < axisDist_boundary_abs &
# mudbanks_selection$axisDistAbs < 14000 &
mudbanks_selection$axisDist != mudbanks_selection$axisDistAbs), ]
plot(mudbanks_selection$axisDist,
mudbanks_selection$axisDistAbs)
points(contrastingDist$axisDist,
contrastingDist$axisDistAbs,
col = 'red')
abline(v=as.numeric(axisDist_boundary))
contrastingD <- sp_pnt_ee(contrastingDist$x,
contrastingDist$y,
'contrasting_dist_abs_rel',
"#e0f3db")
first + SpatialPointsRel + contrastingD
fract_boundary_slope <- median(mudbanks_selection$mudFractSlope) + sd(mudbanks_selection$mudFractSlope)
fract_boundary_slope
contrastingFract <- mudbanks_selection[which(mudbanks_selection$mudFractSlope > fract_boundary_slope &
# mudbanks_selection$axisDistAbs < 14000 &
mudbanks_selection$mudFractSlope != mudbanks_selection$mudFract), ]
plot(mudbanks_selection$mudFract, mudbanks_selection$mudFractSlope)
points(contrastingFract$mudFract,
contrastingFract$mudFractSlope,
col = 'red')
contrastingFract_sp <- sp_pnt_ee(contrastingFract$axisDistSlopeX,
contrastingFract$axisDistSlopeY,
'contrasting_fract_slope_rel',
"#e0f3db")
first + SpatialPointsSlope + SpatialPointsAbs + SpatialPointsRel
first + SpatialPointsSlope + SpatialPointsAbs + contrastingFract_sp
nrow(mudbanks_selection)
## ---------------------------
#'
#' Script name: Plot offshore boundary results
#'
#' Short Description:
#'
#'
#' Author: Job de Vries
#'
#' Date Created: 2020-11-16
#'
#' Copyright (c) Job de Vries, 2020
#' Email: j.devries4@uu.nl
#'
## ---------------------------
#'
#' Description
#'
#'
#'
## ---------------------------
rm(list = ls())
#' set working directory for Mac and PC
wd<-getwd()
# setwd("D:/BackUp_D_mangroMud_202001/Research/Software/Projects/offshore_boundary")
## ---------------------------
options(scipen = 6, digits = 4) # I prefer to view outputs in non-scientific notation
memory.limit(30000000)     # this is needed on some PCs to increase memory allowance, but has no impact on macs.
#  Map view options:
# https://r-spatial.github.io/mapview/articles/articles/mapview_02-advanced.html
## ---------------------------
#' load up the packages
source("./src/packages.R")       # loads up all the packages we need
ee_Initialize()
source("./src/functions.R")
## ---------------------------
mapviewOptions(basemaps = c( "Esri.WorldImagery","Esri.WorldShadedRelief", "OpenStreetMap.DE"))
leaflet() %>%
addProviderTiles("Esri.WorldImagery")
dataFolder <- './data/raw'
# seq1 <- seq(1985, 1999, 1)
seq2 <- seq(2000, 2001, 1)
seq3 <- seq(2008, 2009, 1)
years <- c(seq2, seq3)# seq(from = 1985, to = 2020, by = 1)
# pos to exlcude for mudbank boundary estimates / outlier detection
posToExclude <- c(seq(138000,147000,1000),
seq(241000, 255000, 1000))
#c('2005', '2006','2007', '2008','2009')
min_Std <- 25 # minimal amount of meters difference before considered outlier
year_limit <- 4 # search window in years for finding coastline obs when insufficient values per year.
min_obs_rosner <- 10    # Amount of obs per year needed to perform Rosner Test
# select folders
folderSelect <- as.matrix(list.files(paste0(dataFolder, '/GEE_exports'), full.names = T))
df <- rewrite(folderSelect);
# only csv's
df <- df[grep('.csv', folderSelect, ignore.case = T),]
aoi <-  c('Suriname')
path_rows <- c('229_56')
filtered <- vector('list', 100)
for (q in seq_along(years)) {
for (x in seq_along(aoi)){
for (pr in path_rows){
# q <- 8
year = as.character(years[q])
region = aoi[x]
filters = c(year, region, pr)
filtered = rbind(filtered, df %>%
dplyr::filter(
filters %>%
# apply the filter of all the text rows for each pattern
# you'll get one list of logical by pattern ignored_string
purrr::map(~ to_keep(.x, text = text)) %>%
# get a logical vector of rows to keep
purrr::pmap_lgl(all)
))}
}}
filtered <- unique(filtered)
allFiles <- do.call(rbind, lapply(as.matrix(filtered)[,1], function(x) read.csv(x, stringsAsFactors = FALSE,
sep = ',', na.strings=c("","NA")
)))
col_dates <- col_of_interest(allFiles, 'DATE_ACQUIRED$')
col_coastDist <- col_of_interest(allFiles, 'coastDist$')
# all unique transect (id's)
allPos <- unique(allFiles[, col_of_interest(allFiles, 'pos$')]);
uniqueX<- unique(allFiles[, col_of_interest(allFiles, 'originX$')]);
uniqueY<- unique(allFiles[, col_of_interest(allFiles, 'originY$')]);
geo<- unique(allFiles[, col_of_interest(allFiles, '.geo')]);
uniqueDates <- unique(allFiles[,col_dates]);
# keep_columns <- c('axisDist', 'mudFract', 'endDrop', 'coastDist',
#                   'originX', 'originY', 'coastX', 'coastY')
drop <- c('system.index', '.geo')
keep_columns <- colnames(allFiles)[!(colnames(allFiles) %in% drop)]
mudbanks <- reshape_csvPoints(allFiles, 'peakCoordX', 'peakCoordY', keep_columns)
# change to NA
mudbanks$coastDist[mudbanks$coastDist == -1] <- NA
# sort al rows based on position & date
mudbanks<-mudbanks[with(mudbanks, order(pos, DATE_ACQUIRED)), ]
# make groups per year, 3 months and 3 years per transect
mudbanks <- mudbanks %>%
mutate(quarterly_col = as.Date(cut(lubridate::date(mudbanks$DATE_ACQUIRED),
"3 month"))) %>%
mutate(date_col = as.Date(cut(lubridate::date(mudbanks$DATE_ACQUIRED),
"3 year"))) %>%
mutate(five_year_col = as.Date(cut(lubridate::date(mudbanks$DATE_ACQUIRED),
"5 year"))) %>%
mutate(year_col = as.Date(cut(lubridate::date(mudbanks$DATE_ACQUIRED),
"1 year")))
group_dates<-unique(mudbanks$year_col)
group_pos <- unique(mudbanks$pos)
group_years <- unique(mudbanks$date_col)
five_years <- unique(mudbanks$five_year_col)
# for testing / visualization define an imageCollection
collectionL4 <- ee$ImageCollection("LANDSAT/LT04/C01/T1_TOA")$
filterBounds(ee$Geometry$Point(-55.54, 5.94))
collectionL5 <- ee$ImageCollection("LANDSAT/LT05/C01/T1_TOA")$
filterBounds(ee$Geometry$Point(-55.54, 5.94))
collectionL7 <- ee$ImageCollection("LANDSAT/LE07/C01/T1_TOA")$
filterBounds(ee$Geometry$Point(-55.54, 5.94))
collectionL8 <- ee$ImageCollection("LANDSAT/LC08/C01/T1_TOA")$
filterBounds(ee$Geometry$Point(-55.54, 5.94))
collection <- collectionL8$merge(collectionL5)$merge(collectionL7)$
merge(collectionL4)
vizParams = list(
bands = c("B5", "B4", "B3"),
min = 0.05, max = 0.5, gamma = 1.4
)
# assume nothing is outlier
mudbanks$coast_outlier <- 1
mudbanks$slope         <- NA
mudbanks$coastObs      <- NA
#'
#'  estimate coastal outliers with rosner test
#'  - for each transect per 3 years to ensure sufficient observations
#'
#'  Still poses problems for some transects
#'  Resulting in negative mudbank distances, especially at transects
#'  near river mouths.
#'  Also test for years with low obs?! 1985 - 2000
for(i in five_years){
start <- Sys.time()
# i<-five_years[five_years == c("1991-01-01")]
for(q in group_pos){
# pos_to_test <- 	235000
# q <- group_pos[group_pos == 116000]
# print(q)
indexs <- which(mudbanks$five_year_col == i &
mudbanks$pos == q &
mudbanks$coastDist > -1)
subsets3 <- mudbanks[indexs, ]
# get nearest observation and add it to the list
# is .na going to throw a problem?
reference_date <- mean(as.Date(subsets3$DATE_ACQUIRED))
# Aamount of obs
obs_3years <- nrow(subsets3)
# update that if subset per year is to small, include extra observations?
# So grow the subset to at least 10(?) obs by adding nearest observations
maxAttemp <- 0 # make sure you don't get stuck in infinite loop..
while(nrow(subsets3) < min_obs_rosner &
# nrow(subsets3)+obs_3years > min_obs_rosner &
maxAttemp < min_obs_rosner+5){
# exclude dates from the year of interest
# sample from entire dataset so that years outside the 3 year block
# are also possible candidates
# pitfall: any date is possible, also the ones to far away
# so set limit at search window of x years?
selectedDates <- subset(mudbanks, mudbanks$pos == q &
mudbanks$coastDist > -1 &
!(mudbanks$DATE_ACQUIRED %in%
subsets3$DATE_ACQUIRED)
)$DATE_ACQUIRED
# exclude the ones already selected
# are NA a problem that seems to throw warnings()?
nearestDate <- selectedDates[1:length(selectedDates) ==
which.min(replace(abs(as.Date(selectedDates) - reference_date),
abs(as.Date(selectedDates) - reference_date)>year_limit*356, NA))]
# if nothing is found, break the loop
if(length(nearestDate) == 0){break}
index_nearest <- which(as.Date(as.character(mudbanks$DATE_ACQUIRED)) == nearestDate &
mudbanks$pos == q &
mudbanks$coastDist > -1)
# update subsets
subsets3 <- rbind(subsets3, mudbanks[index_nearest, ] )
maxAttemp = maxAttemp + 1
}
# because subsets 3 changed in size, recalc the indices.
subsets3_recal <- which(mudbanks$DATE_ACQUIRED %in% subsets3$DATE_ACQUIRED &
mudbanks$pos == q &
mudbanks$coastDist > -1)
# apply rosner test if there is sufficient observations ==> this implies that the timeseries to look at needs to be larger than 3 years.
# also the year limit needs to go up.
# All detected outliers with larger std value recieve outlier == 0
# Only give the rosner output to the original subset3 indices
mudbanks[indexs, 'coast_outlier'] <-
rosner(subsets3$coastDist,min_Std , min_obs_rosner)[which(subsets3_recal %in% indexs)]
# consider adding a outlier check for annual obs?
# make sure it is applicable for sufficient observations only
# Or when it involvoves landsat 7 observations?
# plot(as.Date(subsets3$DATE_ACQUIRED), subsets3$coastDist,
#     main = paste0(q), xlab = 'date', ylab = 'coastline position')
#
# points(as.Date(subsets3$DATE_ACQUIRED)[which(rosner(subsets3$coastDist, min_Std, min_obs_rosner) == 0)],
#        subsets3$coastDist[which(rosner(subsets3$coastDist, min_Std, min_obs_rosner) == 0)],
#        col = 'red')
}
end <- Sys.time()
dif<- difftime(end, start, "mins")
print(paste0(as.Date(i) ,' in ', round(dif,1)))
}
#'
#'  calculate slope
#'  - include nearest observations
#'  within predefined search window (4 years difference max)
#'
for(i in group_dates){
start <- Sys.time()
for(q in group_pos){
# i<-group_dates[group_dates == c("1998-01-01")]
#
# pos_to_test <- 	116000
# q <- group_pos[group_pos == pos_to_test]
# print(q)
subsets_annual <- mudbanks[which(mudbanks$year_col == i &
mudbanks$pos == q &
mudbanks$coastDist > -1), ]
# select outliers & non outliers
outliers <- subset(subsets_annual, coast_outlier == 0)
nonOutliers <- subset(subsets_annual, coast_outlier == 1)
# get nearest observation and add it to the list
# if there is nothing there; half way through the year
reference_date <- as.Date(ifelse(nrow(nonOutliers)>0,
mean(as.Date(nonOutliers$DATE_ACQUIRED)),
as.Date(i)+days(180)))
# improvement required!
# slope is only applicable if quality of coastline estimate is
# sufficient (see landsat 7 case with no data in wetland areas)
# if outlier detection is sufficient the slope can be correctly estimated
# if  there is insufficient observations;
# search for additional observations to calculate the slope
# downside; if the observations that are detected are of good quality,
# the slope is wronfully adjusted based on neighbouring observations
# resulting in wrong estimate (often underestimate!) of rate of change.
maxAttemp <- 0
while(nrow(nonOutliers) < 8 &
maxAttemp < min_obs_rosner){
# exclude the ones from the original year
selectDates <- subset(mudbanks, mudbanks$pos == q &
mudbanks$coastDist > -1 & !(mudbanks$DATE_ACQUIRED %in%
nonOutliers$DATE_ACQUIRED))$DATE_ACQUIRED
# get nearest date (excluding dates outside limit)
nearestDate <- selectDates[1:length(selectDates) ==
which.min(replace(abs(as.Date(selectDates) - reference_date),
abs(as.Date(selectDates) - reference_date)>year_limit*356, NA))]
if(length(nearestDate) == 0){break}
index_nearest <- which(as.Date(as.character(mudbanks$DATE_ACQUIRED)) == nearestDate &
mudbanks$pos == q &
mudbanks$coastDist > -1 &
mudbanks$coast_outlier == 1)
# update annual subset
nonOutliers <- rbind(nonOutliers, mudbanks[index_nearest, ] )
maxAttemp = maxAttemp + 1
}
# only fit a line if there is a least 5 valid observations.
if(nrow(nonOutliers) < 5){
m_per_year <- NA
} else {
# calculate linear fit
lm.out <- lm(nonOutliers$coastDist~as.numeric(as.Date(nonOutliers$DATE_ACQUIRED)))
# intercept <-lm.out$coefficients[1]
slope <- round(lm.out$coefficients[2], 5) # change per unit of x (=days)
m_per_year <- slope*365
}
# update all slope values from the original years (incl. coastdist -1 and outliers)
mudbanks$slope[which(mudbanks$year_col == i &
mudbanks$pos == q)] <- as.numeric(m_per_year)
mudbanks$coastObs[which(mudbanks$year_col == i &
mudbanks$pos == q)] <- as.numeric(nrow(nonOutliers))
}
end <- Sys.time()
dif<- difftime(end, start, "mins")
print(paste0(as.Date(i) ,' in ', round(dif,1), ' mins'))
# plot(as.Date(nonOutliers$DATE_ACQUIRED), nonOutliers$coastDist,
#   main = paste0(q), xlab = paste0(i), ylab = 'coastline position',
#   ylim=c(min(nonOutliers$coastDist)-30,max(nonOutliers$coastDist)+30),
#   xlim=c(min(as.Date(nonOutliers$DATE_ACQUIRED)),
#         max(as.Date(nonOutliers$DATE_ACQUIRED))))
# # points(as.Date(outliers$DATE_ACQUIRED), outliers$coastDist, col = 'red')
# abline(lm(nonOutliers$coastDist~as.numeric(as.Date(nonOutliers$DATE_ACQUIRED))),lty = 2)
# text(min(as.Date(subsets3$DATE_ACQUIRED)) + 90,
#      max(subsets3$coastDist) + 25, paste0('slope = ', m_per_year, ' meter'))
}
