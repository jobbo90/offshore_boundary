# yprev = subset_geometry[ifelse(whichseg-smoothing_factor <= 0, 1, whichseg-smoothing_factor),2] # Get Y coordinate on line for previous point
)
# ensure equal spacing (from segments to points)
pos$further =  pos$pos - pos$dtotal       # which is the next position (in meters)
pos$f = pos$further/pos$dseg              # fraction next segment of its distance
# because of smoothing factor this changes starting point
pos$x = pos$x0 + pos$f * (pos$x1-pos$x0)  # X Position of point on line which is x meters away from x0: ensure equal spacing
pos$y = pos$y0 + pos$f * (pos$y1-pos$y0)  # Y Position of point on line which is x meters away from y0: ensure equal spacing
# smoothing_factor <- 5
pos$xnext = c(pos[smoothing_factor:nrow(pos),'x'], rep(pos$x[nrow(pos)-(abs(smoothing_factor)+smoothing_factor)/2],
(abs(smoothing_factor-1)+smoothing_factor-1)/2))
pos$ynext = c(pos[smoothing_factor:nrow(pos),'y'], rep(pos$y[nrow(pos)-(abs(smoothing_factor)+smoothing_factor)/2],
(abs(smoothing_factor-1)+smoothing_factor-1)/2))
pos$yprev = as.data.frame(mutate(pos, yprev = lag(y)))[, 'yprev']
pos$xprev = as.data.frame(mutate(pos, xprev = lag(x)))[, 'xprev']
# calculate angle
# pos$theta = atan2(pos$y-pos$ynext, pos$yprev-pos$xnext)
pos$theta = atan2(pos$yprev-pos$ynext, pos$xprev-pos$xnext)  # Angle between points on the line in radians
# last in line are affected by smoothing window: give same angle
pos$theta[seq(nrow(pos)-(abs(smoothing_factor-2)+smoothing_factor-2)/2,nrow(pos))] <- pos$theta[nrow(pos)-(abs(smoothing_factor-3)+smoothing_factor-3)]
# fill NA with relevant values
pos$theta[which(is.na(pos$theta))] = pos$theta[which(is.na(pos$theta))+1] # fill NA with neighbourh theta
pos$xprev[which(is.na(pos$xprev))] = pos$x[which(is.na(pos$xprev))]
pos$yprev[which(is.na(pos$yprev))] = pos$y[which(is.na(pos$yprev))]
pos$object = i
#
# plot(SpatialPoints(data.frame(x = pos[,'x'], y = pos[,'y']),CRS(as.character(line@proj4string))),
#         axes = T, col = 'red')
######
##
## Define transect end points
#####
pos$thetaT = pos$theta+pi/2         # Get the angle in degrees?
dx_poi <- tlen*cos(pos$thetaT)      # coordinates of point of interest as defined by position length (sep)
dy_poi <- tlen*sin(pos$thetaT)
# transect is defined by x0,y0 and x1,y1 with x,y the coordinate on the line
output <-     data.frame(pos = pos$pos,
x0 = pos$x + dx_poi,       # X coordinate away from line
y0 = pos$y + dy_poi,       # Y coordinate away from line
x1 = pos$x - dx_poi,       # X coordinate away from line
y1 = pos$y - dy_poi,       # X coordinate away from line
theta = pos$thetaT,    # angle
x = pos$x,             # Line coordinate X
y = pos$y,             # Line coordinate Y
object = pos$object,
nextx = pos$x1,
nexty = pos$y1)
# create polygon from object to select correct segment of the transect (coastal side only)
points_for_polygon <- rbind(output[,c('x', 'y','nextx', 'nexty')])# select points
pol_for_plot <- SpatialPolygons(list( Polygons(list(Polygon(points_for_polygon[,1:2])),1)),
proj4string = CRS(as.character(line@proj4string)))
# plot(SpatialPoints(data.frame(x = points_for_polygon[,'x'], y = points_for_polygon[,'y']),CRS(as.character(line@proj4string))),
# axes = T, add = T,col = 'blue')
# plot(SpatialPoints(data.frame(x = output[,'x0'], y = output[,'y0']),CRS(as.character(line@proj4string))),
# axes = T, add = T, col = 'red')
# plot(SpatialPoints(data.frame(x = output[,'x1'], y = output[,'y1']),CRS(as.character(line@proj4string))),
# axes = T, add = T, col = 'green')
# plot(pol_for_plot, axes = T, add = T, col = 'orange')
# determine first and last point on the coastline
firstForPlot <- data.frame(x = points_for_polygon$x[1], y = points_for_polygon$y[1])
lastForPlot <- data.frame(x = points_for_polygon$x[length(points_for_polygon$x)],
y = points_for_polygon$y[length(points_for_polygon$y)])
# plot_all <- SpatialPoints(points_for_polygon, CRS(as.character(line@proj4string)))
plot_first <- SpatialPoints(firstForPlot, CRS(as.character(line@proj4string)))
plot_last <- SpatialPoints(lastForPlot, CRS(as.character(line@proj4string)))
# plot(plot_first, add = T, col = 'red')
# plot(plot_last, add = T, col = 'purple')
# plot(plot_all, add = T)
## Corners of bounding box
LX <- min(points_for_polygon$x)
UX <- max(points_for_polygon$x)
LY <- min(points_for_polygon$y)
UY <- max(points_for_polygon$y)
# polygon(x = c(LX, UX, UX, LX), y = c(LY, LY, UY, UY), lty = 2)
# polygon(x = c(LX, UX, LX), y = c(LY, LY, UY), lty = 2)
# grow polygon
left1 <- data.frame(x = LX - (tlen + 1), y = LY)
right1 <- data.frame(x = UX + (tlen + 1), y = LY)
LL_corner <- data.frame(x = LX - 2 * tlen, y = LY - 2 * tlen)
LR_corner <- data.frame(x = UX + tlen, y = LY - 2 * tlen)
# UR_corner <- data.frame(x = LX - tlen, y = UY - tlen)
corners <- rbind(LL_corner, LR_corner,left1,right1)
bbox_add <- SpatialPoints(corners, CRS(as.character(line@proj4string)))
# plot(bbox_add ,col = 'blue', axes = T, add = T)
# Control plot order of points to avoid weird shapes by using nearest point first
firstForPlot$near <- apply(gDistance(bbox_add,plot_last, byid = T), 1, which.min)
lastForPlot$near <- apply(gDistance(bbox_add,plot_first, byid = T), 1, which.min)
secondForPlot <- apply(gDistance(bbox_add[row.names(bbox_add) != firstForPlot$near & # not equal to first & last for plot
row.names(bbox_add) != lastForPlot$near,],
plot_last, byid = T), 1, which.min)
secondplot <- SpatialPoints(rbind(corners[secondForPlot,]), CRS(as.character(line@proj4string)))
thirdForPlot <- apply(gDistance(bbox_add[row.names(bbox_add) != secondForPlot,],
secondplot, byid = T), 1, which.min)
thirdplot <- SpatialPoints(rbind(corners[thirdForPlot,]), CRS(as.character(line@proj4string)))
# plot(secondplot, add = T, col = 'red')
# plot(thirdplot, add = T, col = 'purple')
# increase polygon with corresponding points
points_for_polygon_incr <- rbind(points_for_polygon[,1:2], corners[firstForPlot$near,],
# corners[row.names(corners) != firstForPlot$near,],
corners[secondForPlot,],
corners[thirdForPlot,],
corners[lastForPlot$near,]
)
pol_for_intersect_incr <- SpatialPolygons( list( Polygons(list(Polygon(points_for_polygon_incr)),1)),
proj4string = CRS(as.character(line@proj4string)))
# plot(pol_for_intersect_incr, col = 'brown', add = T)
# plot
coordsxy <- data.frame(x = output$x, y = output$y)
plotxy <- SpatialPoints(coordsxy, proj4string = CRS(as.character(line@proj4string)))
# plot(plotxy, add = T, col = 'blue')
coordsx1y1 <- data.frame(x = output$x1, y = output$y1)
plotx1y1 <- SpatialPoints(coordsx1y1, proj4string = CRS(as.character(line@proj4string)))
# plot(plotx1y1, add = T)
coordsx0y0 <- data.frame(x = output$x0, y = output$y0)
plotx0y0 <- SpatialPoints(coordsx0y0, proj4string = CRS(as.character(line@proj4string)))
# plot(plotx0y0, add = T, col = 'red')
#intersect
# output[, "x1y1"] <- over(plotx1y1, pol_for_intersect_incr) #NA denotes the point does not fall in a polygon;
# output[, "x0y0"] <- over(plotx0y0, pol_for_intersect_incr)
# CONSIDER CHANGING THIS AND JUST ASSIGNING X1 and Y1 as the end locations of the transect.
# WHEN ORDER OF PLOTTING IS CORRECT (NOW FIxED) TRANSECTS ARE ALSO BETTER ORIENTATED
# indexx0y0 <- with(output, is.na(output$x1y1))
output[, 'endx'] <- output[, 'x0']
output[, 'endy'] <- output[, 'y0']
# # Assign x1 and y1 if end coordinate is not inside the polygon
# indexx0y0 <- with(output, is.na(output$x1y1))
# output[indexx0y0, 'endx'] <- output[indexx0y0, 'x1']
# output[indexx0y0, 'endy'] <- output[indexx0y0, 'y1']
# # assign x0 and y0 if end coordinate is 'clipped'
# index <- with(output, is.na(output$x0y0))
# output[index, 'endx'] <- output[index, 'x0']
# output[index, 'endy'] <- output[index, 'y0']
# drop rows that have both points intersecting with polygon
output <- output[with(output, !is.na(output$endx)),]
AllTransects = rbind(AllTransects, output)
}
# create all transects
id <- rownames(AllTransects)
AllTransects <- cbind(id=id, AllTransects)
lines <- vector('list', nrow(AllTransects))
for(n in seq_along(lines)){
# n = 141
col_names <- list('lon', 'lat')
row_names <- list('begin', 'end')
# dimnames < list(row_names, col_names)
begin_coords <- data.frame(lon = AllTransects$x, lat = AllTransects$y)       # Coordinates on the original line
end_coords <- data.frame(lon = AllTransects$endx, lat = AllTransects$endy)   # coordinates as determined by the over: remove implement in row below by selecting correct column from output
x <- as.matrix(rbind(begin_coords[n,], end_coords[n,]))
# dimnames(x) <- list(row_names, col_names)
lines[[n]] <- Lines(list(Line(x)), ID = as.character(AllTransects[n, 1]))
}
lines_sf <- SpatialLines(lines, proj4string = CRS(as.character(line@proj4string)))
# plot(lines_sf, col = 'black')
df <- SpatialLinesDataFrame(lines_sf, data.frame(AllTransects, row.names = AllTransects[, 1]))
# clean transects
# 1: remove parts that intersect with coastline
for(trans in 1: length(df)){ # kijk in elke transect
# trans <- 145
transect <- df[trans,]
# plot(transect, add = T, col = 'red')
subset_trans <- data.frame(geom(transect))[, c('x', 'y')]
pnt_trans <- gBuffer(SpatialPoints(data.frame(x = subset_trans[,'x'], y = subset_trans[,'y']),
CRS(as.character(line@proj4string)))[1], width = 3000) # select points from transect + buffer
intersect <- gIntersection(pnt_trans, line) # intersect points with coastline
start_buf <- gBuffer(intersect, width = 100) # Apply a buffer to the intersection point
#  gbuffer fails if begin point is not near the initial coastline feature
clipTrans <- gDifference(transect, start_buf) # reduce the transect by the buffer
# after clipping on the buffer: test for coastline intersect
intersect_final <- any(gIntersects(clipTrans,line)) # true for intersection
# test <- gIntersection(clipTrans, line, byid=c(TRUE, TRUE))
if(intersect_final){
# where do they intersect
getIntersect <- intersect(clipTrans, as(line, "SpatialLines"))
intersectBuffer <- gBuffer(SpatialPointsDataFrame(getIntersect, data = data.frame(getIntersect@data)), width = 100)
# mapview(intersectBuffer) + mapview(st_as_sf(clipTrans)) #+ mapview(st_as_sf(line))
intersected2 <- gDifference(transect, intersectBuffer, byid = T)
CoordinatesFirst <- coordinates(intersected2)[[1]][[1]] # get coordinates (1st set is the origin?)
# for plotting
toLine <-  st_sfc(st_linestring(CoordinatesFirst),crs = as.character(crs(line@proj4string@projargs)))
dat_sf = st_as_sf(toLine)
# mapview(dat_sf) + mapview(transect) + mapview(line)
# overwrite if intersect_final
lines[[trans]]<- NA
lines[[trans]] <- Lines(list(Line(CoordinatesFirst)), ID = trans)
# df[trans,]@data
}
}
# df = df[df$intersect != 1,]
# update lines_sf & df!
lines_sf <- SpatialLines(lines, proj4string = CRS(as.character(line@proj4string)))
df <- SpatialLinesDataFrame(lines_sf, data.frame(AllTransects, row.names = AllTransects[, 1]))
return(df)
}
transects <- evenspace(kustlijn_smoothed2, sep = 1000, tlen = 30000, smoothing_factor = 5)
df_transects <- SpatialLinesDataFrame(transects,data.frame(transects@data))
transects_sf <- st_as_sf(df_transects)
mapview(lines_sf, col.regions = c("red")) + mapview(transects_sf)
install.packages("mapview")
library(mapview)
transects <- evenspace(kustlijn_smoothed2, sep = 1000, tlen = 30000, smoothing_factor = 5)
transects_sf <- st_as_sf(df_transects)
mapview(lines_sf, col.regions = c("red")) + mapview(transects_sf)
writeOGR(transects, dsn = 'D:/BackUp_D_mangroMud_202001/Site1_Suriname_all/Analysis/IntertidalArea/Transects',
layer = 'transects_class10_v5', driver = "ESRI Shapefile")
smoothing_factor <- 5
sep <- 1000
tlen <- 30000
start <- 0
line <- kustlijn_smoothed2
# transform line in UTM (allow calculation in Meters)
# projection EPSG:31121 (epsg projection 31121 - zanderij / utm zone 21n): http://spatialreference.org/ref/epsg/31121/
line <- spTransform(line, CRS(as.character("+proj=utm +zone=21 +ellps=intl +towgs84=-265,120,-358,0,0,0,0 +units=m +no_defs")))
# transform line in UTM (allow calculation in Meters)
# projection EPSG:31121 (epsg projection 31121 - zanderij / utm zone 21n): http://spatialreference.org/ref/epsg/31121/
line <- spTransform(line, CRS(as.character("+proj=utm +zone=21 +ellps=intl +towgs84=-265,120,-358,0,0,0,0 +units=m +no_defs")))
line
kustlijn_smoothed2
rm(list = ls())
#' set working directory for Mac and PC
wd<-getwd()
options(scipen = 6, digits = 4) # I prefer to view outputs in non-scientific notation
memory.limit(30000000)     # this is needed on some PCs to increase memory allowance, but has no impact on macs.
#' load up the packages
source("./src/packages.R")       # loads up all the packages we need
# # library(plyr)
# # library(ggridges)
library(ggplot2)
library(readr)
library(mapview)
library(leafpop)
# library(tidyverse)
# library(dplyr)
# library(reshape2)
library(stringr)
library(sp)
library(rgdal)  # for reading/creating shapefiles
library(raster) # for stack & reading raster
library(qdapRegex)
library(sf)
# library(cowplot)
# library(cowplot)
# library(ggspatial) # for north arrow annotation ggRGB
# library(cowplot)
# library(ggspatial) # for north arrow annotation ggRGB
# # library(ggtern)
# library(cowplot)
# library(ggspatial) # for north arrow annotation ggRGB
# # library(ggtern)
# library(RStoolbox) # for ggRGB
# library(cowplot)
# library(ggspatial) # for north arrow annotation ggRGB
# # library(ggtern)
# library(RStoolbox) # for ggRGB
# library(data.table) # for fread
# library(cowplot)
# library(ggspatial) # for north arrow annotation ggRGB
# # library(ggtern)
# library(RStoolbox) # for ggRGB
# library(data.table) # for fread
# library(reshape2) # data melt
# library(cowplot)
# library(ggspatial) # for north arrow annotation ggRGB
# # library(ggtern)
# library(RStoolbox) # for ggRGB
# library(data.table) # for fread
# library(reshape2) # data melt
# library(maptools) # elide spatial line (rotate)
# library(plyr)
# library(plyr)
# library(egg) # for tagging facets
# library(plyr)
# library(egg) # for tagging facets
# library( rasterVis ) # for gPlot
# library(plyr)
# library(egg) # for tagging facets
# library( rasterVis ) # for gPlot
# library( gridExtra )
#' load up the packages
source("./src/packages.R")       # loads up all the packages we need
wd
rm(list = ls())
#' set working directory for Mac and PC
wd<-getwd()
wd
options(scipen = 6, digits = 4) # I prefer to view outputs in non-scientific notation
memory.limit(30000000)     # this is needed on some PCs to increase memory allowance, but has no impact on macs.
#' load up the packages
source("./src/packages.R")       # loads up all the packages we need
## ---------------------------
source("./src/functions.R")
dataFolder <- './data/raw'
# select folders
folderSelect <- as.matrix(list.files(paste0(dataFolder, '/GEE_exports'), full.names = T))
folderSelect
# select folders
folderSelect <- as.matrix(list.files(paste0(dataFolder, '/GEE_exports'), full.names = T))
folderSelect
dataFolder <- './data/raw'
dataFolder
# select folders
folderSelect <- as.matrix(list.files(paste0(dataFolder, '/GEE_exports'), full.names = T))
folderSelect
df <- rewrite(folderSelect);
df
csv = as.matrix(read.csv2(as.character(df[2,1]),
header = T, sep = ',', na.strings=c("","NA"))) # rewrite as matrix to read columns as numeric values
df[grep('csv', df, ignore.case = T),]
df
grep('.csv', df, ignore.case = T)
grep('.csv$', df, ignore.case = T)
grep('Suriname', df, ignore.case = T)
grepl('Suriname', df, ignore.case = T)
grep('Suriname', folderSelect, ignore.case = T)
folderSelect
# only csv's
df[grep('.csv', folderSelect, ignore.case = T),]
# only csv's
df <- df[grep('.csv', folderSelect, ignore.case = T),]
csv = as.matrix(read.csv2(as.character(df[1,1]),
header = T, sep = ',', na.strings=c("","NA"))) # rewrite as matrix to read columns as numeric values
dates <- col_of_interest(csv, 'DATE_ACQUIRED$')
coastDist <- col_of_interest(csv, 'coastDist$')
# all unique dates
uniqueDates <- unique(csv[,dates]);
uniqueDates
# all unique transect (id's)
pos <- unique(csv[, col_of_interest(csv, 'pos$')]);
uniqueX<- unique(csv[, col_of_interest(csv, 'originX$')]);
uniqueY<- unique(csv[, col_of_interest(csv, 'originY$')]);
geo<- unique(csv[, col_of_interest(csv, '.geo')]);
# define output matrices
lines <- vector('list', length(uniqueX));
allPoints <- vector('list', length(csv));
df_coastDist = data.frame(matrix(NA, length(uniqueX), length(uniqueDates)+1),
stringsAsFactors=F) # Empty data frame for coastal distance
colnames(df_coastDist) <- c('pos', uniqueDates)
uniqueX
uniqueY
geo
for (n in 1:length(uniqueX)){
#n<-103
# Coordinates of transects
coords <- qdapRegex::ex_between(as.character(geo[n]), ":[", "]}")[[1]]
all_digits <- regmatches(coords, gregexpr("[-[:digit:].]+", coords))[[1]]
begin_coords <- data.frame(lon = as.numeric(all_digits[1]),
lat = as.numeric(all_digits[2]))
end_coords <- data.frame(lon = as.numeric(all_digits[3]),
lat = as.numeric(all_digits[4]))
x <- as.matrix(rbind(begin_coords, end_coords))
lines[[n]] <- Lines(list(Line(x)), ID = n)  # create line feature
# only return observations if coastDist >= 0 and if coordinates
test1transect <- subset(csv,csv[,col_of_interest(csv, 'originX$')]== uniqueX[n]
& csv[,col_of_interest(csv, 'coastDist$')] >= 0 )
subset <- test1transect[,sort(c(col_of_interest(csv, 'coastDist$'), col_of_interest(csv, 'DATE_ACQUIRED$'),
col_of_interest(csv, 'pos$')))]
# construct a data frame that matches the lines
if(is.null(nrow(subset))){
df_coastDist[n,] <- c(as.numeric(subset[3]), rep(NA, length(uniqueDates)))
# THIS THROWS ERROR LATER ON WHEN THERE IS NOTHING IN SUBSET ALSO NO POS IS ASSIGNED TO THE TRANSECT DATABASE!
} else {
# at the correct location in df_coastDist append the offshore location of mudbank boundary
mathcingDates <- match(subset[ ,col_of_interest(subset, 'DATE_ACQUIRED')], colnames(df_coastDist))
# append the pos number of the transect to the first column
df_coastDist[n,col_of_interest(df_coastDist, 'pos$')] <-  as.numeric(subset[,col_of_interest(subset, 'pos$')])[1]
# fill for each date column the retrieved value
df_coastDist[n,mathcingDates[!is.na(c(mathcingDates))]] <- subset[,col_of_interest(subset, 'coastDist$')]
}
#
#
# coordiates of coastline points
coords <- data.frame(x = as.numeric(test1transect[,col_of_interest(csv, 'coastX$')]),
y = as.numeric(test1transect[,col_of_interest(csv, 'coastY$')]),
DATE_ACQUIRED = as.character(test1transect[,col_of_interest(csv, 'DATE_ACQUIRED$')]),
pos = as.character(test1transect[,col_of_interest(csv, 'pos$')]))
allPoints <- rbind(allPoints, coords)
}
points <- SpatialPointsDataFrame(data.frame(allPoints[,'x'], allPoints[,'y'] ),
data = data.frame(DATE_ACQUIRED = allPoints[,'DATE_ACQUIRED'],
pos = allPoints[,'pos']),
proj4string=CRS("+proj=longlat +datum=WGS84"))
# colnames(points@data) <- c("DATE_ACQUIRED")
AllLines <- SpatialLines(lines, proj4string=CRS("+proj=longlat +datum=WGS84"))
df <- SpatialLinesDataFrame(AllLines,data.frame(df_coastDist))
# change format of lines
lines_sf <- st_as_sf(df)
points_sf <- st_as_sf(points)
mapview(lines_sf,xcol = "x", ycol = "y") + mapview(points_sf, zcol = c("DATE_ACQUIRED"))
# create a spatialData Frame (for interactive plotting)
SpatialOffShore <- SpatialPointsDataFrame(data.frame(offShorePoints[,'x'], offShorePoints[,'y'] ),
data = data.frame(offShorePoints[,'pos'], offShorePoints[,'DATE_ACQUIRED']),
proj4string=CRS("+proj=longlat +datum=WGS84"))
offShorePoints <- vector('list', length(csv))
# off-shore points for selected images
for (q in 1:length(uniqueDates)){
# q <- 6
# select all rows that have an acquisition date
date <- uniqueDates[q]
csv_subset <- subset(csv,csv[,col_of_interest(csv, 'DATE_ACQUIRED$')]== date)
coordsOffShore <- data.frame(x = as.numeric(csv_subset[,col_of_interest(csv_subset, 'peakCoordX$')]),
y = as.numeric(csv_subset[,col_of_interest(csv_subset, 'peakCoordY$')]),
pos = as.numeric(csv_subset[,col_of_interest(csv_subset, 'pos$')]),
DATE_ACQUIRED = as.character(date),
axisDist = as.numeric(csv_subset[,col_of_interest(csv_subset, 'axisDist$')]))
offShorePoints <- rbind(offShorePoints, coordsOffShore)
}
# filter off-shore points -1
offShorePoints <- subset(offShorePoints, offShorePoints[,col_of_interest(offShorePoints, 'x')] != -1)
# Example per time step
date_to_test <- c('2019-02-28')
# Example per time step
date_to_test <- c('2018-12-18')
testYearly <- subset(offShorePoints, offShorePoints[,col_of_interest(offShorePoints, 'DATE_ACQUIRED')] == date_to_test)
testYearlyCoastline <- subset(allPoints, allPoints[,col_of_interest(allPoints, 'DATE_ACQUIRED')] == date_to_test)
# transform to spatialPointsDataFrame
SpatialtestYearly <- SpatialPointsDataFrame(data.frame(testYearly[,'x'], testYearly[,'y'] ),
data = data.frame(pos = testYearly[,'pos'],
DATE_ACQUIRED= testYearly[,'DATE_ACQUIRED'],
axisDist = testYearly[,'axisDist']),
proj4string=CRS("+proj=longlat +datum=WGS84"))
Spatial_testYearlyCoastline <- SpatialPointsDataFrame(data.frame(testYearlyCoastline[,'x'], testYearlyCoastline[,'y'] ),
data = data.frame(pos = testYearlyCoastline[,'pos'],
DATE_ACQUIRED= testYearlyCoastline[,'DATE_ACQUIRED']),
proj4string=CRS("+proj=longlat +datum=WGS84"))
mapview(SpatialtestYearly, xcol = "x", ycol = "y")  +
mapview(Spatial_testYearlyCoastline, xcol = "x", ycol = "y", col.regions = c("red"))
testYearly <- subset(offShorePoints, offShorePoints[,col_of_interest(offShorePoints, 'DATE_ACQUIRED')] == date_to_test)
testYearlyCoastline <- subset(allPoints, allPoints[,col_of_interest(allPoints, 'DATE_ACQUIRED')] == date_to_test)
# transform to spatialPointsDataFrame
SpatialtestYearly <- SpatialPointsDataFrame(data.frame(testYearly[,'x'], testYearly[,'y'] ),
data = data.frame(pos = testYearly[,'pos'],
DATE_ACQUIRED= testYearly[,'DATE_ACQUIRED'],
axisDist = testYearly[,'axisDist']),
proj4string=CRS("+proj=longlat +datum=WGS84"))
# create a spatialData Frame (for interactive plotting)
SpatialOffShore <- SpatialPointsDataFrame(data.frame(offShorePoints[,'x'], offShorePoints[,'y'] ),
data = data.frame(offShorePoints[,'pos'], offShorePoints[,'DATE_ACQUIRED']),
proj4string=CRS("+proj=longlat +datum=WGS84"))
colnames(SpatialOffShore@data) <- c("pos","DATE_ACQUIRED")
SpatialOffShore_sf <- st_as_sf(SpatialOffShore)
mapview(SpatialOffShore_sf,xcol = "x", ycol = "y",  zcol = c("DATE_ACQUIRED")) + mapview(lines_sf)
# average position per tansect
allAveragePoints <- vector('list', length(SpatialtestYearly@data$pos));
for (x in 1:length(SpatialtestYearly@data$pos)){
# x<-1
alongshorePosition <- SpatialtestYearly@data$pos[x]
transectObs = subset(offShorePoints, offShorePoints[,col_of_interest(offShorePoints, 'pos')] == alongshorePosition)
meanAxisDist = mean(transectObs$axisDist)
# translate distances along transect
# get corresponding transect (matching pos)
selectedTransect <- df[df$pos == alongshorePosition, ]
# mapview(st_as_sf(selectedTransect))
# get coordinates at meanDistance away from origin
# change to meters
selectedTransect <- spTransform(selectedTransect, CRS(as.character("+proj=utm +zone=21 +ellps=intl +towgs84=-265,120,-358,0,0,0,0 +units=m +no_defs")))
lineCoords <- coordinates(selectedTransect)[[1]][[1]]
# theta <- atan2(pos$ynext-pos$yprev, pos$xnext-pos$xprev)
# # Angle between points on the line in radians (y1- y0, x1-x0)
theta <- atan2(lineCoords[1]-lineCoords[2], lineCoords[3]-lineCoords[4])   #?
thetaT <- theta+pi/2
dx_poi <- meanAxisDist*cos(thetaT)      # coordinates of point of interest as defined by position length (sep)
dy_poi <- meanAxisDist*sin(thetaT)
xnew = lineCoords[1] - dx_poi
ynew = lineCoords[3] - dy_poi
newPoint <- spTransform(SpatialPoints(data.frame(x = xnew, y = ynew),CRS(as.character(selectedTransect@proj4string))),
CRS("+proj=longlat +datum=WGS84"))
allAveragePoints <- rbind(allAveragePoints, data.frame(x=newPoint@coords[1], y = newPoint@coords[2],
pos = alongshorePosition,
meanAxisDist = meanAxisDist))
# mapview(st_as_sf(selectedTransect)) +mapview(newPoint)
}
meaOffShore <- SpatialPointsDataFrame(data.frame(allAveragePoints[,'x'], allAveragePoints[,'y'] ),
data = data.frame(allAveragePoints[,'pos'], allAveragePoints[,'meanAxisDist']),
proj4string=CRS("+proj=longlat +datum=WGS84"))
st_meaOffShore <- st_as_sf(meaOffShore)
mapview(st_meaOffShore,xcol = "x", ycol = "y", col.regions = c("red")) + mapview(lines_sf) + mapview(SpatialOffShore_sf,xcol = "x", ycol = "y",  zcol = c("DATE_ACQUIRED"))
x<-1
# x<-1
alongshorePosition <- SpatialtestYearly@data$pos[x]
alongshorePosition
transectObs = subset(offShorePoints, offShorePoints[,col_of_interest(offShorePoints, 'pos')] == alongshorePosition)
# x<-113
alongshorePosition <- SpatialtestYearly@data$pos[x]
x<-113
# x<-113
alongshorePosition <- SpatialtestYearly@data$pos[x]
transectObs = subset(offShorePoints, offShorePoints[,col_of_interest(offShorePoints, 'pos')] == alongshorePosition)
transectObs
alongshorePosition
SpatialtestYearly@data$pos[x]
mean(transectObs$axisDist)
# translate distances along transect
# get corresponding transect (matching pos)
selectedTransect <- df[df$pos == alongshorePosition, ]
# get coordinates at meanDistance away from origin
# change to meters
selectedTransect <- spTransform(selectedTransect, CRS(as.character("+proj=utm +zone=21 +ellps=intl +towgs84=-265,120,-358,0,0,0,0 +units=m +no_defs")))
lineCoords <- coordinates(selectedTransect)[[1]][[1]]
lineCoords
# theta <- atan2(pos$ynext-pos$yprev, pos$xnext-pos$xprev)
# # Angle between points on the line in radians (y1- y0, x1-x0)
theta <- atan2(lineCoords[1]-lineCoords[2], lineCoords[3]-lineCoords[4])   #?
thetaT <- theta+pi/2
dx_poi <- meanAxisDist*cos(thetaT)      # coordinates of point of interest as defined by position length (sep)
dy_poi <- meanAxisDist*sin(thetaT)
xnew = lineCoords[1] - dx_poi
ynew = lineCoords[3] - dy_poi
newPoint <- spTransform(SpatialPoints(data.frame(x = xnew, y = ynew),CRS(as.character(selectedTransect@proj4string))),
CRS("+proj=longlat +datum=WGS84"))
library(rgdal)  # for reading/creating shapefiles
rm(list = ls())
#' load up the packages
source("./src/packages.R")       # loads up all the packages we need
