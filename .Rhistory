)#
e <- nls(distances~a +(positions*b) + (c*positions) + (d*positions*distances) + e*positions^2 + f*distances^2, #
start = c(b = 1, a =1,c = 1,d=1,e=1,f=1 ),algorithm = "plinear"
)#
e <- nls(distances~a*positions/(b+positions), #
start = c(b = 195000, a =3000),algorithm = "plinear"
)#
e <- nls(distances~a*positions/(b+positions), #
start = c(b = 195000, a =3000),algorithm = "plinear", minFactor = 1
)#
?nls
e <- nls(distances~a*positions/(b+positions), #
start = c(b = 195000, a =3000),algorithm = "plinear"
)#
fractions <- ajoining_points_orderd$mudFract
fractions
plot(positions,fractions)
points(distances, fractions, col = 'blue')
plot(distances, fractions, col = 'blue')
uniqueDates
transform<-st_transform(mudbanks_selection, 32621)
geom <- cbind(st_coordinates(mudbanks_selection), pos = as.numeric(as.character(mudbanks_selection$pos)))
geom
# order on position
geom_ordered <- geom[order(geom[,'pos']),]
range <- 9:16 # for testing
plot( geom_ordered[range,1], geom_ordered[range,2],type="p") # original points
geom_ordered
range <- 144:163 # for testing
plot( geom_ordered[range,1], geom_ordered[range,2],type="p") # original points
range
geom_ordered[range,1]
geom_ordered[range,2]
plot(positions,fractions)
plot(as.character(ajoining_points$pos), ajoining_points$axisDist)
points(as.character(selected_point$pos), selected_point$axisDist, col = 'blue')
plot(as.character(ajoining_points_orderd$pos), ajoining_points_orderd$axisDist)
points(as.character(selected_point$pos), selected_point$axisDist, col = 'blue')
functionD <- DouglasPeuckerEpsilon(trajx = ajoining_points_orderd$x,trajy = ajoining_points_orderd$y, epsilon = 0.01, spar = NA)
# testD <- DouglasPeuckerNbPoints( geom_ordered[range,1], trajy = geom_ordered[range,2], 2, spar=NA)
# points( testD[,1], testD[,2],type="p", col = 'red')
points( functionD[,1], functionD[,2],type="p", col = 'red')
functionD
plot(ajoining_points_orderd$x, ajoining_points_orderd$y)
functionD <- DouglasPeuckerEpsilon(trajx = ajoining_points_orderd$x,trajy = ajoining_points_orderd$y, epsilon = 0.01, spar = NA)
# testD <- DouglasPeuckerNbPoints( geom_ordered[range,1], trajy = geom_ordered[range,2], 2, spar=NA)
# points( testD[,1], testD[,2],type="p", col = 'red')
points( functionD[,1], functionD[,2],type="p", col = 'red')
functionD <- DouglasPeuckerEpsilon(trajx = ajoining_points_orderd$x,trajy = ajoining_points_orderd$y, epsilon = 0.1, spar = NA)
plot(ajoining_points_orderd$x, ajoining_points_orderd$y)
functionD <- DouglasPeuckerEpsilon(trajx = ajoining_points_orderd$x,trajy = ajoining_points_orderd$y, epsilon = 0.1, spar = NA)
# testD <- DouglasPeuckerNbPoints( geom_ordered[range,1], trajy = geom_ordered[range,2], 2, spar=NA)
# points( testD[,1], testD[,2],type="p", col = 'red')
points( functionD[,1], functionD[,2],type="p", col = 'red')
functionD <- DouglasPeuckerEpsilon(trajx = ajoining_points_orderd$x,trajy = ajoining_points_orderd$y, epsilon = 0.001, spar = NA)
plot(ajoining_points_orderd$x, ajoining_points_orderd$y)
functionD <- DouglasPeuckerEpsilon(trajx = ajoining_points_orderd$x,trajy = ajoining_points_orderd$y, epsilon = 0.001, spar = NA)
# testD <- DouglasPeuckerNbPoints( geom_ordered[range,1], trajy = geom_ordered[range,2], 2, spar=NA)
# points( testD[,1], testD[,2],type="p", col = 'red')
points( functionD[,1], functionD[,2],type="p", col = 'red')
plot(ajoining_points_orderd$x, ajoining_points_orderd$y)
functionD <- DouglasPeuckerEpsilon(trajx = ajoining_points_orderd$x,trajy = ajoining_points_orderd$y, epsilon = 0.0001, spar = NA)
# testD <- DouglasPeuckerNbPoints( geom_ordered[range,1], trajy = geom_ordered[range,2], 2, spar=NA)
# points( testD[,1], testD[,2],type="p", col = 'red')
points( functionD[,1], functionD[,2],type="p", col = 'red')
plot(ajoining_points_orderd$x, ajoining_points_orderd$y)
plot(positions,fractions)
plot(positions, distnaces)
plot(positions, distances)
plot(positions,fractions)
plot(distances, fractions, col = 'blue')
plot(positions,fractions, col ='red')
plot(positions, distances)
# for testing: set to cloudfree
cloudFree <- ee$Image(collection$filter(ee$Filter$gt("CLOUD_COVER", 20))$
filterDate(as.character(as.Date(min(uniqueDates))-1), as.character(as.Date(max(uniqueDates))+1))$
sort("CLOUD_COVER")$first())
id <- eedate_to_rdate(cloudFree$get("system:time_start"))
i <- uniqueDates[uniqueDates == as.Date(id)]
coastlines_selection <-subset(coastlines, coastlines$DATE_ACQUIRED == i &
coastlines$coastDist >= 0)
mudbanks_selection <-subset(mudbanks, mudbanks$DATE_ACQUIRED == i &
mudbanks$axisDist >= 0)
# order
coastlines_selection[order(as.character(coastlines_selection$pos)),]
mudbanks_selection[order(as.character(mudbanks_selection$pos)),]
# collection for testing
filtCollect <- collection$filterDate(as.character(as.Date(i)-1), as.character(as.Date(i)+1))
dates <- ee_get_date_ic(filtCollect, time_end = FALSE)
id <- eedate_to_rdate(filtCollect$first()$get("system:time_start"))
first <- Map$addLayer(filtCollect$first(), visParams, paste0(i))
Map$centerObject(filtCollect$first())
first+mapview(coastlines_selection, col.regions = c("red"), layer.name = i) +
mapview(mudbanks_selection, col.regions = c("green"), layer.name = i )
# for testing: set to cloudfree
cloudFree <- ee$Image(collection$filter(ee$Filter$gt("CLOUD_COVER", 0))$
filterDate(as.character(as.Date(min(uniqueDates))-1), as.character(as.Date(max(uniqueDates))+1))$
sort("CLOUD_COVER")$first())
id <- eedate_to_rdate(cloudFree$get("system:time_start"))
i <- uniqueDates[uniqueDates == as.Date(id)]
coastlines_selection <-subset(coastlines, coastlines$DATE_ACQUIRED == i &
coastlines$coastDist >= 0)
mudbanks_selection <-subset(mudbanks, mudbanks$DATE_ACQUIRED == i &
mudbanks$axisDist >= 0)
# order
coastlines_selection[order(as.character(coastlines_selection$pos)),]
mudbanks_selection[order(as.character(mudbanks_selection$pos)),]
# collection for testing
filtCollect <- collection$filterDate(as.character(as.Date(i)-1), as.character(as.Date(i)+1))
dates <- ee_get_date_ic(filtCollect, time_end = FALSE)
id <- eedate_to_rdate(filtCollect$first()$get("system:time_start"))
first <- Map$addLayer(filtCollect$first(), visParams, paste0(i))
Map$centerObject(filtCollect$first())
# plot
first+mapview(coastlines_selection, col.regions = c("red"), layer.name = i) +
mapview(mudbanks_selection, col.regions = c("green"), layer.name = i )
pos_of_interst <- 130000
selected_point <-mudbanks_selection[which(mudbanks_selection$pos == pos_of_interst),]
# select nearby points
# a) nearest 2?
# b) based on pos
ajoining_points <- subset(mudbanks_selection, as.character(pos) <=  as.numeric(as.character(selected_point$pos))+4000 &
as.character(pos) >= as.numeric(as.character(selected_point$pos))-4000 &
as.character(pos) != as.numeric(as.character(selected_point$pos)))
# order by pos
ajoining_points_orderd<-ajoining_points[order(as.numeric(as.character(ajoining_points$pos))),]
geom <- st_coordinates(ajoining_points)
test_spline<-smooth.spline(geom[,1] ~ geom[,2], spar=0.50)
SpatialPoints <- SpatialPointsDataFrame(data.frame(test_spline$y, test_spline$x ),
data = data.frame(DATE_ACQUIRED = ajoining_points$DATE_ACQUIRED,
mudFract = ajoining_points$mudFract),
proj4string=CRS("+proj=longlat +datum=WGS84"))
plot(st_coordinates(ajoining_points)[,'X'], st_coordinates(ajoining_points)[,'Y'],
ylim = c(min(c(ajoining_points$y, selected_point$y)),max(c(ajoining_points$y, selected_point$y))))
points(st_coordinates(selected_point)[,'X'], st_coordinates(selected_point)[,'Y'], col = 'red') # point of interest
plot(as.character(ajoining_points_orderd$pos), ajoining_points_orderd$axisDist)
points(as.character(selected_point$pos), selected_point$axisDist, col = 'blue')
positions<- as.numeric(as.character(ajoining_points_orderd$pos))
distances <-ajoining_points_orderd$axisDist
fractions <- ajoining_points_orderd$mudFract
datatest <- data.frame(positions=positions,distances=distances)
plot(positions, distances)
plot(positions,fractions, col ='red')
plot(distances, fractions, col = 'blue')
selected_point
selected_point
ajoining_points
combined <- merge(selected_point,ajoining_points)
combined <- st_join(selected_point,ajoining_points)
combined
combined <- st_join(selected_point,ajoining_points)
rbindlist(ajoining_points)
data.table::rbindlist(ajoining_points)
?rbind
combined <- rbind(selected_point,ajoining_points)
combined
ajoining_points
# order by pos
combined_ordered <-ajoining_points[order(as.numeric(as.character(ajoining_points$pos))),]
combined <- rbind(selected_point,ajoining_points)
# order by pos
combined_ordered <-ajoining_points[order(as.numeric(as.character(ajoining_points$pos))),]
# order by pos
combined_ordered <-combined[order(as.numeric(as.character(combined$pos))),]
combined_ordered
combined
plot(st_coordinates(ajoining_points)[,'X'], st_coordinates(ajoining_points)[,'Y'],
ylim = c(min(c(ajoining_points$y, selected_point$y)),max(c(ajoining_points$y, selected_point$y))))
plot(st_coordinates(combined)[,'X'], st_coordinates(combined)[,'Y'],
ylim = c(min(c(combined$y, selected_point$y)),max(c(combined$y, selected_point$y))))
points(st_coordinates(selected_point)[,'X'], st_coordinates(selected_point)[,'Y'], col = 'red') # point of interest
positions<- as.numeric(as.character(combined_ordered$pos))
distances <-combined_ordered$axisDist
fractions <- combined_ordered$mudFract
datatest <- data.frame(positions=positions,distances=distances)
plot(positions, distances)
plot(positions,fractions, col ='red')
plot(positions, distances)
plot(distances, fractions, col = 'blue')
plot(positions, distances)
plot(positions,fractions, col ='red')
lm(datatest$fractions~as.numeric(datatest$positions))
datatest$fractions
datatest <- data.frame(positions=positions,distances=distances, fractions = fractions)
lm(datatest$fractions~as.numeric(datatest$positions))
abline(lm(datatest$fractions~as.numeric(datatest$positions)),lty = 2)
plot(positions, distances)
abline(lm(datatest$distances~as.numeric(datatest$positions)),lty = 2)
plot(positions,fractions, col ='red')
abline(lm(datatest$fractions~as.numeric(datatest$positions)),lty = 2)
plot(distances, fractions, col = 'blue')
plot(fractions, distances, col = 'blue')
abline(lm(datatest$distances~as.numeric(datatest$fractions)),lty = 2)
# calculate linear fit
lm.out <- lm(datatest$distances~as.numeric(datatest$positions))
plot(positions, distances)
abline(lm(datatest$distances~as.numeric(datatest$positions)),lty = 2)
# calculate linear fit
lm.out <- lm(datatest$distances~as.numeric(datatest$positions))
intercept <-lm.out$coefficients[1]
slope <- lm.out$coefficients[2]
intercept
slope
# residuals
resid <- lm.out$residuals
resid
maxResid
maxResid <- which.max(abs(resid))
maxResid
lm.out
lm.out$fitted.values
lm.out$fitted.values
points(lm.out$fitted.values)
# Also set a threshold of some sort -> largest residual can still be valid
# consider using the fitted values. if they are a certain fraction compared to
# the original? ()
points(positions,lm.out$fitted.values)
lm.out$fitted.values/distances
resid
distances
positions
maxResid
resid
max(resid)
.6*max(resid)
# Also set a threshold of some sort -> largest residual can still be valid
# consider using the fitted values. if they are a certain fraction compared to
# the original? ()
lm.out$fitted.values>.6*max(resid)
lm.out$fitted.values
resid
abs(resid)
max(abs(resid))
# Also set a threshold of some sort -> largest residual can still be valid
# consider using the fitted values. if they are a certain fraction compared to
# the original? ()
abs(lm.out$fitted.values)>.6*max(abs(resid))
lm.out$fitted.values
resid
.6*max(abs(resid))
abs(lm.out$fitted.values)
# Also set a threshold of some sort -> largest residual can still be valid
# consider using the fitted values. if they are a certain fraction compared to
# the original? ()
abs(distances)>.6*max(abs(resid))
pnt
selectedCoast <- coastlines_selection[pnt,]
selected_point
mudbanks_selection$pos == pos_of_interst
coastlines_selection$pos == pos_of_interst
selectedCoast <- coastlines_selection[coastlines_selection$pos == pos_of_interst,]
selectedCoast
mudbanks_selection
coastlines_selection
View(mudbanks_selection)
keep_columns <- c('axisDist', 'mudFract', 'endDrop', 'coastDist')  # necessary for mudbank output
mudbanks <- reshape_csvPoints(allFiles, 'peakCoordX', 'peakCoordY', keep_columns)
mudbanks
# normalize mudbank Distance:
# combine them in one table; one entry for each location
mudbanks$distance <- mudbanks$axisDist - mudbanks$coastDist
mudbanks
install.packages("imputeTS")
library(imputeTS)
?na.locf
zoo::na.locf(mudbanks)
# set -1 coast dist to NA
mudbanks$coastDist[mudbanks$coastDist == -1] <- NA
mudbanks
mudbanks$distance <- mudbanks$axisDist - mudbanks$coastDist
test<-na.locf(mudbanks, option = "locf")   # Last Obs. Carried Forward
View(mudbanks)
warnings()
View(test)
test<-na.locf(mudbanks$coastDist, option = "locf")   # Last Obs. Carried Forward
mudbanks$coastDist2<-na_locf(mudbanks$coastDist, option = "locf")   # Last Obs. Carried Forward
View(mudbanks)
## ---------------------------
source("./src/functions.R")
mapviewOptions(basemaps = c( "Esri.WorldImagery","Esri.WorldShadedRelief", "OpenStreetMap.DE"))
dataFolder <- './data/raw'
years <- c('2018', '2019')
# select folders
folderSelect <- as.matrix(list.files(paste0(dataFolder, '/GEE_exports'), full.names = T))
df <- rewrite(folderSelect);
# only csv's
df <- df[grep('.csv', folderSelect, ignore.case = T),]
filtered <- vector('list', 100)
for (q in seq_along(years)) {
# q <- 1
year = years[q]
filters = c(year)
filtered = rbind(filtered, df %>%
dplyr::filter(
filters %>%
# apply the filter of all the text rows for each pattern
# you'll get one list of logical by pattern ignored_string
purrr::map(~ to_keep(.x, text = text)) %>%
# get a logical vector of rows to keep
purrr::pmap_lgl(all)
))
}
filtered
allFiles <- do.call(rbind, lapply(as.matrix(filtered)[,1], function(x) read.csv(x, stringsAsFactors = FALSE,
sep = ',', na.strings=c("","NA")
)))
col_dates <- col_of_interest(allFiles, 'DATE_ACQUIRED$')
col_coastDist <- col_of_interest(allFiles, 'coastDist$')
# all unique dates
uniqueDates <- unique(allFiles[,col_dates]);
# all unique transect (id's)
allPos <- unique(allFiles[, col_of_interest(allFiles, 'pos$')]);
uniqueX<- unique(allFiles[, col_of_interest(allFiles, 'originX$')]);
uniqueY<- unique(allFiles[, col_of_interest(allFiles, 'originY$')]);
geo<- unique(allFiles[, col_of_interest(allFiles, '.geo')]);
coastlines <- reshape_csvPoints(allFiles, 'coastX', 'coastY', c('coastDist'))
keep_columns <- c('axisDist', 'mudFract', 'endDrop', 'coastDist')  # necessary for mudbank output
mudbanks <- reshape_csvPoints(allFiles, 'peakCoordX', 'peakCoordY', keep_columns)
mudbanks
# if coastDist = -1; replace with nearest observations
# set -1 coast dist to NA
mudbanks$coastDist[mudbanks$coastDist == -1] <- NA
View(mudbanks)
mudbanks$dist_locf <- na_locf(mudbanks$coastDist, option = "locf")   # Last Obs. Carried Forward
?na_locf
# sort al rows based on position & date
mudbanks[order(-mudbanks[,mudbanks$pos], mudbanks[,mudbanks$DATE_ACQUIRED]), ]
order(-mudbanks$pos)
-mudbanks$pos
with(mudbanks, order(pos, DATE_ACQUIRED))
mudbanks[with(mudbanks, order(pos, DATE_ACQUIRED)), ]
View(mudbanks)
View(mudbanks)
# sort al rows based on position & date
mudbanks<-mudbanks[with(mudbanks, order(pos, DATE_ACQUIRED)), ]
View(mudbanks)
mudbanks$dist_locf <- na_locf(mudbanks$coastDist, option = "locf")   # Last Obs. Carried Forward
# normalize mudbank Distance:
mudbanks$distance <- mudbanks$axisDist - mudbanks$coastDist
# normalize mudbank Distance:
mudbanks$distance <- mudbanks$axisDist - mudbanks$dist_locf
# for testing: set to cloudfree
cloudFree <- ee$Image(collection$filter(ee$Filter$gt("CLOUD_COVER", 0))$
filterDate(as.character(as.Date(min(uniqueDates))-1), as.character(as.Date(max(uniqueDates))+1))$
sort("CLOUD_COVER")$first())
# plotting example
collectionL5 <- ee$ImageCollection("LANDSAT/LT05/C01/T1_TOA")$
filterBounds(ee$Geometry$Point(-55.54, 5.94))
collectionL7 <- ee$ImageCollection("LANDSAT/LE07/C01/T1_TOA")$
filterBounds(ee$Geometry$Point(-55.54, 5.94))
collectionL8 <- ee$ImageCollection("LANDSAT/LC08/C01/T1_TOA")$
filterBounds(ee$Geometry$Point(-55.54, 5.94))
collection <- collectionL8$merge(collectionL7)$merge(collectionL5)
visParams = list(
bands = c("B5", "B4", "B3"),
min = 0.05, max = 0.4, gamma = 1.4
)
i <- uniqueDates[3]
# for testing: set to cloudfree
cloudFree <- ee$Image(collection$filter(ee$Filter$gt("CLOUD_COVER", 0))$
filterDate(as.character(as.Date(min(uniqueDates))-1), as.character(as.Date(max(uniqueDates))+1))$
sort("CLOUD_COVER")$first())
id <- eedate_to_rdate(cloudFree$get("system:time_start"))
i <- uniqueDates[uniqueDates == as.Date(id)]
coastlines_selection <-subset(coastlines, coastlines$DATE_ACQUIRED == i &
coastlines$coastDist >= 0)
mudbanks_selection <-subset(mudbanks, mudbanks$DATE_ACQUIRED == i &
mudbanks$axisDist >= 0)
coastlines_selection <-subset(coastlines, coastlines$DATE_ACQUIRED == i &
coastlines$coastDist >= 0)
mudbanks_selection <-subset(mudbanks, mudbanks$DATE_ACQUIRED == i &
mudbanks$axisDist >= 0)
mudbanks_selection
View(mudbanks_selection)
coastlines_selection[order(as.character(coastlines_selection$pos)),]
mudbanks_selection[order(as.character(mudbanks_selection$pos)),]
# collection for testing
filtCollect <- collection$filterDate(as.character(as.Date(i)-1), as.character(as.Date(i)+1))
dates <- ee_get_date_ic(filtCollect, time_end = FALSE)
id <- eedate_to_rdate(filtCollect$first()$get("system:time_start"))
first <- Map$addLayer(filtCollect$first(), visParams, paste0(i))
Map$centerObject(filtCollect$first())
# plot
first+mapview(coastlines_selection, col.regions = c("red"), layer.name = i) +
mapview(mudbanks_selection, col.regions = c("green"), layer.name = i )
pos_of_interst <- 130000
selected_point <-mudbanks_selection[which(mudbanks_selection$pos == pos_of_interst),]
# select nearby points
# a) nearest 2?
# b) based on pos
ajoining_points <- subset(mudbanks_selection, as.character(pos) <=  as.numeric(as.character(selected_point$pos))+4000 &
as.character(pos) >= as.numeric(as.character(selected_point$pos))-4000 &
as.character(pos) != as.numeric(as.character(selected_point$pos)))
combined <- rbind(selected_point,ajoining_points)
# order by pos
combined_ordered <-combined[order(as.numeric(as.character(combined$pos))),]
plot(st_coordinates(combined)[,'X'], st_coordinates(combined)[,'Y'],
ylim = c(min(c(combined$y, selected_point$y)),max(c(combined$y, selected_point$y))))
points(st_coordinates(selected_point)[,'X'], st_coordinates(selected_point)[,'Y'], col = 'red') # point of interest
positions<- as.numeric(as.character(combined_ordered$pos))
distances <-combined_ordered$axisDist
fractions <- combined_ordered$mudFract
datatest <- data.frame(positions=positions,distances=distances, fractions = fractions)
plot(positions, distances)
distances <-combined_ordered$distance
distances <-combined_ordered$distance # grap the normalized distances
fractions <- combined_ordered$mudFract
datatest <- data.frame(positions=positions,distances=distances, fractions = fractions)
plot(positions, distances)
combined_ordered$distance
combined_ordered
View(combined_ordered)
plot(positions,fractions, col ='red')
plot(positions, distances)
abline(lm(datatest$distances~as.numeric(datatest$positions)),lty = 2)
# calculate linear fit
lm.out <- lm(datatest$distances~as.numeric(datatest$positions))
# points(positions,lm.out$fitted.values)
intercept <-lm.out$coefficients[1]
slope <- lm.out$coefficients[2]
intercept
# residuals
resid <- lm.out$residuals
resid
maxResid <- which.max(abs(resid))
maxResid
abs(distances)
max(abs(resid))
abs(distances)>.6*max(abs(resid))
maxResid <- which.max(abs(resid))
maxResid
combined_ordered[maxResid]
# if maxResid is same as selected point
# remove it? ==> probably give indication that it needs to be dropped when all computations are finished
# Perhaps consider the running for outliers again/
combined_ordered[maxResid,]
combined_ordered[maxResid,]$pos
# if maxResid is same as selected point
# remove it? ==> probably give indication that it needs to be dropped when all computations are finished
# Perhaps consider the running for outliers again/
as.character(combined_ordered[maxResid,]$pos)
# if maxResid is same as selected point
# remove it? ==> probably give indication that it needs to be dropped when all computations are finished
# Perhaps consider the running for outliers again/
as.numeric(as.character(combined_ordered[maxResid,]$pos))
selected_point$pos
as.numeric(as.character(combined_ordered[maxResid,]$pos)) == as.numeric(as.character(selected_point$pos))
# set outlier to 0
mudbanks$outlier <- 0
View(mudbanks)
selected_point
match(mudbanks, selected_point)
match(selected_point, mudbanks)
?match
selected_point
colnames(selected_point)
colnames(mudbanks)
selected_point
mudbanks
selected_point
rowname(selected_point)
row.names(selected_point)
subset(mudbanks, rown.names(mudbanks) == row.names(selected_point))
rown.names(mudbanks)
subset(mudbanks, row.names(mudbanks) == row.names(selected_point))
which(mudbanks, row.names(mudbanks) == row.names(selected_point))
which(row.names(mudbanks) == row.names(selected_point))
mudbanks[which(row.names(mudbanks) == row.names(selected_point))]
mudbanks[which(row.names(mudbanks) == row.names(selected_point)),]
mudbanks[which(row.names(mudbanks) == row.names(selected_point)), 'outlier']
mudbanks[which(row.names(mudbanks) == row.names(selected_point)), 'outlier'] <- +1
mudbanks[which(row.names(mudbanks) == row.names(selected_point)), 'outlier']
mudbanks[which(row.names(mudbanks) == row.names(selected_point)), 'outlier'] <- +1
mudbanks[which(row.names(mudbanks) == row.names(selected_point)), 'outlier']
mudbanks[which(row.names(mudbanks) == row.names(selected_point)), 'outlier'] +1
mudbanks[which(row.names(mudbanks) == row.names(selected_point)), 'outlier'] +1
mudbanks[which(row.names(mudbanks) == row.names(selected_point)), 'outlier'] +1
row.names(selected_point)
mudbanks[which(row.names(mudbanks) == row.names(selected_point)), 'outlier'] +1
mudbanks[which(row.names(mudbanks) == row.names(selected_point)), 'outlier'] <- mudbanks[which(row.names(mudbanks) == row.names(selected_point)), 'outlier'] + 1
mudbanks[which(row.names(mudbanks) == row.names(selected_point)), 'outlier']
which(row.names(mudbanks) == row.names(selected_point))
mudbanks[which(row.names(mudbanks) == row.names(selected_point)), 'outlier'] + 1
mudbanks[which(row.names(mudbanks) == row.names(selected_point)), 'outlier'] + 1
mudbanks[which(row.names(mudbanks) == row.names(selected_point)), 'outlier'] + 1
mudbanks[which(row.names(mudbanks) == row.names(selected_point)), 'outlier'] <-
mudbanks[which(row.names(mudbanks) == row.names(selected_point)), 'outlier'] + 1
mudbanks[which(row.names(mudbanks) == row.names(selected_point)), 'outlier'] <-
mudbanks[which(row.names(mudbanks) == row.names(selected_point)), 'outlier'] += 1
mudbanks[which(row.names(mudbanks) == row.names(selected_point)), 'outlier'] <-
mudbanks[which(row.names(mudbanks) == row.names(selected_point)), 'outlier'] += 1
mudbanks[which(row.names(mudbanks) == row.names(selected_point)), 'outlier'] <-
mudbanks[which(row.names(mudbanks) == row.names(selected_point)), 'outlier'] =+ 1
mudbanks[which(row.names(mudbanks) == row.names(selected_point)), 'outlier'] <- mudbanks[which(row.names(mudbanks) == row.names(selected_point)), 'outlier'] =+ 1
mudbanks[which(row.names(mudbanks) == row.names(selected_point)), 'outlier'] =+ 1
mudbanks
mudbanks[which(row.names(mudbanks) == row.names(selected_point)), 'outlier']
mudbanks[which(row.names(mudbanks) == row.names(selected_point)), 'outlier'] + 1
class(mudbanks[which(row.names(mudbanks) == row.names(selected_point)), 'outlier'] )
as.vector(mudbanks[which(row.names(mudbanks) == row.names(selected_point)), 'outlier'] )
as.array(mudbanks[which(row.names(mudbanks) == row.names(selected_point)), 'outlier'] )
as.integer(mudbanks[which(row.names(mudbanks) == row.names(selected_point)), 'outlier'] )
mudbanks[1,12]
as.data.frame(mudbanks[which(row.names(mudbanks) == row.names(selected_point)),"outlier"])[,1]
mudbanks[which(row.names(mudbanks) == row.names(selected_point)), "outlier"] <- as.data.frame(mudbanks[which(row.names(mudbanks) == row.names(selected_point)),"outlier"])[,1] + 1
mudbanks[which(row.names(mudbanks) == row.names(selected_point)), "outlier"]
mudbanks[which(row.names(mudbanks) == row.names(selected_point)), "outlier"] <- as.data.frame(mudbanks[which(row.names(mudbanks) == row.names(selected_point)),"outlier"])[,1] + 1
mudbanks[which(row.names(mudbanks) == row.names(selected_point)), "outlier"]
print('true')
if (as.numeric(as.character(combined_ordered[maxResid,]$pos)) == as.numeric(as.character(selected_point$pos))){
print('true')
}
