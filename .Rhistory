csv2 = as.matrix(read.csv2(as.character(df[grep(set2, folderSelect, ignore.case = T),1]),
header = T, sep = ',', na.strings=c("","NA"))) # rewrite as matrix to read columns as numeric values
csv3 = as.matrix(read.csv2(as.character(df[grep(set3, folderSelect, ignore.case = T),1]),
header = T, sep = ',', na.strings=c("","NA"))) # rewrite as matrix to read columns as numeric values
# mydata <- sapply(list.files(paste0(dataFolder, '/GEE_exports/testImages'), full.names = T), read.csv)
points1<- reshape_csvPoints(csv1, 'peakCoordX', 'peakCoordY')
pointsLand1 <- reshape_csvPoints(csv1, 'coastX', 'coastY')
points2<- reshape_csvPoints(csv2, 'peakCoordX', 'peakCoordY')
pointsLand2 <- reshape_csvPoints(csv2, 'coastX', 'coastY')
points3<- reshape_csvPoints(csv3, 'peakCoordX', 'peakCoordY')
pointsLand3 <- reshape_csvPoints(csv3, 'coastX', 'coastY')
# filter -1?
lines1 <- reshape_csvLines(csv1)
# change format of lines
lines_sf <- st_as_sf(lines1)
# Load an image.
image20090912 <- ee$Image("LANDSAT/LT05/C01/T1_TOA/LT05_229056_20090912")
test1 <- Map$addLayer(image20090912, vizParams, "Landsat 8 False color")
test1 +
mapview(pointsLand2,col.regions = c("blue")) +
mapview(points1, col.regions = c("red"), layer.name = c("largestDrop")) +
mapview(points2, col.regions = c("green"), layer.name = c("relativeDrop")) +
mapview(points3, col.regions = c("yellow"), layer.name = c("slopeDrop")) +
mapview(lines_sf,xcol = "x", ycol = "y")
set1 <- 'Suriname_229_56_2009_till_2009_testImage20091115_largestDrop_20201210'
set2 <- 'Suriname_229_56_2009_till_2009_testImage20091115_relativeDrop_20201210'
set3 <- 'Suriname_229_56_2009_till_2009_testImage20091115_slopeDrop_20201210'
# largest, relative and slope drop for 20091115 image
# set1 <- 'Suriname_229_56_2009_till_2009_testImage20090912_largestDrop_20201210'
# set2 <- 'Suriname_229_56_2009_till_2009_testImage20090912_relativeDrop_20201210'
# set3 <- 'Suriname_229_56_2009_till_2009_testImage20090912_slopeDrop_20201210'
# set1 <- '/Suriname_229_56_2009_till_2009_testImage20090912_extraMask_largestDrop'
# set2 <- 'Suriname_229_56_2009_till_2009_testImage20090912_extraMask_V20201207'
csv1 = as.matrix(read.csv2(as.character(df[grep(set1, folderSelect, ignore.case = T),1]),
header = T, sep = ',', na.strings=c("","NA"))) # rewrite as matrix to read columns as numeric values
csv2 = as.matrix(read.csv2(as.character(df[grep(set2, folderSelect, ignore.case = T),1]),
header = T, sep = ',', na.strings=c("","NA"))) # rewrite as matrix to read columns as numeric values
csv3 = as.matrix(read.csv2(as.character(df[grep(set3, folderSelect, ignore.case = T),1]),
header = T, sep = ',', na.strings=c("","NA"))) # rewrite as matrix to read columns as numeric values
# mydata <- sapply(list.files(paste0(dataFolder, '/GEE_exports/testImages'), full.names = T), read.csv)
points1<- reshape_csvPoints(csv1, 'peakCoordX', 'peakCoordY')
pointsLand1 <- reshape_csvPoints(csv1, 'coastX', 'coastY')
points2<- reshape_csvPoints(csv2, 'peakCoordX', 'peakCoordY')
pointsLand2 <- reshape_csvPoints(csv2, 'coastX', 'coastY')
points3<- reshape_csvPoints(csv3, 'peakCoordX', 'peakCoordY')
pointsLand3 <- reshape_csvPoints(csv3, 'coastX', 'coastY')
# filter -1?
lines1 <- reshape_csvLines(csv1)
# change format of lines
lines_sf <- st_as_sf(lines1)
test1 <- Map$addLayer(image20091115, vizParams, "Landsat 8 False color")
test1 +
mapview(pointsLand2,col.regions = c("blue")) +
mapview(points1, col.regions = c("red"), layer.name = c("largestDrop")) +
mapview(points2, col.regions = c("green"), layer.name = c("relativeDrop")) +
mapview(points3, col.regions = c("yellow"), layer.name = c("slopeDrop")) +
mapview(lines_sf,xcol = "x", ycol = "y")
View(csv1)
View(reshape_csvPoints)
for (n in 1:length(uniqueX)){
#n<-1
# Coordinates of transects
coords <- qdapRegex::ex_between(as.character(geo[n]), ":[", "]}")[[1]]
all_digits <- regmatches(coords, gregexpr("[-[:digit:].]+", coords))[[1]]
begin_coords <- data.frame(lon = as.numeric(all_digits[1]),
lat = as.numeric(all_digits[2]))
end_coords <- data.frame(lon = as.numeric(all_digits[3]),
lat = as.numeric(all_digits[4]))
x <- as.matrix(rbind(begin_coords, end_coords))
# only return observations if patternX >= 0 and if coordinates
test1transect <- subset(csv,csv[,col_of_interest(csv, 'originX$')]== uniqueX[n]
& csv[,col_of_interest(csv, paste( '^', patternX, sep = ''))] >= 0 )
subset <- test1transect[,sort(c(col_of_interest(csv, 'coastDist$'), col_of_interest(csv, 'DATE_ACQUIRED$'),
col_of_interest(csv, 'pos$')))]
# coordiates of points of interest (coastline, offshore boundary etc)
coords <- data.frame(x = as.numeric(test1transect[,col_of_interest(csv, paste( '^', patternX, sep = ''))]),
y = as.numeric(test1transect[,col_of_interest(csv, paste( '^', patternY, sep = ''))]),
DATE_ACQUIRED = as.character(test1transect[,col_of_interest(csv, 'DATE_ACQUIRED$')]),
pos = as.character(test1transect[,col_of_interest(csv, 'pos$')]),
axisDist = as.numeric(test1transect[,col_of_interest(csv, 'axisDist$')]))
allPoints <- rbind(allPoints, coords)
}
reshape_csvPoints <- function(csv, patternX, patternY){
#' @title reshape CSV to points matrix
#' @description Return column number matching name with string pattern
#' @param file csv file
#' @param patternX is the pattern describing column of x-coordinate
#' @param patternY is the pattern describing column of Y-coordinate
# csv <- csv1
# patternX <- 'peakCoordX'
# patternY <- 'peakCoordY'
dates <- col_of_interest(csv, 'DATE_ACQUIRED$')
coastDist <- col_of_interest(csv, 'coastDist$')
# all unique dates
uniqueDates <- unique(csv[,dates]);
# all unique transect (id's)
pos <- unique(csv[, col_of_interest(csv, 'pos$')]);
# grep(paste( '^', patternX, sep = ''), colnames(csv), fixed = F)
uniqueX<- unique(csv[, col_of_interest(csv,'originX$')]);
uniqueY<- unique(csv[, col_of_interest(csv,'originY$')]);
geo<- unique(csv[, col_of_interest(csv, '.geo')]);
# define output matrices
allPoints <- vector('list', length(csv));
for (n in 1:length(uniqueX)){
#n<-1
# Coordinates of transects
coords <- qdapRegex::ex_between(as.character(geo[n]), ":[", "]}")[[1]]
all_digits <- regmatches(coords, gregexpr("[-[:digit:].]+", coords))[[1]]
begin_coords <- data.frame(lon = as.numeric(all_digits[1]),
lat = as.numeric(all_digits[2]))
end_coords <- data.frame(lon = as.numeric(all_digits[3]),
lat = as.numeric(all_digits[4]))
x <- as.matrix(rbind(begin_coords, end_coords))
# only return observations if patternX >= 0 and if coordinates
test1transect <- subset(csv,csv[,col_of_interest(csv, 'originX$')]== uniqueX[n]
& csv[,col_of_interest(csv, paste( '^', patternX, sep = ''))] >= 0 )
subset <- test1transect[,sort(c(col_of_interest(csv, 'coastDist$'), col_of_interest(csv, 'DATE_ACQUIRED$'),
col_of_interest(csv, 'pos$')))]
# coordiates of points of interest (coastline, offshore boundary etc)
coords <- data.frame(x = as.numeric(test1transect[,col_of_interest(csv, paste( '^', patternX, sep = ''))]),
y = as.numeric(test1transect[,col_of_interest(csv, paste( '^', patternY, sep = ''))]),
DATE_ACQUIRED = as.character(test1transect[,col_of_interest(csv, 'DATE_ACQUIRED$')]),
pos = as.character(test1transect[,col_of_interest(csv, 'pos$')]),
axisDist = as.numeric(test1transect[,col_of_interest(csv, 'axisDist$')]))
allPoints <- rbind(allPoints, coords)
}
# make it spatial
SpatialPoints <- SpatialPointsDataFrame(data.frame(allPoints[,'x'], allPoints[,'y'] ),
data = data.frame(DATE_ACQUIRED = allPoints[,'DATE_ACQUIRED'],
pos = allPoints[,'pos'],
axisDist = as.numeric(allPoints[,'axisDist'])),
proj4string=CRS("+proj=longlat +datum=WGS84"))
points_sf <- st_as_sf(SpatialPoints)
return(points_sf)
}
points1<- reshape_csvPoints(csv1, 'peakCoordX', 'peakCoordY')
pointsLand1 <- reshape_csvPoints(csv1, 'coastX', 'coastY')
points2<- reshape_csvPoints(csv2, 'peakCoordX', 'peakCoordY')
pointsLand2 <- reshape_csvPoints(csv2, 'coastX', 'coastY')
points3<- reshape_csvPoints(csv3, 'peakCoordX', 'peakCoordY')
pointsLand3 <- reshape_csvPoints(csv3, 'coastX', 'coastY')
# filter -1?
lines1 <- reshape_csvLines(csv1)
# change format of lines
lines_sf <- st_as_sf(lines1)
reshape_csvPoints <- function(csv, patternX, patternY){
#' @title reshape CSV to points matrix
#' @description Return column number matching name with string pattern
#' @param file csv file
#' @param patternX is the pattern describing column of x-coordinate
#' @param patternY is the pattern describing column of Y-coordinate
# csv <- csv1
# patternX <- 'peakCoordX'
# patternY <- 'peakCoordY'
dates <- col_of_interest(csv, 'DATE_ACQUIRED$')
coastDist <- col_of_interest(csv, 'coastDist$')
# all unique dates
uniqueDates <- unique(csv[,dates]);
# all unique transect (id's)
pos <- unique(csv[, col_of_interest(csv, 'pos$')]);
# grep(paste( '^', patternX, sep = ''), colnames(csv), fixed = F)
uniqueX<- unique(csv[, col_of_interest(csv,'originX$')]);
uniqueY<- unique(csv[, col_of_interest(csv,'originY$')]);
geo<- unique(csv[, col_of_interest(csv, '.geo')]);
# define output matrices
allPoints <- vector('list', length(csv));
for (n in 1:length(uniqueX)){
#n<-1
# Coordinates of transects
coords <- qdapRegex::ex_between(as.character(geo[n]), ":[", "]}")[[1]]
all_digits <- regmatches(coords, gregexpr("[-[:digit:].]+", coords))[[1]]
begin_coords <- data.frame(lon = as.numeric(all_digits[1]),
lat = as.numeric(all_digits[2]))
end_coords <- data.frame(lon = as.numeric(all_digits[3]),
lat = as.numeric(all_digits[4]))
x <- as.matrix(rbind(begin_coords, end_coords))
# only return observations if patternX >= 0 and if coordinates
test1transect <- subset(csv,csv[,col_of_interest(csv, 'originX$')]== uniqueX[n]
& csv[,col_of_interest(csv, 'coastDist$')] >= 0 )
subset <- test1transect[,sort(c(col_of_interest(csv, 'coastDist$'), col_of_interest(csv, 'DATE_ACQUIRED$'),
col_of_interest(csv, 'pos$')))]
# coordiates of points of interest (coastline, offshore boundary etc)
coords <- data.frame(x = as.numeric(test1transect[,col_of_interest(csv, paste( '^', patternX, sep = ''))]),
y = as.numeric(test1transect[,col_of_interest(csv, paste( '^', patternY, sep = ''))]),
DATE_ACQUIRED = as.character(test1transect[,col_of_interest(csv, 'DATE_ACQUIRED$')]),
pos = as.character(test1transect[,col_of_interest(csv, 'pos$')]),
axisDist = as.numeric(test1transect[,col_of_interest(csv, 'axisDist$')]))
allPoints <- rbind(allPoints, coords)
}
# make it spatial
SpatialPoints <- SpatialPointsDataFrame(data.frame(allPoints[,'x'], allPoints[,'y'] ),
data = data.frame(DATE_ACQUIRED = allPoints[,'DATE_ACQUIRED'],
pos = allPoints[,'pos'],
axisDist = as.numeric(allPoints[,'axisDist'])),
proj4string=CRS("+proj=longlat +datum=WGS84"))
points_sf <- st_as_sf(SpatialPoints)
return(points_sf)
}
points1<- reshape_csvPoints(csv1, 'peakCoordX', 'peakCoordY')
pointsLand1 <- reshape_csvPoints(csv1, 'coastX', 'coastY')
points2<- reshape_csvPoints(csv2, 'peakCoordX', 'peakCoordY')
pointsLand2 <- reshape_csvPoints(csv2, 'coastX', 'coastY')
points3<- reshape_csvPoints(csv3, 'peakCoordX', 'peakCoordY')
pointsLand3 <- reshape_csvPoints(csv3, 'coastX', 'coastY')
for (n in 1:length(uniqueX)){
#n<-1
# Coordinates of transects
coords <- qdapRegex::ex_between(as.character(geo[n]), ":[", "]}")[[1]]
all_digits <- regmatches(coords, gregexpr("[-[:digit:].]+", coords))[[1]]
begin_coords <- data.frame(lon = as.numeric(all_digits[1]),
lat = as.numeric(all_digits[2]))
end_coords <- data.frame(lon = as.numeric(all_digits[3]),
lat = as.numeric(all_digits[4]))
x <- as.matrix(rbind(begin_coords, end_coords))
# only return observations if patternX >= 0 and if coordinates
test1transect <- subset(csv,csv[,col_of_interest(csv, 'originX$')]== uniqueX[n]
& csv[,col_of_interest(csv, paste( '^', patternX, sep = ''))] >= 0 )
subset <- test1transect[,sort(c(col_of_interest(csv, 'coastDist$'), col_of_interest(csv, 'DATE_ACQUIRED$'),
col_of_interest(csv, 'pos$')))]
# coordiates of points of interest (coastline, offshore boundary etc)
coords <- data.frame(x = as.numeric(test1transect[,col_of_interest(csv, paste( '^', patternX, sep = ''))]),
y = as.numeric(test1transect[,col_of_interest(csv, paste( '^', patternY, sep = ''))]),
DATE_ACQUIRED = as.character(test1transect[,col_of_interest(csv, 'DATE_ACQUIRED$')]),
pos = as.character(test1transect[,col_of_interest(csv, 'pos$')]),
axisDist = as.numeric(test1transect[,col_of_interest(csv, 'axisDist$')]))
allPoints <- rbind(allPoints, coords)
}
reshape_csvPoints <- function(csv, patternX, patternY){
#' @title reshape CSV to points matrix
#' @description Return column number matching name with string pattern
#' @param file csv file
#' @param patternX is the pattern describing column of x-coordinate
#' @param patternY is the pattern describing column of Y-coordinate
# csv <- csv1
# patternX <- 'peakCoordX'
# patternY <- 'peakCoordY'
dates <- col_of_interest(csv, 'DATE_ACQUIRED$')
coastDist <- col_of_interest(csv, 'coastDist$')
# all unique dates
uniqueDates <- unique(csv[,dates]);
# all unique transect (id's)
pos <- unique(csv[, col_of_interest(csv, 'pos$')]);
# grep(paste( '^', patternX, sep = ''), colnames(csv), fixed = F)
uniqueX<- unique(csv[, col_of_interest(csv,'originX$')]);
uniqueY<- unique(csv[, col_of_interest(csv,'originY$')]);
geo<- unique(csv[, col_of_interest(csv, '.geo')]);
# define output matrices
allPoints <- vector('list', length(csv));
for (n in 1:length(uniqueX)){
#n<-1
# Coordinates of transects
coords <- qdapRegex::ex_between(as.character(geo[n]), ":[", "]}")[[1]]
all_digits <- regmatches(coords, gregexpr("[-[:digit:].]+", coords))[[1]]
begin_coords <- data.frame(lon = as.numeric(all_digits[1]),
lat = as.numeric(all_digits[2]))
end_coords <- data.frame(lon = as.numeric(all_digits[3]),
lat = as.numeric(all_digits[4]))
x <- as.matrix(rbind(begin_coords, end_coords))
# only return observations if patternX >= 0 and if coordinates
test1transect <- subset(csv,csv[,col_of_interest(csv, 'originX$')]== uniqueX[n]
& csv[,col_of_interest(csv, paste( '^', patternX, sep = ''))] >= 0 )
subset <- test1transect[,sort(c(col_of_interest(csv, 'coastDist$'), col_of_interest(csv, 'DATE_ACQUIRED$'),
col_of_interest(csv, 'pos$')))]
# coordiates of points of interest (coastline, offshore boundary etc)
coords <- data.frame(x = as.numeric(test1transect[,col_of_interest(csv, paste( '^', patternX, sep = ''))]),
y = as.numeric(test1transect[,col_of_interest(csv, paste( '^', patternY, sep = ''))]),
DATE_ACQUIRED = as.character(test1transect[,col_of_interest(csv, 'DATE_ACQUIRED$')]),
pos = as.character(test1transect[,col_of_interest(csv, 'pos$')]),
axisDist = as.numeric(test1transect[,col_of_interest(csv, 'axisDist$')]))
allPoints <- rbind(allPoints, coords)
}
# make it spatial
SpatialPoints <- SpatialPointsDataFrame(data.frame(allPoints[,'x'], allPoints[,'y'] ),
data = data.frame(DATE_ACQUIRED = allPoints[,'DATE_ACQUIRED'],
pos = allPoints[,'pos'],
axisDist = as.numeric(allPoints[,'axisDist'])),
proj4string=CRS("+proj=longlat +datum=WGS84"))
points_sf <- st_as_sf(SpatialPoints)
return(points_sf)
}
points1<- reshape_csvPoints(csv1, 'peakCoordX', 'peakCoordY')
csv <- csv1
patternX <- 'peakCoordX'
patternY <- 'peakCoordY'
dates <- col_of_interest(csv, 'DATE_ACQUIRED$')
coastDist <- col_of_interest(csv, 'coastDist$')
# all unique dates
uniqueDates <- unique(csv[,dates]);
# all unique transect (id's)
pos <- unique(csv[, col_of_interest(csv, 'pos$')]);
uniqueX<- unique(csv[, col_of_interest(csv,'originX$')]);
uniqueY<- unique(csv[, col_of_interest(csv,'originY$')]);
geo<- unique(csv[, col_of_interest(csv, '.geo')]);
# define output matrices
allPoints <- vector('list', length(csv));
for (n in 1:length(uniqueX)){
#n<-1
# Coordinates of transects
coords <- qdapRegex::ex_between(as.character(geo[n]), ":[", "]}")[[1]]
all_digits <- regmatches(coords, gregexpr("[-[:digit:].]+", coords))[[1]]
begin_coords <- data.frame(lon = as.numeric(all_digits[1]),
lat = as.numeric(all_digits[2]))
end_coords <- data.frame(lon = as.numeric(all_digits[3]),
lat = as.numeric(all_digits[4]))
x <- as.matrix(rbind(begin_coords, end_coords))
# only return observations if patternX >= 0 and if coordinates
test1transect <- subset(csv,csv[,col_of_interest(csv, 'originX$')]== uniqueX[n]
& csv[,col_of_interest(csv, paste( '^', patternX, sep = ''))] >= 0 )
subset <- test1transect[,sort(c(col_of_interest(csv, 'coastDist$'), col_of_interest(csv, 'DATE_ACQUIRED$'),
col_of_interest(csv, 'pos$')))]
# coordiates of points of interest (coastline, offshore boundary etc)
coords <- data.frame(x = as.numeric(test1transect[,col_of_interest(csv, paste( '^', patternX, sep = ''))]),
y = as.numeric(test1transect[,col_of_interest(csv, paste( '^', patternY, sep = ''))]),
DATE_ACQUIRED = as.character(test1transect[,col_of_interest(csv, 'DATE_ACQUIRED$')]),
pos = as.character(test1transect[,col_of_interest(csv, 'pos$')]),
axisDist = as.numeric(test1transect[,col_of_interest(csv, 'axisDist$')]))
allPoints <- rbind(allPoints, coords)
}
allPoints <- vector('list', length(csv));
n<-1
# Coordinates of transects
coords <- qdapRegex::ex_between(as.character(geo[n]), ":[", "]}")[[1]]
all_digits <- regmatches(coords, gregexpr("[-[:digit:].]+", coords))[[1]]
begin_coords <- data.frame(lon = as.numeric(all_digits[1]),
lat = as.numeric(all_digits[2]))
end_coords <- data.frame(lon = as.numeric(all_digits[3]),
lat = as.numeric(all_digits[4]))
# only return observations if patternX >= 0 and if coordinates
test1transect <- subset(csv,csv[,col_of_interest(csv, 'originX$')]== uniqueX[n]
& csv[,col_of_interest(csv, paste( '^', patternX, sep = ''))] >= 0 )
test1transect
col_of_interest(csv, paste( '^', patternX, sep = ''))
csv[,col_of_interest(csv, paste( '^', patternX, sep = ''))]
csv[,col_of_interest(csv, paste( '^', patternX, sep = ''))] != -1
# only return observations if patternX >= 0 and if coordinates
test1transect <- subset(csv,csv[,col_of_interest(csv, 'originX$')]== uniqueX[n]
& csv[,col_of_interest(csv, paste( '^', patternX, sep = ''))] != -1 )
test1transect
uniqueX
test1transect <- subset(csv,csv[,col_of_interest(csv, 'originX$')]== uniqueX[n]
& csv[,col_of_interest(csv, paste( '^', patternX, sep = ''))] != -1 )
test1transect
subset <- test1transect[,sort(c(col_of_interest(csv, 'coastDist$'), col_of_interest(csv, 'DATE_ACQUIRED$'),
col_of_interest(csv, 'pos$')))]
subset
# coordiates of points of interest (coastline, offshore boundary etc)
coords <- data.frame(x = as.numeric(test1transect[,col_of_interest(csv, paste( '^', patternX, sep = ''))]),
y = as.numeric(test1transect[,col_of_interest(csv, paste( '^', patternY, sep = ''))]),
DATE_ACQUIRED = as.character(test1transect[,col_of_interest(csv, 'DATE_ACQUIRED$')]),
pos = as.character(test1transect[,col_of_interest(csv, 'pos$')]),
axisDist = as.numeric(test1transect[,col_of_interest(csv, 'axisDist$')]))
coords
allPoints <- rbind(allPoints, coords)
reshape_csvPoints <- function(csv, patternX, patternY){
#' @title reshape CSV to points matrix
#' @description Return column number matching name with string pattern
#' @param file csv file
#' @param patternX is the pattern describing column of x-coordinate
#' @param patternY is the pattern describing column of Y-coordinate
# csv <- csv1
# patternX <- 'peakCoordX'
# patternY <- 'peakCoordY'
dates <- col_of_interest(csv, 'DATE_ACQUIRED$')
coastDist <- col_of_interest(csv, 'coastDist$')
# all unique dates
uniqueDates <- unique(csv[,dates]);
# all unique transect (id's)
pos <- unique(csv[, col_of_interest(csv, 'pos$')]);
# grep(paste( '^', patternX, sep = ''), colnames(csv), fixed = F)
uniqueX<- unique(csv[, col_of_interest(csv,'originX$')]);
uniqueY<- unique(csv[, col_of_interest(csv,'originY$')]);
geo<- unique(csv[, col_of_interest(csv, '.geo')]);
# define output matrices
allPoints <- vector('list', length(csv));
for (n in 1:length(uniqueX)){
#n<-1
# Coordinates of transects
coords <- qdapRegex::ex_between(as.character(geo[n]), ":[", "]}")[[1]]
all_digits <- regmatches(coords, gregexpr("[-[:digit:].]+", coords))[[1]]
begin_coords <- data.frame(lon = as.numeric(all_digits[1]),
lat = as.numeric(all_digits[2]))
end_coords <- data.frame(lon = as.numeric(all_digits[3]),
lat = as.numeric(all_digits[4]))
x <- as.matrix(rbind(begin_coords, end_coords))
# only return observations if patternX >= 0 and if coordinates
test1transect <- subset(csv,csv[,col_of_interest(csv, 'originX$')]== uniqueX[n]
& csv[,col_of_interest(csv, paste( '^', patternX, sep = ''))] != -1 )
subset <- test1transect[,sort(c(col_of_interest(csv, 'coastDist$'), col_of_interest(csv, 'DATE_ACQUIRED$'),
col_of_interest(csv, 'pos$')))]
# coordiates of points of interest (coastline, offshore boundary etc)
coords <- data.frame(x = as.numeric(test1transect[,col_of_interest(csv, paste( '^', patternX, sep = ''))]),
y = as.numeric(test1transect[,col_of_interest(csv, paste( '^', patternY, sep = ''))]),
DATE_ACQUIRED = as.character(test1transect[,col_of_interest(csv, 'DATE_ACQUIRED$')]),
pos = as.character(test1transect[,col_of_interest(csv, 'pos$')]),
axisDist = as.numeric(test1transect[,col_of_interest(csv, 'axisDist$')]))
allPoints <- rbind(allPoints, coords)
}
# make it spatial
SpatialPoints <- SpatialPointsDataFrame(data.frame(allPoints[,'x'], allPoints[,'y'] ),
data = data.frame(DATE_ACQUIRED = allPoints[,'DATE_ACQUIRED'],
pos = allPoints[,'pos'],
axisDist = as.numeric(allPoints[,'axisDist'])),
proj4string=CRS("+proj=longlat +datum=WGS84"))
points_sf <- st_as_sf(SpatialPoints)
return(points_sf)
}
points1<- reshape_csvPoints(csv1, 'peakCoordX', 'peakCoordY')
pointsLand1 <- reshape_csvPoints(csv1, 'coastX', 'coastY')
points2<- reshape_csvPoints(csv2, 'peakCoordX', 'peakCoordY')
pointsLand2 <- reshape_csvPoints(csv2, 'coastX', 'coastY')
points3<- reshape_csvPoints(csv3, 'peakCoordX', 'peakCoordY')
pointsLand3 <- reshape_csvPoints(csv3, 'coastX', 'coastY')
lines1 <- reshape_csvLines(csv1)
# change format of lines
lines_sf <- st_as_sf(lines1)
test1 <- Map$addLayer(image20091115, vizParams, "Landsat 8 False color")
test1 +
mapview(pointsLand2,col.regions = c("blue")) +
mapview(points1, col.regions = c("red"), layer.name = c("largestDrop")) +
mapview(points2, col.regions = c("green"), layer.name = c("relativeDrop")) +
mapview(points3, col.regions = c("yellow"), layer.name = c("slopeDrop")) +
mapview(lines_sf,xcol = "x", ycol = "y")
test1 <- Map$addLayer(image20091115, vizParams, "Landsat 8 False color")
test1
test1 +
mapview(pointsLand2,col.regions = c("blue")) +
mapview(points1, col.regions = c("red"), layer.name = c("largestDrop")) +
mapview(points2, col.regions = c("green"), layer.name = c("relativeDrop")) +
mapview(points3, col.regions = c("yellow"), layer.name = c("slopeDrop")) +
mapview(lines_sf,xcol = "x", ycol = "y")
set1 <- 'Suriname_229_56_2009_till_2009_testImage20090912_largestDrop_20201210'
set2 <- 'Suriname_229_56_2009_till_2009_testImage20090912_relativeDrop_20201210'
set3 <- 'Suriname_229_56_2009_till_2009_testImage20090912_slopeDrop_20201210'
# set1 <- '/Suriname_229_56_2009_till_2009_testImage20090912_extraMask_largestDrop'
# set2 <- 'Suriname_229_56_2009_till_2009_testImage20090912_extraMask_V20201207'
csv1 = as.matrix(read.csv2(as.character(df[grep(set1, folderSelect, ignore.case = T),1]),
header = T, sep = ',', na.strings=c("","NA"))) # rewrite as matrix to read columns as numeric values
csv2 = as.matrix(read.csv2(as.character(df[grep(set2, folderSelect, ignore.case = T),1]),
header = T, sep = ',', na.strings=c("","NA"))) # rewrite as matrix to read columns as numeric values
csv3 = as.matrix(read.csv2(as.character(df[grep(set3, folderSelect, ignore.case = T),1]),
header = T, sep = ',', na.strings=c("","NA"))) # rewrite as matrix to read columns as numeric values
# mydata <- sapply(list.files(paste0(dataFolder, '/GEE_exports/testImages'), full.names = T), read.csv)
points1<- reshape_csvPoints(csv1, 'peakCoordX', 'peakCoordY')
pointsLand1 <- reshape_csvPoints(csv1, 'coastX', 'coastY')
points2<- reshape_csvPoints(csv2, 'peakCoordX', 'peakCoordY')
pointsLand2 <- reshape_csvPoints(csv2, 'coastX', 'coastY')
points3<- reshape_csvPoints(csv3, 'peakCoordX', 'peakCoordY')
pointsLand3 <- reshape_csvPoints(csv3, 'coastX', 'coastY')
# filter -1?
lines1 <- reshape_csvLines(csv1)
# change format of lines
lines_sf <- st_as_sf(lines1)
test1 <- Map$addLayer(image20090912, vizParams, "Landsat 8 False color")
test1 +
mapview(pointsLand2,col.regions = c("blue")) +
mapview(points1, col.regions = c("red"), layer.name = c("largestDrop")) +
mapview(points2, col.regions = c("green"), layer.name = c("relativeDrop")) +
mapview(points3, col.regions = c("yellow"), layer.name = c("slopeDrop")) +
mapview(lines_sf,xcol = "x", ycol = "y")
# largest, relative and slope drop for 20091115 image
set1 <- 'Suriname_229_56_2009_till_2009_testImage20090912_largestDrop_20201210'
# set1 <- '/Suriname_229_56_2009_till_2009_testImage20090912_extraMask_largestDrop'
set2 <- 'Suriname_229_56_2009_till_2009_testImage20090912_extraMask_V20201207'
csv1 = as.matrix(read.csv2(as.character(df[grep(set1, folderSelect, ignore.case = T),1]),
header = T, sep = ',', na.strings=c("","NA"))) # rewrite as matrix to read columns as numeric values
csv2 = as.matrix(read.csv2(as.character(df[grep(set2, folderSelect, ignore.case = T),1]),
header = T, sep = ',', na.strings=c("","NA"))) # rewrite as matrix to read columns as numeric values
csv3 = as.matrix(read.csv2(as.character(df[grep(set3, folderSelect, ignore.case = T),1]),
header = T, sep = ',', na.strings=c("","NA"))) # rewrite as matrix to read columns as numeric values
points1<- reshape_csvPoints(csv1, 'peakCoordX', 'peakCoordY')
pointsLand1 <- reshape_csvPoints(csv1, 'coastX', 'coastY')
points2<- reshape_csvPoints(csv2, 'peakCoordX', 'peakCoordY')
pointsLand2 <- reshape_csvPoints(csv2, 'coastX', 'coastY')
points3<- reshape_csvPoints(csv3, 'peakCoordX', 'peakCoordY')
pointsLand3 <- reshape_csvPoints(csv3, 'coastX', 'coastY')
test1 +
mapview(pointsLand2,col.regions = c("blue")) +
mapview(points1, col.regions = c("red"), layer.name = c("set1")) +
mapview(points2, col.regions = c("green"), layer.name = c("set2")) +
# mapview(points3, col.regions = c("yellow"), layer.name = c("slopeDrop")) +
mapview(lines_sf,xcol = "x", ycol = "y")
View(points2)
View(points1)
# largest, relative and slope drop for 20091115 image
set1 <- 'Suriname_229_56_2009_till_2009_testImage20090912_largestDrop_20201210'
# set2 <- 'Suriname_229_56_2009_till_2009_testImage20090912_relativeDrop_20201210'
# set3 <- 'Suriname_229_56_2009_till_2009_testImage20090912_slopeDrop_20201210'
set3 <- '/Suriname_229_56_2009_till_2009_testImage20090912_extraMask_largestDrop'
set2 <- 'Suriname_229_56_2009_till_2009_testImage20090912_extraMask_V20201207'
csv1 = as.matrix(read.csv2(as.character(df[grep(set1, folderSelect, ignore.case = T),1]),
header = T, sep = ',', na.strings=c("","NA"))) # rewrite as matrix to read columns as numeric values
csv2 = as.matrix(read.csv2(as.character(df[grep(set2, folderSelect, ignore.case = T),1]),
header = T, sep = ',', na.strings=c("","NA"))) # rewrite as matrix to read columns as numeric values
csv3 = as.matrix(read.csv2(as.character(df[grep(set3, folderSelect, ignore.case = T),1]),
header = T, sep = ',', na.strings=c("","NA"))) # rewrite as matrix to read columns as numeric values
.# mydata <- sapply(list.files(paste0(dataFolder, '/GEE_exports/testImages'), full.names = T), read.csv)
points1<- reshape_csvPoints(csv1, 'peakCoordX', 'peakCoordY')
pointsLand1 <- reshape_csvPoints(csv1, 'coastX', 'coastY')
points2<- reshape_csvPoints(csv2, 'peakCoordX', 'peakCoordY')
pointsLand2 <- reshape_csvPoints(csv2, 'coastX', 'coastY')
points3<- reshape_csvPoints(csv3, 'peakCoordX', 'peakCoordY')
pointsLand3 <- reshape_csvPoints(csv3, 'coastX', 'coastY')
lines1 <- reshape_csvLines(csv1)
# change format of lines
lines_sf <- st_as_sf(lines1)
test1 <- Map$addLayer(image20090912, vizParams, "Landsat 8 False color")
test1 +
mapview(pointsLand2,col.regions = c("blue")) +
mapview(points1, col.regions = c("red"), layer.name = c("set1")) +
mapview(points2, col.regions = c("green"), layer.name = c("set2")) +
mapview(points3, col.regions = c("yellow"), layer.name = c("set3")) +
mapview(lines_sf,xcol = "x", ycol = "y")
