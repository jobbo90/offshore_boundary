# i<-five_years[five_years == c("2005-01-01")]
for(q in group_pos){
# pos_to_test <- 	272000
# q <- group_pos[group_pos == 272000]
# print(q)
indexs <- which(mudbanks$five_year_col == i &
mudbanks$pos == q &
mudbanks$coastX > -1)
subsets3 <- mudbanks[indexs, ]
# get nearest observation and add it to the list
# is .na going to throw a problem?
reference_date <- mean(as.Date(subsets3$DATE_ACQUIRED))
# Aamount of obs
obs_3years <- nrow(subsets3)
# update that if subset per year is to small, include extra observations?
# So grow the subset to at least 10(?) obs by adding nearest observations
maxAttemp <- 0 # make sure you don't get stuck in infinite loop..
while(nrow(subsets3) < min_obs_rosner &
# nrow(subsets3)+obs_3years > min_obs_rosner &
maxAttemp < min_obs_rosner+5){
# exclude dates from the year of interest
# sample from entire dataset so that years outside the 3 year block
# are also possible candidates
# pitfall: any date is possible, also the ones to far away
# so set limit at search window of x years?
selectedDates <- subset(mudbanks, mudbanks$pos == q &
mudbanks$coastX > -1 &
!(mudbanks$DATE_ACQUIRED %in%
subsets3$DATE_ACQUIRED)
)$DATE_ACQUIRED
# exclude the ones already selected
# are NA a problem that seems to throw warnings()?
nearestDate <- selectedDates[1:length(selectedDates) ==
which.min(replace(abs(as.Date(selectedDates) - reference_date),
abs(as.Date(selectedDates) - reference_date)>year_limit*356, NA))]
# if nothing is found, break the loop
if(length(nearestDate) == 0){break}
index_nearest <- which(as.Date(as.character(mudbanks$DATE_ACQUIRED)) == nearestDate &
mudbanks$pos == q &
mudbanks$coastX > -1)
# update subsets
subsets3 <- rbind(subsets3, mudbanks[index_nearest, ] )
maxAttemp = maxAttemp + 1
}
# because subsets 3 changed in size, recalc the indices.
subsets3_recal <- which(mudbanks$DATE_ACQUIRED %in% subsets3$DATE_ACQUIRED &
mudbanks$pos == q &
mudbanks$coastX > -1)
# apply rosner test if there is sufficient observations ==> this implies that the timeseries to look at needs to be larger than 3 years.
# also the year limit needs to go up.
# All detected outliers with larger std value recieve outlier == 0
# Only give the rosner output to the original subset3 indices
mudbanks[indexs, 'coast_outlier'] <-
rosner(subsets3$coastDist,min_Std , min_obs_rosner)[which(subsets3_recal %in% indexs)]
# Will throw an error/warning if all values are the same => nothing is assigned as outlier
#
# plot(as.Date(subsets3$DATE_ACQUIRED), subsets3$coastDist,
#     main = paste0(q), xlab = 'date', ylab = 'coastline position')
# points(as.Date(subsets3$DATE_ACQUIRED)[which(rosner(subsets3$coastDist, min_Std, min_obs_rosner) == 0)],
#        subsets3$coastDist[which(rosner(subsets3$coastDist, min_Std, min_obs_rosner) == 0)],
#        col = 'red')
}
end <- Sys.time()
dif<- difftime(end, start, "mins")
print(paste0(as.Date(i) ,' in ', round(dif,1)))
}
#'
#'  calculate slope of coastline change
#'  - Per year
#'  - include nearest observations
#'  -
#'  within predefined search window (4 years difference max)
#'
for(i in group_dates){
start <- Sys.time()
for(q in group_pos){
# i<-group_dates[group_dates == c("1998-01-01")]
#
# pos_to_test <- 	116000
# q <- group_pos[group_pos == pos_to_test]
# print(q)
subsets_annual <- mudbanks[which(mudbanks$year_col == i &
mudbanks$pos == q &
mudbanks$coastDist > -1), ]
# select outliers & non outliers
outliers <- subset(subsets_annual, coast_outlier == 0)
nonOutliers <- subset(subsets_annual, coast_outlier == 1)
# get nearest observation and add it to the list
# if there is nothing there; half way through the year
reference_date <- as.Date(ifelse(nrow(nonOutliers)>0,
mean(as.Date(nonOutliers$DATE_ACQUIRED)),
as.Date(i)+days(180)))
# improvement required!
# slope is only applicable if quality of coastline estimate is
# sufficient (see landsat 7 case with no data in wetland areas)
# if outlier detection is sufficient the slope can be correctly estimated
# if  there is insufficient observations;
# search for additional observations to calculate the slope
# downside; if the observations that are detected are of good quality,
# the slope is wronfully adjusted based on neighbouring observations
# resulting in wrong estimate (often underestimate!) of rate of change.
maxAttemp <- 0
while(nrow(nonOutliers) < 8 &
maxAttemp < min_obs_rosner){
# exclude the ones from the original year
selectDates <- subset(mudbanks, mudbanks$pos == q &
mudbanks$coastDist > -1 & !(mudbanks$DATE_ACQUIRED %in%
nonOutliers$DATE_ACQUIRED))$DATE_ACQUIRED
# get nearest date (excluding dates outside limit)
nearestDate <- selectDates[1:length(selectDates) ==
which.min(replace(abs(as.Date(selectDates) - reference_date),
abs(as.Date(selectDates) - reference_date)>year_limit*356, NA))]
if(length(nearestDate) == 0){break}
index_nearest <- which(as.Date(as.character(mudbanks$DATE_ACQUIRED)) == nearestDate &
mudbanks$pos == q &
mudbanks$coastDist > -1 &
mudbanks$coast_outlier == 1)
# update annual subset
nonOutliers <- rbind(nonOutliers, mudbanks[index_nearest, ] )
maxAttemp = maxAttemp + 1
}
# only fit a line if there is a least 5 valid observations.
if(nrow(nonOutliers) < 5){
m_per_year <- NA
} else {
# calculate linear fit
lm.out <- lm(nonOutliers$coastDist~as.numeric(as.Date(nonOutliers$DATE_ACQUIRED)))
# intercept <-lm.out$coefficients[1]
slope <- round(lm.out$coefficients[2], 5) # change per unit of x (=days)
m_per_year <- slope*365
}
# update all slope values from the original years (incl. coastdist -1 and outliers)
mudbanks$slope[which(mudbanks$year_col == i &
mudbanks$pos == q)] <- as.numeric(m_per_year)
mudbanks$coastObs[which(mudbanks$year_col == i &
mudbanks$pos == q)] <- as.numeric(nrow(nonOutliers))
}
end <- Sys.time()
dif<- difftime(end, start, "mins")
print(paste0(as.Date(i) ,' in ', round(dif,1), ' mins'))
# plot(as.Date(nonOutliers$DATE_ACQUIRED), nonOutliers$coastDist,
#   main = paste0(q), xlab = paste0(i), ylab = 'coastline position',
#   ylim=c(min(nonOutliers$coastDist)-30,max(nonOutliers$coastDist)+30),
#   xlim=c(min(as.Date(nonOutliers$DATE_ACQUIRED)),
#         max(as.Date(nonOutliers$DATE_ACQUIRED))))
# # points(as.Date(outliers$DATE_ACQUIRED), outliers$coastDist, col = 'red')
# abline(lm(nonOutliers$coastDist~as.numeric(as.Date(nonOutliers$DATE_ACQUIRED))),lty = 2)
# text(min(as.Date(subsets3$DATE_ACQUIRED)) + 90,
#      max(subsets3$coastDist) + 25, paste0('slope = ', m_per_year, ' meter'))
}
twoD_pos
#190000
subset2d_for_testPlot <- subset(mudbanks, pos == twoD_pos)
# set initial value
mudbanks$locf <- mudbanks$coastDist
# if coastDist NA or coast observation is an outlier;
indices <- unique(which(is.na(mudbanks$coastDist) | mudbanks$coast_outlier == 0))
indices
for(ind in indices){
# ind<-indices[1200]
data_entry <- mudbanks[ind, ]
# select all accepted observations from the same transect
pos_subset <- subset(mudbanks, mudbanks$pos == data_entry$pos &
mudbanks$coast_outlier == 1 &
!is.na(mudbanks$coastDist))
# plot(pos_subset$DATE_ACQUIRED, pos_subset$locf)
# plot(pos_subset$DATE_ACQUIRED, pos_subset$coastDist, col = 'red')
if(nrow(pos_subset) > 0){ # if no observations; locf remains original observation (=NA)
# calculate date difference
dateDiff <- abs(as.Date(pos_subset$DATE_ACQUIRED) - as.Date(data_entry$DATE_ACQUIRED))
# find nearest date
dateDiff[dateDiff==0] <- max(dateDiff) # exclude the date of interest (dateDiff = 0)
minInd <- which.min(dateDiff)
nearest <- pos_subset[minInd,]
# fill locf in original data frame
mudbanks[row.names(mudbanks) == row.names(data_entry), 'locf'] <-
nearest$coastDist
}
}
# order by pos
mudbanks<-mudbanks[order(mudbanks$pos),]
# calculate median coastal position
# grouped by pos, year and outlier
mudbanks <- mudbanks %>%
dplyr::group_by(pos, year_col, coast_outlier) %>%
dplyr::mutate(coast_median = median(coastDist, na.rm = T))
# set outlier groups to NA
# this is now prefered over filling NA with nearest values.
mudbanks$coast_median[mudbanks$coast_outlier == 0] <- NA
# key to indicate groups of years~pos
mudbanks$key <- with(rle(as.numeric(mudbanks$year_col)), rep(seq_along(lengths), lengths))
# # fill outliers (NA) with median coastal observation of that year
mudbanks <- mudbanks %>%
group_by(key) %>% # group by position & year
mutate(coast_median = Mode(coast_median)) %>%
ungroup() # remove group
mudbanks <- mudbanks %>%
group_by(pos) %>%           # group_by performs calculation per group
# arrange(pos) %>%              # for each pos calculate the difference compared to previous median observation
# calculate for each position the difference with previous
mutate(deltaCoast = coast_median - lag(coast_median)) %>%
mutate(deltaCoast = replace_na(deltaCoast, 0)) %>%        # NA corresponds to first obs at each transect, set it to 0
# make sure within each group the difference are all assigned the same value (max)
group_by(key) %>%
mutate(deltaCoast = ifelse(sign(deltaCoast[which.max(abs(deltaCoast))]) == 1,
max((deltaCoast), na.rm = F),
min((deltaCoast), na.rm = F))) %>%
ungroup()
#
# # test simple 2d plot
twoD_pos <- 95000
#190000
subset2d_for_testPlot <- subset(mudbanks, pos == twoD_pos)
subset2d_for_testPlot2 <- subset(allFiles, pos == twoD_pos)
plot(as.Date(subset2d_for_testPlot$DATE_ACQUIRED), subset2d_for_testPlot$coastDist,
xlab="DATE_ACQUIRED", ylab="coastDist [m]",
main = paste0('coastline position: ',twoD_pos, ' [m]'), pch = 20)
lines(unique(as.Date(subset2d_for_testPlot$year_col))+180,
aggregate(subset2d_for_testPlot$coast_median, list(subset2d_for_testPlot$key), median)$x,
col = 'black', lty = 2)
points(as.Date(subset2d_for_testPlot[subset2d_for_testPlot$coast_outlier == 0, ]$DATE_ACQUIRED),
subset2d_for_testPlot[subset2d_for_testPlot$coast_outlier == 0, ]$coastDist,
col = 'red',  pch = 20)
points(as.Date(subset2d_for_testPlot[subset2d_for_testPlot$axisDist == -1, ]$DATE_ACQUIRED),
subset2d_for_testPlot[subset2d_for_testPlot$axisDist == -1, ]$locf, col = 'blue')
legend("right", legend=c("Observations", "median values", 'outliers', 'locf'),
col=c("black", "black", 'red', 'blue'), pch = c(20,NA,20,20) ,lty = c(0,2,0,0), cex=0.8)
coast_spatial <- sp_pnt_ee(subset2d_for_testPlot$coastX,
subset2d_for_testPlot$coastY, paste0('pos: ',twoD_pos),
"#d95f0e")
filtCollect <- collection$filterDate(as.character(as.Date(min(subset2d_for_testPlot$DATE_ACQUIRED))-1),
as.character(as.Date(max(subset2d_for_testPlot$DATE_ACQUIRED))+1))$
sort("CLOUDCOVER", TRUE)
dates <- ee_get_date_ic(filtCollect, time_end = FALSE)
Map$centerObject(filtCollect$first())
first <- Map$addLayer(filtCollect$first(), vizParams, paste0('landsat: ',i))
first + coast_spatial
# mudbank Distance
mudbanks$mudbank_distance <- mudbanks$axisDist - mudbanks$coast_median
#190000
subset2d_for_testPlot <- subset(mudbanks, pos == twoD_pos)
# mudbank Distance Abs Drop
mudbanks$mudbank_distance_abs <- mudbanks$axisDistAbs - mudbanks$coast_median
# some examples
mudbanks_select <-subset(mudbanks, mudbanks$DATE_ACQUIRED == uniqueDates[2] &
mudbanks$axisDist >= 0 &
mudbanks$mudbank_distance >= 0)
# set outlier: assume nothing is an outlier
mudbanks$mudbank_outlier <- 0
# calculate slope
mudbanks$SmoothedSlopes <- (mudbanks$SmoothedPeakFract - mudbanks$maxExtentIndex) /
(mudbanks$SmoothedPeak -  mudbanks$maxExtent) * 10000
i <- uniqueDates[11]
i
filtCollect <- collection$filterDate(as.character(as.Date(i)-1),
as.character(as.Date(i)+1))
dates <- ee_get_date_ic(filtCollect, time_end = FALSE)
Map$centerObject(filtCollect$first())
first <- Map$addLayer(filtCollect$first(), vizParams, paste0('landsat: ',i))
# select relevant observations
mudbanks_selection <-subset(mudbanks, mudbanks$DATE_ACQUIRED == i &
mudbanks$axisDist >= 0 &
!(pos %in% posToExclude) &
mudbanks$mudbank_distance >= 0)
mudbanks[which(mudbanks$DATE_ACQUIRED == i &
mudbanks$axisDist < 0 &
mudbanks$mudbank_distance < 0), "mudbank_outlier"] <-
as.data.frame(mudbanks[
which(mudbanks$DATE_ACQUIRED == i &
mudbanks$axisDist < 0 &
mudbanks$mudbank_distance < 0),"mudbank_outlier"])[,1] + 1
# order by position
mudbanks_selection<-mudbanks_selection[order(mudbanks_selection$pos),]
positions_all <- as.numeric(as.character(mudbanks_selection$pos))
distances_all <-mudbanks_selection$mudbank_distance # grab the normalized distances
# abs distance
distance_all_abs <- mudbanks_selection$mudbank_distance_abs
# second order polynomial fit: alongshore position & polynomial fit
lm_out_all <-lm(distances_all ~ poly(as.numeric(positions_all),2))
predicted.intervals <- predict(lm_out_all,
data.frame(x=as.numeric(positions_all)),
interval='confidence', level=0.99)
# Bonferroni-adjusted mudbank_outlier test (test largest absolute standardized residual)
outlier_test <- car::outlierTest(lm_out_all)
outlier_ind<-as.numeric(names(outlier_test$rstudent))
outlier_ind
# Give mudbank_outlier +1 in the source file to keep track
mudbanks[which(mudbanks$DATE_ACQUIRED == i &
mudbanks$pos %in% positions_all[outlier_ind]), "mudbank_outlier"] <-
as.data.frame(mudbanks[
which(mudbanks$DATE_ACQUIRED == i &
mudbanks$pos %in% positions_all[outlier_ind]),"mudbank_outlier"])[,1] + 1
outlier_selection <- mudbanks_selection[outlier_ind,]
# drop the most obvious outliers from the selection
mudbanks_selection <- mudbanks_selection[-outlier_ind, ]
slopes <- mudbanks_selection$SmoothedSlopes
hist(slopes,  xlim=c(floor(min(slopes)), ceiling(max(slopes))),
breaks =c(seq(floor(min(slopes)),ceiling(max(slopes)),0.01)))
# Value should be in the range of -0.15 and 0 ==> not sure yet if using median is the best way
median_slope <- median(slopes)
indicesSlopes <- which(slopes > -0.15) # indices of the subset
pos_slopes <- sp_pnt_ee(mudbanks_selection[indicesSlopes, ]$axisDistAbsX, # &  mudbanks_selection$SmoothedPeak > 0
mudbanks_selection[indicesSlopes, ]$axisDistAbsY,
'positive_slopes',
"#3182bd")
indicesSlopes
mudbanks_selection[indicesSlopes, ]$axisDistAbsX
# translate other distances into coordinates
mudbanks <- get_dists2(mudbanks, mudbanks$originX, mudbanks$originY,
mudbanks$bearing,
c('axisDistAbs', 'axisDistSlope', 'maxExtent'))
mudbanks$ax
# calculate slope of the super smoothed line
# indication of no_mudbank scenario per transect
mudbanks$SmoothedSlopes <- (mudbanks$SmoothedPeakFract - mudbanks$maxExtentIndex) /
(mudbanks$SmoothedPeak -  mudbanks$maxExtent) * 10000
i <- uniqueDates[11]
filtCollect <- collection$filterDate(as.character(as.Date(i)-1),
as.character(as.Date(i)+1))
dates <- ee_get_date_ic(filtCollect, time_end = FALSE)
Map$centerObject(filtCollect$first())
first <- Map$addLayer(filtCollect$first(), vizParams, paste0('landsat: ',i))
# select relevant observations
mudbanks_selection <-subset(mudbanks, mudbanks$DATE_ACQUIRED == i &
mudbanks$axisDist >= 0 &
!(pos %in% posToExclude) &
mudbanks$mudbank_distance >= 0)
mudbanks[which(mudbanks$DATE_ACQUIRED == i &
mudbanks$axisDist < 0 &
mudbanks$mudbank_distance < 0), "mudbank_outlier"] <-
as.data.frame(mudbanks[
which(mudbanks$DATE_ACQUIRED == i &
mudbanks$axisDist < 0 &
mudbanks$mudbank_distance < 0),"mudbank_outlier"])[,1] + 1
# order by position
mudbanks_selection<-mudbanks_selection[order(mudbanks_selection$pos),]
positions_all <- as.numeric(as.character(mudbanks_selection$pos))
distances_all <-mudbanks_selection$mudbank_distance # grab the normalized distances
# abs distance
distance_all_abs <- mudbanks_selection$mudbank_distance_abs
# second order polynomial fit: alongshore position & polynomial fit
lm_out_all <-lm(distances_all ~ poly(as.numeric(positions_all),2))
predicted.intervals <- predict(lm_out_all,
data.frame(x=as.numeric(positions_all)),
interval='confidence', level=0.99)
# Bonferroni-adjusted mudbank_outlier test (test largest absolute standardized residual)
outlier_test <- car::outlierTest(lm_out_all)
outlier_ind<-as.numeric(names(outlier_test$rstudent))
# Give mudbank_outlier +1 in the source file to keep track
mudbanks[which(mudbanks$DATE_ACQUIRED == i &
mudbanks$pos %in% positions_all[outlier_ind]), "mudbank_outlier"] <-
as.data.frame(mudbanks[
which(mudbanks$DATE_ACQUIRED == i &
mudbanks$pos %in% positions_all[outlier_ind]),"mudbank_outlier"])[,1] + 1
outlier_selection <- mudbanks_selection[outlier_ind,]
# drop the most obvious outliers from the selection
mudbanks_selection <- mudbanks_selection[-outlier_ind, ]
slopes <- mudbanks_selection$SmoothedSlopes
hist(slopes,  xlim=c(floor(min(slopes)), ceiling(max(slopes))),
breaks =c(seq(floor(min(slopes)),ceiling(max(slopes)),0.01)))
# Value should be in the range of -0.15 and 0 ==> not sure yet if using median is the best way
median_slope <- median(slopes)
indicesSlopes <- which(slopes > -0.15) # indices of the subset
pos_slopes <- sp_pnt_ee(mudbanks_selection[indicesSlopes, ]$axisDistAbsX, # &  mudbanks_selection$SmoothedPeak > 0
mudbanks_selection[indicesSlopes, ]$axisDistAbsY,
'positive_slopes',
"#3182bd")
# Give mudbank_outlier +1 in the source file to keep track
mudbanks[which(mudbanks$DATE_ACQUIRED == i &
mudbanks$pos %in% positions_all[indicesSlopes]), "mudbank_outlier"] <-
as.data.frame(mudbanks[
which(mudbanks$DATE_ACQUIRED == i &
mudbanks$pos %in% positions_all[indicesSlopes]),"mudbank_outlier"])[,1] + 1
threshold <- median(mudbanks_selection$SmoothedPeakFract) - sd(mudbanks_selection$SmoothedPeakFract)
# lowPeakFractsSmoothed<- mudbanks_selection[which(mudbanks_selection$SmoothedPeakFract < 0.1),]
# highPeakDist <- mudbanks_selection[which(mudbanks_selection$SmoothedPeak > 7500), ]
lowPeakOutlier <-  which(mudbanks_selection$SmoothedPeakFract < threshold) #& mudbanks_selection$SmoothedPeakFract > 0
noMudBankTest <- mudbanks_selection[lowPeakOutlier , ] # 0 is an artefact of GEE export in the super smoothed peaks?
noBankSp <- sp_pnt_ee(noMudBankTest$x,
noMudBankTest$y,
'noBankSp_rel',
"#e0f3db")
# again update mudbank Selection
mudbanks_selection <- mudbanks_selection[-unique(c(indicesSlopes,lowPeakOutlier)), ]
# Make distances compatible (get x,y) with rgee for plotting
SpatialPointsAbs <- sp_pnt_ee(mudbanks_selection$axisDistAbsX,
mudbanks_selection$axisDistAbsY, 'abs_drop',
"FF0000")
SpatialPointsSlope<- sp_pnt_ee(mudbanks_selection$axisDistSlopeX,
mudbanks_selection$axisDistSlopeY, 'slope_drop',
"#31a354")
SpatialPointsRel <- sp_pnt_ee(mudbanks_selection$x,
mudbanks_selection$y, 'rel_drop',
"#d95f0e")
first + SpatialPointsRel + SpatialPointsAbs + SpatialPointsSlope + pos_slopes + noBankSp
# contrasting fractions for abs drop / re drop
contrastingFractAbs <- mudbanks_selection[which(mudbanks_selection$mudFractAbs > 0.4 &
mudbanks_selection$mudFract < 0.6 &
mudbanks_selection$mudFract != mudbanks_selection$mudFractAbs), ]
# contrasting distances for abs drop / rel drop
# shows nicely which RELATIVE distances are wrong! (if tresholds can be finetuned)
# Allthough this throuws ouy far awway points +=> methodology already has a bias on nearshore observations being detected
# ncie thing about relative drops are that they are in general further away
axisDist_boundary <- median(mudbanks_selection$axisDist) + sd(mudbanks_selection$axisDist)
axisDist_boundary_abs <- median(mudbanks_selection$axisDistAbs) - sd(mudbanks_selection$axisDistAbs)
contrastingDist <- mudbanks_selection[which(mudbanks_selection$axisDist > axisDist_boundary &
# mudbanks_selection$axisDistAbs < 14000 &
mudbanks_selection$axisDist != mudbanks_selection$axisDistAbs), ]
contrastingDist_abs <- mudbanks_selection[which(mudbanks_selection$axisDistAbs < axisDist_boundary_abs &
# mudbanks_selection$axisDistAbs < 14000 &
mudbanks_selection$axisDist != mudbanks_selection$axisDistAbs), ]
plot(mudbanks_selection$axisDist,
mudbanks_selection$axisDistAbs)
points(contrastingDist$axisDist,
contrastingDist$axisDistAbs,
col = 'red')
abline(v=as.numeric(axisDist_boundary))
contrastingD <- sp_pnt_ee(contrastingDist$x,
contrastingDist$y,
'contrasting_dist_abs_rel',
"#e0f3db")
for (pnt in 1:nrow(mudbanks_selection)){
# pos_of_interst <- 224000 #81000
# selected_point <-mudbanks_selection[which(mudbanks_selection$pos == pos_of_interst),]
# pnt <- 55
selected_point <-mudbanks_selection[pnt,]
# plot all info per point available
plot(c(selected_point$axisDist, selected_point$axisDistAbs, selected_point$axisDistSlope),
c(selected_point$mudFract, selected_point$mudFractAbs, selected_point$mudFractSlope),
main = paste0(selected_point$pos), xlab = 'distance', ylab = 'fraction',
ylim=c(0, 1),
xlim=c(0,selected_point$maxExtent + 1000))
points(selected_point$SmoothedPeak, selected_point$SmoothedPeakFract, col = 'green' )
points(selected_point$maxExtent, selected_point$maxExtentIndex, col = 'red')
abline(selected_point$meanMud, 0)
abline(v=as.numeric(selected_point$coastDist))
# temp <- subset(mudbanks_selection, )
# row.names(mudbanks_selection[pnt,])
# select nearby points
ajoining_points <- subset(mudbanks_selection,
as.character(pos) <=  as.numeric(as.character(selected_point$pos))+4000 &
as.character(pos) >= as.numeric(as.character(selected_point$pos))-4000 &
as.character(pos) != as.numeric(as.character(selected_point$pos)))
combined <- rbind(selected_point,ajoining_points)
# order by position
combined_ordered <-combined[order(as.numeric(as.character(combined$pos))),]
positions<- as.numeric(as.character(combined_ordered$pos))
distances <-combined_ordered$mudbank_distance # grap the normalized distances
fractions <- combined_ordered$mudFract
datatest <- data.frame(positions=positions,distances=distances, fractions = fractions)
# plot(positions,fractions, col ='red')
# abline(lm(datatest$fractions~as.numeric(datatest$positions)),lty = 2)
# plot(fractions, distances, col = 'blue')
# abline(lm(datatest$distances~as.numeric(datatest$fractions)),lty = 2)
# sufficient observations: determine outliers
if (length(unique(datatest$distances)) > 2) {
# # calculate linear fit
lm.out_lin <- lm(datatest$distances~as.numeric(datatest$positions))
# calculate second order polynomial
lm.out<-lm(datatest$distances ~ poly(as.numeric(datatest$positions),2))
r2 <- summary(lm.out)$r.squared # or adjusted r2?
p <- summary(lm.out)                # should be <0.05?
fstat <- summary(lm.out)$fstatistic #
# or B-splines?
# splines <- lm(datatest$distances ~ bs(as.numeric(datatest$positions), df = 10))
pred.int <- predict(lm.out,data.frame(x=positions),
interval='confidence',level=0.99)
# # plot
# plot(positions, distances)
# abline(lm(datatest$distances~as.numeric(datatest$positions)),lty = 2)
# plot(fitted(lm.out),residuals(lm.out))
# lines(positions, pred.int[,1],col='green',lwd=3)
intercept <-lm.out$coefficients[1]
slope <- lm.out$coefficients[2]
# potential benefit: slope says something about direction; negative slope; front of mudbank
# low pos > further east, decreasing mudbank_distance ==> front of mud bank.
# only in case of mudbank
# residuals
resid <- lm.out$residuals
maxResid <- which.max(abs(resid))
# Bonferroni-adjusted outlier test (test largest absolute standardized residual)
# or linear fit test
test2 <- has_error(car::outlierTest(lm.out), silent = !interactive())
test3 <- has_warning(car::outlierTest(lm.out))
# Allways returns a observation (with largest Studentized residual)
# Which implies it is not allways meeting the P < 0.05 cutoff value
outlier_test <- if(test2|test3){car::outlierTest(lm.out_lin)} else{car::outlierTest(lm.out)}
# if no outliers detected:
# allways returns one point to ensure continuation of worklfow
# point with a Pos outside the range is selected
outlierIndex <- ifelse(length(outlier_test$rstudent) > 0,
as.numeric(as.character(combined_ordered[as.numeric(names(outlier_test$rstudent)),]$pos)),
min(as.numeric(as.character(mudbanks_selection$pos)))-1000)
# drop outlier ==> not sure if necessary
# might be necessary if re-run this script for second sweep
# new_dataTest <- datatest[-outlierIndex,]
} else {
# if only 0 or 1 observation; cannot determine if outlier based on neighbours
# to continue workflow return an index outside the selected range
outlierIndex <- min(as.numeric(as.character(mudbanks_selection$pos)))-1000
}
# test the selected position index of the outlier
# if it is selected point of interest; consider it as outlier
if (outlierIndex == as.numeric(as.character(selected_point$pos))){
mudbanks[which(mudbanks$DATE_ACQUIRED == selected_point$DATE_ACQUIRED &
mudbanks$pos == selected_point$pos), "mudbank_outlier"] <-
# mudbanks[which(row.names(mudbanks) == row.names(selected_point)), "mudbank_outlier"] <-
as.data.frame(mudbanks[
which(mudbanks$DATE_ACQUIRED == selected_point$DATE_ACQUIRED &
mudbanks$pos == selected_point$pos) ,"mudbank_outlier"])[,1] + 1
}
}
