df <- SpatialLinesDataFrame(AllLines,data.frame(df_coastDist))
# change format of lines
lines_sf <- st_as_sf(df)
points_sf <- st_as_sf(points)
mapview(lines_sf,xcol = "x", ycol = "y", popup = popupTable(lines_sf)) + mapview(points_sf)
SpatialOffShore <- SpatialPointsDataFrame(data.frame(offShorePoints[,'x'], offShorePoints[,'y'] ),
data = data.frame(offShorePoints[,'pos']),
proj4string=CRS("+proj=longlat +datum=WGS84"))
# off-shore points for selected images
for (q in 1:length(uniqueDates)){
q <- 6
# select all rows that have an acquisition date
date <- uniqueDates[q]
csv_subset <- subset(csv,csv[,col_of_interest(csv, 'DATE_ACQUIRED$')]== date)
coordsOffShore <- data.frame(x = as.numeric(csv_subset[,col_of_interest(csv_subset, 'peakCoordX$')]),
y = as.numeric(csv_subset[,col_of_interest(csv_subset, 'peakCoordY$')]),
pos = as.numeric(csv_subset[,col_of_interest(csv_subset, 'pos$')]))
offShorePoints <- rbind(offShorePoints, coordsOffShore)
}
offShorePoints <- vector('list', length(csv))
# off-shore points for selected images
for (q in 1:length(uniqueDates)){
q <- 6
# select all rows that have an acquisition date
date <- uniqueDates[q]
csv_subset <- subset(csv,csv[,col_of_interest(csv, 'DATE_ACQUIRED$')]== date)
coordsOffShore <- data.frame(x = as.numeric(csv_subset[,col_of_interest(csv_subset, 'peakCoordX$')]),
y = as.numeric(csv_subset[,col_of_interest(csv_subset, 'peakCoordY$')]),
pos = as.numeric(csv_subset[,col_of_interest(csv_subset, 'pos$')]))
offShorePoints <- rbind(offShorePoints, coordsOffShore)
}
mapviewOptions(basemaps = c( "Esri.WorldImagery","Esri.WorldShadedRelief", "OpenStreetMap.DE")) .
mapviewOptions(basemaps = c( "Esri.WorldImagery","Esri.WorldShadedRelief", "OpenStreetMap.DE"))
s
offShorePoints <- vector('list', length(csv))
# off-shore points for selected images
for (q in 1:length(uniqueDates)){
q <- 6
# select all rows that have an acquisition date
date <- uniqueDates[q]
csv_subset <- subset(csv,csv[,col_of_interest(csv, 'DATE_ACQUIRED$')]== date)
coordsOffShore <- data.frame(x = as.numeric(csv_subset[,col_of_interest(csv_subset, 'peakCoordX$')]),
y = as.numeric(csv_subset[,col_of_interest(csv_subset, 'peakCoordY$')]),
pos = as.numeric(csv_subset[,col_of_interest(csv_subset, 'pos$')]))
offShorePoints <- rbind(offShorePoints, coordsOffShore)
}
SpatialOffShore <- SpatialPointsDataFrame(data.frame(offShorePoints[,'x'], offShorePoints[,'y'] ),
data = data.frame(offShorePoints[,'pos']),
proj4string=CRS("+proj=longlat +datum=WGS84"))
mapview(SpatialOffShore,xcol = "x", ycol = "y", crs = 4326) + lines_sf
offShorePoints <- vector('list', length(csv))
# off-shore points for selected images
for (q in 1:length(uniqueDates)){
q <- 6
# select all rows that have an acquisition date
date <- uniqueDates[q]
csv_subset <- subset(csv,csv[,col_of_interest(csv, 'DATE_ACQUIRED$')]== date)
coordsOffShore <- data.frame(x = as.numeric(csv_subset[,col_of_interest(csv_subset, 'peakCoordX$')]),
y = as.numeric(csv_subset[,col_of_interest(csv_subset, 'peakCoordY$')]),
pos = as.numeric(csv_subset[,col_of_interest(csv_subset, 'pos$')]),
date = as.character(date))
offShorePoints <- rbind(offShorePoints, coordsOffShore)
}
SpatialOffShore <- SpatialPointsDataFrame(data.frame(offShorePoints[,'x'], offShorePoints[,'y'] ),
data = data.frame(offShorePoints[,'pos', 'date']),
proj4string=CRS("+proj=longlat +datum=WGS84"))
SpatialOffShore <- SpatialPointsDataFrame(data.frame(offShorePoints[,'x'], offShorePoints[,'y'] ),
data = data.frame(offShorePoints[,'pos'], offShorePoints[,'date']),
proj4string=CRS("+proj=longlat +datum=WGS84"))
mapview(SpatialOffShore,xcol = "x", ycol = "y", popup = popupGraph(date)) + lines_sf
date
offShorePoints <- vector('list', length(csv))
# off-shore points for selected images
for (q in 1:length(uniqueDates)){
q <- 6
# select all rows that have an acquisition date
date <- uniqueDates[q]
csv_subset <- subset(csv,csv[,col_of_interest(csv, 'DATE_ACQUIRED$')]== date)
coordsOffShore <- data.frame(x = as.numeric(csv_subset[,col_of_interest(csv_subset, 'peakCoordX$')]),
y = as.numeric(csv_subset[,col_of_interest(csv_subset, 'peakCoordY$')]),
pos = as.numeric(csv_subset[,col_of_interest(csv_subset, 'pos$')]),
DATE_ACQUIRED = as.character(date))
offShorePoints <- rbind(offShorePoints, coordsOffShore)
}
SpatialOffShore <- SpatialPointsDataFrame(data.frame(offShorePoints[,'x'], offShorePoints[,'y'] ),
data = data.frame(offShorePoints[,'pos'], offShorePoints[,'DATE_ACQUIRED']),
proj4string=CRS("+proj=longlat +datum=WGS84"))
mapview(SpatialOffShore,xcol = "x", ycol = "y", popup = popupGraph(DATE_ACQUIRED)) + lines_sf
mapview(lines_sf,xcol = "x", ycol = "y",zcol = "DATE_ACQUIRED") + mapview(points_sf)
mapview(lines_sf,xcol = "x", ycol = "y") + mapview(points_sf, zcol ="zcol = "DATE_ACQUIRED"")
mapview(lines_sf,xcol = "x", ycol = "y") + mapview(points_sf, zcol = "DATE_ACQUIRED")
points
points$allPoints....date..
colnames(points)
points@data
colnames(points@data)
colnames(points@data)
colnames(points@data) <- c("DATE_ACQUIRED")
points <- SpatialPointsDataFrame(data.frame(allPoints[,'x'], allPoints[,'y'] ),
data = data.frame(allPoints[,'DATE_ACQUIRED']),
proj4string=CRS("+proj=longlat +datum=WGS84"))
points <- SpatialPointsDataFrame(data.frame(allPoints[,'x'], allPoints[,'y'] ),
data = data.frame(allPoints[,'DATE_ACQUIRED']),
proj4string=CRS("+proj=longlat +datum=WGS84"))
data.frame(allPoints[,'DATE_ACQUIRED'])
}
for (n in 1:length(uniqueX)){
#n<-102
# Coordinates of transects
coords <- qdapRegex::ex_between(as.character(geo[n]), ":[", "]}")[[1]]
all_digits <- regmatches(coords, gregexpr("[-[:digit:].]+", coords))[[1]]
begin_coords <- data.frame(lon = as.numeric(all_digits[1]),
lat = as.numeric(all_digits[2]))
end_coords <- data.frame(lon = as.numeric(all_digits[3]),
lat = as.numeric(all_digits[4]))
x <- as.matrix(rbind(begin_coords, end_coords))
lines[[n]] <- Lines(list(Line(x)), ID = n)  # create line feature
# only return observations if coastDist >= 0 and if coordinates
test1transect <- subset(csv,csv[,col_of_interest(csv, 'originX$')]== uniqueX[n]
& csv[,col_of_interest(csv, 'coastDist$')] >= 0 )
subset <- test1transect[,sort(c(col_of_interest(csv, 'coastDist$'), col_of_interest(csv, 'DATE_ACQUIRED$')))]
if(is.null(nrow(subset))){
df_coastDist[n,] <- rep(NA, length(uniqueDates))
} else {
mathcingDates <- match(colnames(df_coastDist), subset[ ,col_of_interest(subset, 'DATE_ACQUIRED')])
df_coastDist[n,mathcingDates[!is.na(c(mathcingDates))]] <- subset[,col_of_interest(subset, 'coastDist$')]
}
#
#
# coordiates of coastline points
coords <- data.frame(x = as.numeric(test1transect[,col_of_interest(csv, 'coastX$')]),
y = as.numeric(test1transect[,col_of_interest(csv, 'coastY$')]),
DATE_ACQUIRED = as.character(test1transect[,col_of_interest(csv, 'DATE_ACQUIRED$')]))
allPoints <- rbind(allPoints, coords)
}
rm(list = ls())
#' set working directory for Mac and PC
wd<-getwd()
options(scipen = 6, digits = 4) # I prefer to view outputs in non-scientific notation
memory.limit(30000000)     # this is needed on some PCs to increase memory allowance, but has no impact on macs.
mapviewOptions(basemaps = c( "Esri.WorldImagery","Esri.WorldShadedRelief", "OpenStreetMap.DE"))
#' load up the packages
source("./src/packages.R")       # loads up all the packages we need
## ---------------------------
source("./src/functions.R")
dataFolder <- './data/raw'
# select folders
folderSelect <- as.matrix(list.files(paste0(dataFolder, '/GEE_exports'), full.names = T))
df <- rewrite(folderSelect);
csv = as.matrix(read.csv2(as.character(df[2,1]),
header = T, sep = ',', na.strings=c("","NA"))) # rewrite as matrix to read columns as numeric values
dates <- col_of_interest(csv, 'DATE_ACQUIRED$')
coastDist <- col_of_interest(csv, 'coastDist$')
# all unique dates
uniqueDates <- unique(csv[,dates]);
# all unique transect (id's)
pos <- unique(csv[, col_of_interest(csv, 'pos$')]);
uniqueX<- unique(csv[, col_of_interest(csv, 'originX$')]);
uniqueY<- unique(csv[, col_of_interest(csv, 'originY$')]);
geo<- unique(csv[, col_of_interest(csv, '.geo')]);
# define output matrices
lines <- vector('list', length(uniqueX));
allPoints <- vector('list', length(csv));
df_coastDist = data.frame(matrix(NA, length(uniqueX), length(uniqueDates)),
stringsAsFactors=F)
colnames(df_coastDist) <- c(uniqueDates)
for (n in 1:length(uniqueX)){
#n<-102
# Coordinates of transects
coords <- qdapRegex::ex_between(as.character(geo[n]), ":[", "]}")[[1]]
all_digits <- regmatches(coords, gregexpr("[-[:digit:].]+", coords))[[1]]
begin_coords <- data.frame(lon = as.numeric(all_digits[1]),
lat = as.numeric(all_digits[2]))
end_coords <- data.frame(lon = as.numeric(all_digits[3]),
lat = as.numeric(all_digits[4]))
x <- as.matrix(rbind(begin_coords, end_coords))
lines[[n]] <- Lines(list(Line(x)), ID = n)  # create line feature
# only return observations if coastDist >= 0 and if coordinates
test1transect <- subset(csv,csv[,col_of_interest(csv, 'originX$')]== uniqueX[n]
& csv[,col_of_interest(csv, 'coastDist$')] >= 0 )
subset <- test1transect[,sort(c(col_of_interest(csv, 'coastDist$'), col_of_interest(csv, 'DATE_ACQUIRED$')))]
if(is.null(nrow(subset))){
df_coastDist[n,] <- rep(NA, length(uniqueDates))
} else {
mathcingDates <- match(colnames(df_coastDist), subset[ ,col_of_interest(subset, 'DATE_ACQUIRED')])
df_coastDist[n,mathcingDates[!is.na(c(mathcingDates))]] <- subset[,col_of_interest(subset, 'coastDist$')]
}
#
#
# coordiates of coastline points
coords <- data.frame(x = as.numeric(test1transect[,col_of_interest(csv, 'coastX$')]),
y = as.numeric(test1transect[,col_of_interest(csv, 'coastY$')]),
DATE_ACQUIRED = as.character(test1transect[,col_of_interest(csv, 'DATE_ACQUIRED$')]))
allPoints <- rbind(allPoints, coords)
}
points <- SpatialPointsDataFrame(data.frame(allPoints[,'x'], allPoints[,'y'] ),
data = data.frame(allPoints[,'DATE_ACQUIRED']),
proj4string=CRS("+proj=longlat +datum=WGS84"))
colnames(points@data) <- c("DATE_ACQUIRED")
AllLines <- SpatialLines(lines, proj4string=CRS("+proj=longlat +datum=WGS84"))
df <- SpatialLinesDataFrame(AllLines,data.frame(df_coastDist))
# change format of lines
lines_sf <- st_as_sf(df)
points_sf <- st_as_sf(points)
mapview(lines_sf,xcol = "x", ycol = "y") + mapview(points_sf, zcol = "DATE_ACQUIRED")
offShorePoints <- vector('list', length(csv))
# off-shore points for selected images
for (q in 1:length(uniqueDates)){
q <- 6
# select all rows that have an acquisition date
date <- uniqueDates[q]
csv_subset <- subset(csv,csv[,col_of_interest(csv, 'DATE_ACQUIRED$')]== date)
coordsOffShore <- data.frame(x = as.numeric(csv_subset[,col_of_interest(csv_subset, 'peakCoordX$')]),
y = as.numeric(csv_subset[,col_of_interest(csv_subset, 'peakCoordY$')]),
pos = as.numeric(csv_subset[,col_of_interest(csv_subset, 'pos$')]),
DATE_ACQUIRED = as.character(date))
offShorePoints <- rbind(offShorePoints, coordsOffShore)
}
SpatialOffShore <- SpatialPointsDataFrame(data.frame(offShorePoints[,'x'], offShorePoints[,'y'] ),
data = data.frame(offShorePoints[,'pos'], offShorePoints[,'DATE_ACQUIRED']),
proj4string=CRS("+proj=longlat +datum=WGS84"))
mapview(SpatialOffShore,xcol = "x", ycol = "y", popup = popupGraph(DATE_ACQUIRED)) + lines_sf
mapview(SpatialOffShore,xcol = "x", ycol = "y",  zcol = "DATE_ACQUIRED") + lines_sf
mapview(SpatialOffShore,xcol = "x", ycol = "y",  zcol = "DATE_ACQUIRED")
SpatialOffShore_sf <- st_as_sf(SpatialOffShore)
mapview(SpatialOffShore_sf,xcol = "x", ycol = "y",  zcol = "DATE_ACQUIRED")
SpatialOffShore <- SpatialPointsDataFrame(data.frame(offShorePoints[,'x'], offShorePoints[,'y'] ),
data = data.frame(offShorePoints[,'pos'], offShorePoints[,'DATE_ACQUIRED']),
proj4string=CRS("+proj=longlat +datum=WGS84"))
SpatialOffShore_sf <- st_as_sf(SpatialOffShore)
mapview(SpatialOffShore_sf,xcol = "x", ycol = "y",  zcol = "DATE_ACQUIRED")
offShorePoints[,'DATE_ACQUIRED']
SpatialOffShore
colnames(SpatialOffShore@data)
colnames(points@data) <- c("pos","DATE_ACQUIRED")
colnames(SpatialOffShore@data) <- c("pos","DATE_ACQUIRED")
SpatialOffShore_sf <- st_as_sf(SpatialOffShore)
mapview(SpatialOffShore_sf,xcol = "x", ycol = "y",  zcol = "DATE_ACQUIRED")
length(uniqueDates)
# off-shore points for selected images
for (q in 1:length(uniqueDates)){
# q <- 6
# select all rows that have an acquisition date
date <- uniqueDates[q]
csv_subset <- subset(csv,csv[,col_of_interest(csv, 'DATE_ACQUIRED$')]== date)
coordsOffShore <- data.frame(x = as.numeric(csv_subset[,col_of_interest(csv_subset, 'peakCoordX$')]),
y = as.numeric(csv_subset[,col_of_interest(csv_subset, 'peakCoordY$')]),
pos = as.numeric(csv_subset[,col_of_interest(csv_subset, 'pos$')]),
DATE_ACQUIRED = as.character(date))
offShorePoints <- rbind(offShorePoints, coordsOffShore)
}
SpatialOffShore <- SpatialPointsDataFrame(data.frame(offShorePoints[,'x'], offShorePoints[,'y'] ),
data = data.frame(offShorePoints[,'pos'], offShorePoints[,'DATE_ACQUIRED']),
proj4string=CRS("+proj=longlat +datum=WGS84"))
colnames(SpatialOffShore@data) <- c("pos","DATE_ACQUIRED")
SpatialOffShore_sf <- st_as_sf(SpatialOffShore)
mapview(SpatialOffShore_sf,xcol = "x", ycol = "y",  zcol = "DATE_ACQUIRED")
mapview(SpatialOffShore_sf,xcol = "x", ycol = "y",  zcol = "DATE_ACQUIRED") + mapview(lines_sf)
library(rgdal)
library(raster)
library(sf)              # Vector data
library(purrr)           # to run map_dfr
library(dplyr)           # to run map dfr
library(ggplot2)
library(viridis)         # colour blind friendly pallette
library(rgeos)
library(alphahull)
library(maptools)
library(sp)              # Spatial data in general
library(geosphere)
library(rasterVis) # Hovmoller diagram
library(snow)
# library(leaflet) # interactive maps
old <- getwd()
# Coastline from tidal analysis
kustlijn_total <- readOGR('D:/MangroMud/Site1_Suriname_all/Analysis/IntertidalArea/Coastlines','class10_line_v5')
library(rgdal)
library(raster)
library(sf)              # Vector data
library(purrr)           # to run map_dfr
library(dplyr)           # to run map dfr
library(ggplot2)
library(viridis)         # colour blind friendly pallette
library(rgeos)
library(alphahull)
library(maptools)
library(sp)              # Spatial data in general
library(geosphere)
library(rasterVis) # Hovmoller diagram
library(snow)
# library(leaflet) # interactive maps
old <- getwd()
# function to define transect characteristics: spacing & length
evenspace <- function(line, sep, start=0, tlen, smoothing_factor){
# ##for testing:
# smoothing_factor <- 50
# sep <- 1000
# tlen <- 30000
# start <- 0
# line <- kustlijn_smoothed
# ### line <- kustlijn_total
if(length(line)>1){
line <- gLineMerge(line) # make one feature out of all line features
} else {
line <- line
}
# transform line in UTM (allow calculation in Meters)
# projection EPSG:31121 (epsg projection 31121 - zanderij / utm zone 21n): http://spatialreference.org/ref/epsg/31121/
line <- spTransform(line, CRS(as.character("+proj=utm +zone=21 +ellps=intl +towgs84=-265,120,-358,0,0,0,0 +units=m +no_defs")))
# plot(line, col = rainbow(length(unique(line@lines))))
AllTransects <- vector('list', 100000) # DB that should contain all transects
# for each element in geometry calculate line positions seperately:
# for (i in unique(line$ID)){
for (i in 1: length(line)){
# i <- 1
######
##
## Define transect starting points
#####
# Define geometry subset
subset_geometry <- data.frame(geom(line[i,]))[, c('x', 'y')]
# plot(SpatialPoints(data.frame(x = subset_geometry[,'x'], y = subset_geometry[,'y']),CRS(as.character(line@proj4string))),
#         axes = T, add = T)
# is the plotorder causing problems?
retrieve_order <- SpatialPolygons(list(Polygons(list(Polygon(data.frame(x = subset_geometry[,'x'], y = subset_geometry[,'y']))),1)),
proj4string = CRS(as.character(line@proj4string)))
# plot(retrieve_order, col = rainbow(length(unique(retrieve_order@polygons))))
dx <- c(0, diff(subset_geometry[,'x'])) # Calculate difference at each cell comapred to next cell
dy <- c(0, diff(subset_geometry[,'y']))
dseg <- sqrt(dx^2+dy^2)                 # get rid of negatives and transfer to uniform distance per segment (pythagoras)
dtotal <- cumsum(dseg)                  # cumulative sum total distance of segments
linelength = sum(dseg)                  # total linelength ( in units of original line input)
pos = seq(start,linelength, by=sep)     # Array with postions numbers in meters
whichseg = unlist(lapply(pos, function(x){sum(dtotal<=x)})) # select Segments corresponding to distance
# Data frame with positions ON the coastline (starting points)
pos=data.frame(pos=pos,                            # keep only
whichseg=whichseg,                  # Position in meters on line
x0=subset_geometry[whichseg,1],     # x-coordinate on line
y0=subset_geometry[whichseg,2],     # y-coordinate on line
dseg = dseg[whichseg+1],            # segment length selected (sum of all dseg in that segment)
dtotal = dtotal[whichseg],          # Accumulated length
x1=subset_geometry[whichseg+1,1],   # Get X coordinate on line for next point
y1=subset_geometry[whichseg+1,2],    # Get Y coordinate on line for next point
xnext = subset_geometry[ifelse(whichseg+smoothing_factor >= nrow(subset_geometry),
nrow(subset_geometry), whichseg+smoothing_factor),1],
ynext = subset_geometry[ifelse(whichseg+smoothing_factor >= nrow(subset_geometry),
nrow(subset_geometry), whichseg+smoothing_factor),2],
xprev = subset_geometry[ifelse(whichseg-smoothing_factor <= 0, 1, whichseg-smoothing_factor),1],
# Get X coordinate on line for previous point, unless it is the first point of the line
yprev = subset_geometry[ifelse(whichseg-smoothing_factor <= 0, 1, whichseg-smoothing_factor),2] # Get Y coordinate on line for previous point
)
# ensure equal spacing
pos$further =  pos$pos - pos$dtotal       # which is the next position (in meters)
pos$f = pos$further/pos$dseg              # fraction next segment of its distance
# because of smoothing factor this changes starting point
pos$x = pos$x0 + pos$f * (pos$x1-pos$x0)  # X Position of point on line which is x meters away from x0: ensure equal spacing
pos$y = pos$y0 + pos$f * (pos$y1-pos$y0)  # Y Position of point on line which is x meters away from y0: ensure equal spacing
# pos$theta = atan2(pos$y0-pos$y1,pos$x0-pos$x1)  # Angle between points on the line in radians
# pos$theta = atan2(pos$y1-pos$yprev,pos$x1-pos$xprev)
pos$theta = atan2(pos$ynext-pos$yprev, pos$xnext-pos$xprev)
pos$object = i
# plot(SpatialPoints(data.frame(x = pos[,'x'], y = pos[,'y']),CRS(as.character(line@proj4string))),
#         axes = T, add = T, col = 'red')
######
##
## Define transect end points
#####
pos$thetaT = pos$theta+pi/2         # Get the angle in degrees?
dx_poi <- tlen*cos(pos$thetaT)      # coordinates of point of interest as defined by position length (sep)
dy_poi <- tlen*sin(pos$thetaT)
# transect is defined by x0,y0 and x1,y1 with x,y the coordinate on the line
output <-     data.frame(pos = pos$pos,
x0 = pos$x + dx_poi,       # X coordinate away from line
y0 = pos$y + dy_poi,       # Y coordinate away from line
x1 = pos$x - dx_poi,       # X coordinate away from line
y1 = pos$y - dy_poi,       # X coordinate away from line
theta = pos$thetaT,    # angle
x = pos$x,             # Line coordinate X
y = pos$y,             # Line coordinate Y
object = pos$object,
nextx = pos$x1,
nexty = pos$y1)
# create polygon from object to select correct segment of the transect (coastal side only)
points_for_polygon <- rbind(output[,c('x', 'y','nextx', 'nexty')])# select points
pol_for_plot <- SpatialPolygons(list( Polygons(list(Polygon(points_for_polygon[,1:2])),1)),
proj4string = CRS(as.character(line@proj4string)))
# plot(SpatialPoints(data.frame(x = points_for_polygon[,'x'], y = points_for_polygon[,'y']),CRS(as.character(line@proj4string))),
#         axes = T, add = T, col = 'blue')
# plot(SpatialPoints(data.frame(x = output[,'x0'], y = output[,'y0']),CRS(as.character(line@proj4string))),
#         axes = T, add = T, col = 'red')
# plot(SpatialPoints(data.frame(x = output[,'x1'], y = output[,'y1']),CRS(as.character(line@proj4string))),
#      axes = T, add = T, col = 'green')
# plot(pol_for_plot, axes = T, add = T, col = 'orange')
# determine first and last point on the coastline
firstForPlot <- data.frame(x = points_for_polygon$x[1], y = points_for_polygon$y[1])
lastForPlot <- data.frame(x = points_for_polygon$x[length(points_for_polygon$x)],
y = points_for_polygon$y[length(points_for_polygon$y)])
# plot_all <- SpatialPoints(points_for_polygon, CRS(as.character(line@proj4string)))
plot_first <- SpatialPoints(firstForPlot, CRS(as.character(line@proj4string)))
plot_last <- SpatialPoints(lastForPlot, CRS(as.character(line@proj4string)))
# plot(plot_first, add = T, col = 'red')
# plot(plot_last, add = T, col = 'purple')
# plot(plot_all, add = T)
## Corners of bounding box
LX <- min(points_for_polygon$x)
UX <- max(points_for_polygon$x)
LY <- min(points_for_polygon$y)
UY <- max(points_for_polygon$y)
# polygon(x = c(LX, UX, UX, LX), y = c(LY, LY, UY, UY), lty = 2)
# polygon(x = c(LX, UX, LX), y = c(LY, LY, UY), lty = 2)
# grow polygon
left1 <- data.frame(x = LX - (tlen + 1), y = LY)
right1 <- data.frame(x = UX + (tlen + 1), y = LY)
LL_corner <- data.frame(x = LX - 2 * tlen, y = LY - 2 * tlen)
LR_corner <- data.frame(x = UX + tlen, y = LY - 2 * tlen)
# UR_corner <- data.frame(x = LX - tlen, y = UY - tlen)
corners <- rbind(LL_corner, LR_corner,left1,right1)
bbox_add <- SpatialPoints(corners, CRS(as.character(line@proj4string)))
# plot(bbox_add ,col = 'blue', axes = T, add = T)
# Control plot order of points to avoid weird shapes by using nearest point first
firstForPlot$near <- apply(gDistance(bbox_add,plot_last, byid = T), 1, which.min)
lastForPlot$near <- apply(gDistance(bbox_add,plot_first, byid = T), 1, which.min)
secondForPlot <- apply(gDistance(bbox_add[row.names(bbox_add) != firstForPlot$near & # not equal to first & last for plot
row.names(bbox_add) != lastForPlot$near,],
plot_last, byid = T), 1, which.min)
secondplot <- SpatialPoints(rbind(corners[secondForPlot,]), CRS(as.character(line@proj4string)))
thirdForPlot <- apply(gDistance(bbox_add[row.names(bbox_add) != secondForPlot,],
secondplot, byid = T), 1, which.min)
thirdplot <- SpatialPoints(rbind(corners[thirdForPlot,]), CRS(as.character(line@proj4string)))
# plot(secondplot, add = T, col = 'red')
# plot(thirdplot, add = T, col = 'purple')
# increase polygon with corresponding points
points_for_polygon_incr <- rbind(points_for_polygon[,1:2], corners[firstForPlot$near,],
# corners[row.names(corners) != firstForPlot$near,],
corners[secondForPlot,],
corners[thirdForPlot,],
corners[lastForPlot$near,]
)
pol_for_intersect_incr <- SpatialPolygons( list( Polygons(list(Polygon(points_for_polygon_incr)),1)),
proj4string = CRS(as.character(line@proj4string)))
# plot(pol_for_intersect_incr, col = 'brown', add = T)
# plot
coordsxy <- data.frame(x = output$x, y = output$y)
plotxy <- SpatialPoints(coordsxy, proj4string = CRS(as.character(line@proj4string)))
# plot(plotxy, add = T, col = 'blue')
coordsx1y1 <- data.frame(x = output$x1, y = output$y1)
plotx1y1 <- SpatialPoints(coordsx1y1, proj4string = CRS(as.character(line@proj4string)))
# plot(plotx1y1, add = T)
coordsx0y0 <- data.frame(x = output$x0, y = output$y0)
plotx0y0 <- SpatialPoints(coordsx0y0, proj4string = CRS(as.character(line@proj4string)))
# plot(plotx0y0, add = T, col = 'red')
#intersect
output[, "x1y1"] <- over(plotx1y1, pol_for_intersect_incr) #NA denotes the point does not fall in a polygon;
output[, "x0y0"] <- over(plotx0y0, pol_for_intersect_incr)
# x1y1NA <- sum(is.na(output$x1y1)) # Count Na
# x0y0NA <- sum(is.na(output$x1y1)) # Count NA
# Assign x1 and y1 if end coordinate is not inside the polygon
indexx0y0 <- with(output, is.na(output$x1y1))
output[indexx0y0, 'endx'] <- output[indexx0y0, 'x1']
output[indexx0y0, 'endy'] <- output[indexx0y0, 'y1']
# assign x0 and y0 if end coordinate is 'clipped'
index <- with(output, is.na(output$x0y0))
output[index, 'endx'] <- output[index, 'x0']
output[index, 'endy'] <- output[index, 'y0']
# drop rows that have both points intersecting with polygon
output <- output[with(output, !is.na(output$endx)),]
AllTransects = rbind(AllTransects, output)
}
# create all transects
id <- rownames(AllTransects)
AllTransects <- cbind(id=id, AllTransects)
lines <- vector('list', nrow(AllTransects))
for(n in seq_along(lines)){
# n = 10
col_names <- list('lon', 'lat')
row_names <- list('begin', 'end')
# dimnames < list(row_names, col_names)
begin_coords <- data.frame(lon = AllTransects$x, lat = AllTransects$y)       # Coordinates on the original line
end_coords <- data.frame(lon = AllTransects$endx, lat = AllTransects$endy)   # coordinates as determined by the over: remove implement in row below by selecting correct column from output
x <- as.matrix(rbind(begin_coords[n,], end_coords[n,]))
dimnames(x) <- list(row_names, col_names)
lines[[n]] <- Lines(list(Line(x)), ID = as.character(AllTransects[n, 1]))
}
lines_sf <- SpatialLines(lines, proj4string = CRS(as.character(line@proj4string)))
# plot(lines_sf, add = T, col = 'black')
df <- SpatialLinesDataFrame(lines_sf, data.frame(AllTransects, row.names = AllTransects[, 1]))
# clean transects
# 1: remove parts that intersect with coastline
for(trans in 1: length(df)){ # kijk in elke transect
# trans <- 260
transect <- df[trans,]
# plot(transect, add = T, col = 'red')
subset_trans <- data.frame(geom(transect))[, c('x', 'y')]
pnt_trans <- gBuffer(SpatialPoints(data.frame(x = subset_trans[,'x'], y = subset_trans[,'y']),
CRS(as.character(line@proj4string)))[1], width = 3000) # select points from transect + buffer
intersect <- gIntersection(pnt_trans, line) # intersect points with coastline
start_buf <- gBuffer(intersect, width = 1000) # Apply a buffer to the intersection point
clipTrans <- gDifference(transect, start_buf) # reduce the transect by the buffer
# after clipping on the buffer: test for coastline intersect
intersect_final <- any(gIntersects(clipTrans,line)) # true for intersection
df$intersect[trans] <- ifelse(intersect_final, 1, 0) # geef waarde 1 als de transect met een stuk kust snijdt (maar niet begipunt)
}
df = df[df$intersect != 1,]
# remove parts that frequently intersect other?
# voorkeur zal ontstaan omdat aan het begin meer transects verwijderd zullen worden.
# for(trans in 1: length(df)){
#   transect <- df[trans,]
# }
return(df)
}
# Coastline from tidal analysis
kustlijn_total <- readOGR('D:/MangroMud/Site1_Suriname_all/Analysis/IntertidalArea/Coastlines','class10_line_v5')
