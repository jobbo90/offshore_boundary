allFiles <- do.call(rbind, lapply(as.matrix(filtered)[,1], function(x) read.csv(x, stringsAsFactors = FALSE,
sep = ',', na.strings=c("","NA")
)))
col_dates <- col_of_interest(allFiles, 'DATE_ACQUIRED$')
col_coastDist <- col_of_interest(allFiles, 'coastDist$')
# all unique transect (id's)
allPos <- unique(allFiles[, col_of_interest(allFiles, 'pos$')]);
uniqueX<- unique(allFiles[, col_of_interest(allFiles, 'originX$')]);
uniqueY<- unique(allFiles[, col_of_interest(allFiles, 'originY$')]);
geo<- unique(allFiles[, col_of_interest(allFiles, '.geo')]);
uniqueDates <- unique(allFiles[,col_dates]);
# keep_columns <- c('axisDist', 'mudFract', 'endDrop', 'coastDist',
#                   'originX', 'originY', 'coastX', 'coastY')
drop <- c('system.index', '.geo')
keep_columns <- colnames(allFiles)[!(colnames(allFiles) %in% drop)]
mudbanks <- reshape_csvPoints(allFiles, 'peakCoordX', 'peakCoordY', keep_columns)
# change to NA
mudbanks$coastDist[mudbanks$coastDist == -1] <- NA
# sort al rows based on position & date
mudbanks<-mudbanks[with(mudbanks, order(pos, DATE_ACQUIRED)), ]
# make groups per year, 3 months and 3 years per transect
mudbanks <- mudbanks %>%
mutate(quarterly_col = as.Date(cut(lubridate::date(mudbanks$DATE_ACQUIRED),
"3 month"))) %>%
mutate(date_col = as.Date(cut(lubridate::date(mudbanks$DATE_ACQUIRED),
"3 year"))) %>%
mutate(five_year_col = as.Date(cut(lubridate::date(mudbanks$DATE_ACQUIRED),
"5 year"))) %>%
mutate(year_col = as.Date(cut(lubridate::date(mudbanks$DATE_ACQUIRED),
"1 year")))
group_dates<-unique(mudbanks$year_col)
group_pos <- unique(mudbanks$pos)
group_years <- unique(mudbanks$date_col)
five_years <- unique(mudbanks$five_year_col)
# assume nothing is outlier
mudbanks$coast_outlier <- 1
mudbanks$slope         <- NA
mudbanks$coastObs      <- NA
#'
#'  estimate coastal outliers with rosner test
#'  - for each transect per 3 years to ensure sufficient observations
#'
#'  Still poses problems for some transects
#'  Resulting in negative mudbank distances, especially at transects
#'  near river mouths.
#'  Also test for years with low obs?! 1985 - 2000
for(i in five_years){
start <- Sys.time()
# i<-five_years[five_years == c("1991-01-01")]
for(q in group_pos){
# pos_to_test <- 	235000
# q <- group_pos[group_pos == 116000]
# print(q)
indexs <- which(mudbanks$five_year_col == i &
mudbanks$pos == q &
mudbanks$coastDist > -1)
subsets3 <- mudbanks[indexs, ]
# get nearest observation and add it to the list
# is .na going to throw a problem?
reference_date <- mean(as.Date(subsets3$DATE_ACQUIRED))
# Aamount of obs
obs_3years <- nrow(subsets3)
# update that if subset per year is to small, include extra observations?
# So grow the subset to at least 10(?) obs by adding nearest observations
maxAttemp <- 0 # make sure you don't get stuck in infinite loop..
while(nrow(subsets3) < min_obs_rosner &
# nrow(subsets3)+obs_3years > min_obs_rosner &
maxAttemp < min_obs_rosner+5){
# exclude dates from the year of interest
# sample from entire dataset so that years outside the 3 year block
# are also possible candidates
# pitfall: any date is possible, also the ones to far away
# so set limit at search window of x years?
selectedDates <- subset(mudbanks, mudbanks$pos == q &
mudbanks$coastDist > -1 &
!(mudbanks$DATE_ACQUIRED %in%
subsets3$DATE_ACQUIRED)
)$DATE_ACQUIRED
# exclude the ones already selected
# are NA a problem that seems to throw warnings()?
nearestDate <- selectedDates[1:length(selectedDates) ==
which.min(replace(abs(as.Date(selectedDates) - reference_date),
abs(as.Date(selectedDates) - reference_date)>year_limit*356, NA))]
# if nothing is found, break the loop
if(length(nearestDate) == 0){break}
index_nearest <- which(as.Date(as.character(mudbanks$DATE_ACQUIRED)) == nearestDate &
mudbanks$pos == q &
mudbanks$coastDist > -1)
# update subsets
subsets3 <- rbind(subsets3, mudbanks[index_nearest, ] )
maxAttemp = maxAttemp + 1
}
# because subsets 3 changed in size, recalc the indices.
subsets3_recal <- which(mudbanks$DATE_ACQUIRED %in% subsets3$DATE_ACQUIRED &
mudbanks$pos == q &
mudbanks$coastDist > -1)
# apply rosner test if there is sufficient observations ==> this implies that the timeseries to look at needs to be larger than 3 years.
# also the year limit needs to go up.
# All detected outliers with larger std value recieve outlier == 0
# Only give the rosner output to the original subset3 indices
mudbanks[indexs, 'coast_outlier'] <-
rosner(subsets3$coastDist,min_Std , min_obs_rosner)[which(subsets3_recal %in% indexs)]
# consider adding a outlier check for annual obs?
# make sure it is applicable for sufficient observations only
# Or when it involvoves landsat 7 observations?
# plot(as.Date(subsets3$DATE_ACQUIRED), subsets3$coastDist,
#     main = paste0(q), xlab = 'date', ylab = 'coastline position')
#
# points(as.Date(subsets3$DATE_ACQUIRED)[which(rosner(subsets3$coastDist, min_Std, min_obs_rosner) == 0)],
#        subsets3$coastDist[which(rosner(subsets3$coastDist, min_Std, min_obs_rosner) == 0)],
#        col = 'red')
}
end <- Sys.time()
dif<- difftime(end, start, "mins")
print(paste0(as.Date(i) ,' in ', round(dif,1)))
}
#'
#'  calculate slope
#'  - include nearest observations
#'  within predefined search window (4 years difference max)
#'
for(i in group_dates){
start <- Sys.time()
for(q in group_pos){
# i<-group_dates[group_dates == c("1998-01-01")]
#
# pos_to_test <- 	116000
# q <- group_pos[group_pos == pos_to_test]
# print(q)
subsets_annual <- mudbanks[which(mudbanks$year_col == i &
mudbanks$pos == q &
mudbanks$coastDist > -1), ]
# select outliers & non outliers
outliers <- subset(subsets_annual, coast_outlier == 0)
nonOutliers <- subset(subsets_annual, coast_outlier == 1)
# get nearest observation and add it to the list
# if there is nothing there; half way through the year
reference_date <- as.Date(ifelse(nrow(nonOutliers)>0,
mean(as.Date(nonOutliers$DATE_ACQUIRED)),
as.Date(i)+days(180)))
# improvement required!
# slope is only applicable if quality of coastline estimate is
# sufficient (see landsat 7 case with no data in wetland areas)
# if outlier detection is sufficient the slope can be correctly estimated
# if  there is insufficient observations;
# search for additional observations to calculate the slope
# downside; if the observations that are detected are of good quality,
# the slope is wronfully adjusted based on neighbouring observations
# resulting in wrong estimate (often underestimate!) of rate of change.
maxAttemp <- 0
while(nrow(nonOutliers) < 8 &
maxAttemp < min_obs_rosner){
# exclude the ones from the original year
selectDates <- subset(mudbanks, mudbanks$pos == q &
mudbanks$coastDist > -1 & !(mudbanks$DATE_ACQUIRED %in%
nonOutliers$DATE_ACQUIRED))$DATE_ACQUIRED
# get nearest date (excluding dates outside limit)
nearestDate <- selectDates[1:length(selectDates) ==
which.min(replace(abs(as.Date(selectDates) - reference_date),
abs(as.Date(selectDates) - reference_date)>year_limit*356, NA))]
if(length(nearestDate) == 0){break}
index_nearest <- which(as.Date(as.character(mudbanks$DATE_ACQUIRED)) == nearestDate &
mudbanks$pos == q &
mudbanks$coastDist > -1 &
mudbanks$coast_outlier == 1)
# update annual subset
nonOutliers <- rbind(nonOutliers, mudbanks[index_nearest, ] )
maxAttemp = maxAttemp + 1
}
# only fit a line if there is a least 5 valid observations.
if(nrow(nonOutliers) < 5){
m_per_year <- NA
} else {
# calculate linear fit
lm.out <- lm(nonOutliers$coastDist~as.numeric(as.Date(nonOutliers$DATE_ACQUIRED)))
# intercept <-lm.out$coefficients[1]
slope <- round(lm.out$coefficients[2], 5) # change per unit of x (=days)
m_per_year <- slope*365
}
# update all slope values from the original years (incl. coastdist -1 and outliers)
mudbanks$slope[which(mudbanks$year_col == i &
mudbanks$pos == q)] <- as.numeric(m_per_year)
mudbanks$coastObs[which(mudbanks$year_col == i &
mudbanks$pos == q)] <- as.numeric(nrow(nonOutliers))
}
end <- Sys.time()
dif<- difftime(end, start, "mins")
print(paste0(as.Date(i) ,' in ', round(dif,1), ' mins'))
# plot(as.Date(nonOutliers$DATE_ACQUIRED), nonOutliers$coastDist,
#   main = paste0(q), xlab = paste0(i), ylab = 'coastline position',
#   ylim=c(min(nonOutliers$coastDist)-30,max(nonOutliers$coastDist)+30),
#   xlim=c(min(as.Date(nonOutliers$DATE_ACQUIRED)),
#         max(as.Date(nonOutliers$DATE_ACQUIRED))))
# # points(as.Date(outliers$DATE_ACQUIRED), outliers$coastDist, col = 'red')
# abline(lm(nonOutliers$coastDist~as.numeric(as.Date(nonOutliers$DATE_ACQUIRED))),lty = 2)
# text(min(as.Date(subsets3$DATE_ACQUIRED)) + 90,
#      max(subsets3$coastDist) + 25, paste0('slope = ', m_per_year, ' meter'))
}
#'
#'  calculate last observation carried forward
#'
# set initial value
mudbanks$locf <- mudbanks$coastDist
# if coastDist NA or coast observation is an outlier;
indices <- unique(which(is.na(mudbanks$coastDist) | mudbanks$coast_outlier == 0))
for(ind in indices){
# ind<-indices[1200]
data_entry <- mudbanks[ind, ]
# select all accepted observations from the same transect
pos_subset <- subset(mudbanks, mudbanks$pos == data_entry$pos &
mudbanks$coast_outlier == 1 &
!is.na(mudbanks$coastDist))
# plot(pos_subset$DATE_ACQUIRED, pos_subset$locf)
# plot(pos_subset$DATE_ACQUIRED, pos_subset$coastDist, col = 'red')
if(nrow(pos_subset) > 0){ # if no observations; locf remains original observation (=NA?)
test <- abs(as.Date(pos_subset$DATE_ACQUIRED) - as.Date(data_entry$DATE_ACQUIRED))
test[test==0] <- max(test)
minInd <- which.min(test)
nearest <- pos_subset[minInd,]
mudbanks[row.names(mudbanks) == row.names(data_entry), 'locf'] <-
nearest$coastDist # fill with nearest coast obs
}
}
#'
#' Coastline
#' median observation per year
#'
#'
# order by pos
mudbanks<-mudbanks[order(mudbanks$pos),]
# calculate median coastal position
# grouped by pos, year and outlier
mudbanks <- mudbanks %>% dplyr::group_by(pos, year_col, coast_outlier) %>%
dplyr::mutate(coast_median = median(coastDist, na.rm = T))
# set outlier groups to NA
mudbanks$coast_median[mudbanks$coast_outlier == 0] <- NA
# fill outliers with median coastal observation of that year
mudbanks <- mudbanks %>%
group_by(pos, year_col) %>%
# mutate(key = row_number()) %>% # assign a incrementing key value per group as defined in group_by
# select(-key) %>%
# group_by(pos, year_col) %>%
fill(coast_median) %>%
select(-key)
# key to indicate groups of years~
mudbanks$key <- with(rle(as.numeric(mudbanks$year_col)), rep(seq_along(lengths), lengths))
#'
#'  calculate for each pos, each year gain/loss compared to previous year
#'
# fill outliers with median coastal observation of that year
mudbanks <- mudbanks %>%
group_by(pos) %>%
arrange(key) %>%
mutate(deltaCoast = coast_median - lag(coast_median, default = max(coast_median)))%>%
group_by(key) %>%
mutate(deltaCoast=max(deltaCoast, na.rm=F))
#
# # test simple 2d plot
# twoD_pos <- 322000
# #190000
# subset2d_for_testPlot <- subset(mudbanks, pos == twoD_pos)
#
# plot(as.Date(subset2d_for_testPlot$DATE_ACQUIRED), subset2d_for_testPlot$coastDist,
#      xlab="DATE_ACQUIRED", ylab="coastDist [m]",
#      main = paste0('coastline position: ',twoD_pos, ' [m]'))
# points(as.Date(subset2d_for_testPlot[subset2d_for_testPlot$coast_outlier == 0, ]$DATE_ACQUIRED),
#        subset2d_for_testPlot[subset2d_for_testPlot$coast_outlier == 0, ]$coastDist,
#        col = 'red')
# lines(as.Date(subset2d_for_testPlot$DATE_ACQUIRED),  subset2d_for_testPlot$coast_median,
#        col = 'blue')
################################################################################
#' filter mudbank boundary outliers
#'
#' - Filter on neighborhood (previous 2, current and next two points)
#'     Use distance to see if the point is deviating
#'     Consider using fraction..
#'
#'     good example dates: 2017-09-02, "2018-02-27", 2018-08-28, 2018-09-27
################################################################################
# mudbank Distance
mudbanks$mudbank_distance <- mudbanks$axisDist - mudbanks$coast_median
# some examples
mudbanks_select <-subset(mudbanks, mudbanks$DATE_ACQUIRED == uniqueDates[2] &
mudbanks$axisDist >= 0 &
mudbanks$mudbank_distance >= 0)
# set outlier: assume nothing is an outlier
mudbanks$mudbank_outlier <- 0
# translate other distances into coordinates
# axisDistSlope / axisDistAbs / maxExtent(?)
# bearing is already calculated for each transect, and origin is known
# mudbanks_selection$axisDistAbs[3]
# mudbanks_selection$originX[3]
# mudbanks_selection$originY[3]
# mudbanks_selection$bearing[3]
# get for all obs the x,y coords corresponding to measured distances
# overwrite previous mudbanks variable
mudbanks <- get_dists2(mudbanks, mudbanks$originX, mudbanks$originY,
mudbanks$bearing,
c('axisDistAbs', 'axisDistSlope', 'maxExtent'))
# # make it spatial
# SpatialPoints <- SpatialPointsDataFrame(data.frame(x= test_get$axisDistAbsX, y = test_get$axisDistAbsY),
#                                         data = data.rame(test_get),
#                                         proj4string=CRS("+proj=longlat +datum=WGS84"))
# sp_axisDistAbs <- st_as_sf(SpatialPoints)
i <- uniqueDates[3]
# select relevant observations
mudbanks_selection <-subset(mudbanks, mudbanks$DATE_ACQUIRED == i &
mudbanks$axisDist >= 0 &
!(pos %in% posToExclude) &
mudbanks$mudbank_distance >= 0)
mudbanks[which(mudbanks$DATE_ACQUIRED == i &
mudbanks$axisDist < 0 &
mudbanks$mudbank_distance < 0), "mudbank_outlier"] <-
as.data.frame(mudbanks[
which(mudbanks$DATE_ACQUIRED == i &
mudbanks$axisDist < 0 &
mudbanks$mudbank_distance < 0),"mudbank_outlier"])[,1] + 1
# order by position
mudbanks_selection<-mudbanks_selection[order(mudbanks_selection$pos),]
positions_all <- as.numeric(as.character(mudbanks_selection$pos))
distances_all <-mudbanks_selection$mudbank_distance # grab the normalized distances
# second order polynomial fit: alongshore position & polynomial fit
lm_out_all <-lm(distances_all ~ poly(as.numeric(positions_all),2))
predicted.intervals <- predict(lm_out_all,
data.frame(x=as.numeric(positions_all)),
interval='confidence', level=0.99)
# Bonferroni-adjusted mudbank_outlier test (test largest absolute standardized residual)
outlier_test <- car::outlierTest(lm_out_all)
outlier_ind<-as.numeric(names(outlier_test$rstudent))
# Give mudbank_outlier +1 in the source file to keep track
mudbanks[which(mudbanks$DATE_ACQUIRED == i &
mudbanks$pos %in% positions_all[outlier_ind]), "mudbank_outlier"] <-
as.data.frame(mudbanks[
which(mudbanks$DATE_ACQUIRED == i &
mudbanks$pos %in% positions_all[outlier_ind]),"mudbank_outlier"])[,1] + 1
outlier_selection <- mudbanks_selection[outlier_ind,]
# drop the most obvious outliers from the selection
mudbanks_selection <- mudbanks_selection[-outlier_ind, ]
# plot
plot(positions_all, distances_all, main = paste0(i),
xlab = 'alongshore position', ylab = 'cross shore dist')
# points(positions_all[outlier_ind],distances_all[outlier_ind], col = 'red')
points(positions_all, mudbanks_selection$axisDistAbs, col = 'blue')
points(positions_all, mudbanks_selection$axisDistSlope, col = 'red')
indicesToDrop <- NULL
for (pnt in 1:nrow(mudbanks_selection)){
# pos_of_interst <- 224000 #81000
# selected_point <-mudbanks_selection[which(mudbanks_selection$pos == pos_of_interst),]
# pnt <- 55
selected_point <-mudbanks_selection[pnt,]
# plot all info per point available
plot(c(selected_point$axisDist, selected_point$axisDistAbs, selected_point$axisDistSlope),
c(selected_point$mudFract, selected_point$mudFractAbs, selected_point$mudFractSlope),
main = paste0(selected_point$pos), xlab = 'distance', ylab = 'fraction',
ylim=c(0, 1),
xlim=c(0,selected_point$maxExtent + 1000))
points(selected_point$SmoothedPeak, selected_point$SmoothedPeakFract, col = 'green' )
points(selected_point$maxExtent, selected_point$maxExtentIndex, col = 'red')
abline(selected_point$meanMud, 0)
abline(v=as.numeric(selected_point$coastDist))
# if slope between smoothed peak & maxExtent is low
# test if can be used to filter out mudbank obs. e.g. height, distance and slope between points
slope <- (selected_point$SmoothedPeakFract - selected_point$maxExtentIndex) /
(selected_point$SmoothedPeak -  selected_point$maxExtent)
if(slope>0){
# mudbanks_selection<-mudbanks_selection[-pnt,]
indicesToDrop <- rbind(indicesToDrop,selected_point)
}
# each transect now contains 3x distances: rel, abs and slope drops
# Is it possible to define some rules on these 3 points? E.g. define the potential of an outlier based on some tests?
# e.g. if same pos = no outlier
# if fraction < mean value add + 1 for outlier?
#
}
# make it spatial
SpatialPointsAbs <- SpatialPointsDataFrame(data.frame(x= mudbanks_selection$axisDistAbsX, y = mudbanks_selection$axisDistAbsY),
data = data.frame(mudbanks_selection),
proj4string=CRS("+proj=longlat +datum=WGS84"))
sp_axisDistAbs <- st_as_sf(SpatialPointsAbs)
SpatialPointsSlope <- SpatialPointsDataFrame(data.frame(x= mudbanks_selection$axisDistSlopeX, y = mudbanks_selection$axisDistSlopeY),
data = data.frame(mudbanks_selection),
proj4string=CRS("+proj=longlat +datum=WGS84"))
sp_axisDistSlope <- st_as_sf(SpatialPointsSlope)
SpatialPointsNegSlope <- SpatialPointsDataFrame(data.frame(x= indicesToDrop$axisDistSlopeX, y = indicesToDrop$axisDistSlopeY),
data = data.frame(indicesToDrop),
proj4string=CRS("+proj=longlat +datum=WGS84"))
sp_indicesToDrop <- st_as_sf(SpatialPointsNegSlope)
collectionL4 <- ee$ImageCollection("LANDSAT/LT04/C01/T1_TOA")$
filterBounds(ee$Geometry$Point(-55.54, 5.94))
collectionL5 <- ee$ImageCollection("LANDSAT/LT05/C01/T1_TOA")$
filterBounds(ee$Geometry$Point(-55.54, 5.94))
collectionL7 <- ee$ImageCollection("LANDSAT/LE07/C01/T1_TOA")$
filterBounds(ee$Geometry$Point(-55.54, 5.94))
collectionL8 <- ee$ImageCollection("LANDSAT/LC08/C01/T1_TOA")$
filterBounds(ee$Geometry$Point(-55.54, 5.94))
collection <- collectionL8$merge(collectionL5)$merge(collectionL7)$
merge(collectionL4)
vizParams = list(
bands = c("B5", "B4", "B3"),
min = 0.05, max = 0.4, gamma = 1.4
)
# collection for testing
i <- c("2000-05-22") #uniqueDates[3]
filtCollect <- collection$filterDate(as.character(as.Date(i)-1),
as.character(as.Date(i)+1))
dates <- ee_get_date_ic(filtCollect, time_end = FALSE)
Map$centerObject(filtCollect$first())
first <- Map$addLayer(filtCollect$first(), vizParams, paste0('landsat: ',i))
first
m2 <- Map$addLayer(
eeObject = sf_as_ee(outlier_selection),
name = "outliers"
)
class(outlier_selection)
sf_as_ee(outlier_selection)
m2 <- Map$addLayer(
eeObject = sf_as_ee(outlier_selection),
name = "outliers"
)
first + sf_as_ee(outlier_selection)
m2 <- Map$addLayer(
eeObject = st_sfc(st_point(c(-55.6, 6.02)), crs=4326),#sf_as_ee(outlier_selection),
name = "outliers"
)
m2 <- Map$addLayer(
eeObject = sf_as_ee(st_sfc(st_point(c(-55.6, 6.02)), crs=4326)),#sf_as_ee(outlier_selection),
name = "outliers"
)
first + m2
works <- sf_as_ee(st_sfc(st_point(c(-55.6, 6.02)), crs=4326))
doesntwork <- st_sfc(outlier_selection)
doesntwork <- st_point(outlier_selection)
class(works)
works <- st_sfc(st_point(c(-55.6, 6.02)), crs=4326)
works
doesntwork <- outlier_selection
doesntwork
doesntwork <- sf_as_ee(outlier_selection)
m2 <- Map$addLayer(
eeObject = doesntwork,
name = "outliers"
)
class(works)
klass(doesntwork)
class(doesntwork)
doesntwork <- outlier_selection
doesntwork
class(doesntwork)
?st_point
doesntwork <- sp_indicesToDrop
doesntwork
m2 <- Map$addLayer(
eeObject = doesntwork,
name = "outliers"
)
doesntwork <- sf_as_ee(sp_indicesToDrop)
m2 <- Map$addLayer(
eeObject = doesntwork,
name = "outliers"
)
class(sp_indicesToDrop)
st_sfc(st_point(c(-55.6, 6.02)), crs=4326)
?st_sfc
doesntwork <- st_sfc(sp_indicesToDrop)
class(sp_indicesToDrop)
doesntwork <- st_as_sfc(sp_indicesToDrop)
first
st_as_sfc(sp_indicesToDrop)
st_sfc(sp_indicesToDrop)
?st_point
matrix(1:10, , 2)
matrix(mudbanks_selection$axisDistAbsX,
, mudbanks_selection$axisDistAbsY)
matrix(mudbanks_selection$axisDistAbsX,
mudbanks_selection$axisDistAbsY)
matrix(mudbanks_selection$axisDistAbsX,
mudbanks_selection$axisDistAbsY,2)
mudbanks_selection$axisDistAbsY
mudbanks_selection$axisDistAbsX
matrix(mudbanks_selection$axisDistAbsX,
mudbanks_selection$axisDistAbsY)
t(mudbanks_selection$axisDistAbsY)
st_multipoint(matrix(t(mudbanks_selection$axisDistAbsX),
t(mudbanks_selection$axisDistAbsY)))
t(mudbanks_selection$axisDistAbsX)
matrix(t(mudbanks_selection$axisDistAbsX),
t(mudbanks_selection$axisDistAbsY)
matrix(t(mudbanks_selection$axisDistAbsX),
t(mudbanks_selection$axisDistAbsY))
matrix(t(mudbanks_selection$axisDistAbsX),
t(mudbanks_selection$axisDistAbsY))
cbind(mudbanks_selection$axisDistAbsX,
mudbanks_selection$axisDistAbsY)
st_multipoint(cbind(mudbanks_selection$axisDistAbsX,
mudbanks_selection$axisDistAbsY))
testMulti <- st_multipoint(cbind(mudbanks_selection$axisDistAbsX,
mudbanks_selection$axisDistAbsY))
testMulti <- st_sfc(st_multipoint(cbind(mudbanks_selection$axisDistAbsX,
mudbanks_selection$axisDistAbsY)))
testMulti
testMulti <- sf_as_ee(st_sfc(st_multipoint(cbind(mudbanks_selection$axisDistAbsX,
mudbanks_selection$axisDistAbsY))))
?st_set_crs
testMulti <- st_set_crs (st_sfc(st_multipoint(cbind(mudbanks_selection$axisDistAbsX,
mudbanks_selection$axisDistAbsY))),4326 )
testMulti <- sf_as_ee(st_set_crs (st_sfc(st_multipoint(cbind(mudbanks_selection$axisDistAbsX,
mudbanks_selection$axisDistAbsY))),4326 ))
m2 <- Map$addLayer(
eeObject = testMulti,
name = "outliers"
)
first + m2
