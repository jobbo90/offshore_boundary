points1<- reshape_csvPoints(csv1, 'peakCoordX', 'peakCoordY')
pointsLand1 <- reshape_csvPoints(csv1, 'coastX', 'coastY')
points2<- reshape_csvPoints(csv2, 'peakCoordX', 'peakCoordY')
pointsLand2 <- reshape_csvPoints(csv2, 'coastX', 'coastY')
points3<- reshape_csvPoints(csv3, 'peakCoordX', 'peakCoordY')
pointsLand3 <- reshape_csvPoints(csv3, 'coastX', 'coastY')
test1 +
mapview(pointsLand2,col.regions = c("blue")) +
mapview(points1, col.regions = c("red"), layer.name = c("set1")) +
mapview(points2, col.regions = c("green"), layer.name = c("set2")) +
# mapview(points3, col.regions = c("yellow"), layer.name = c("slopeDrop")) +
mapview(lines_sf,xcol = "x", ycol = "y")
View(points2)
View(points1)
# largest, relative and slope drop for 20091115 image
set1 <- 'Suriname_229_56_2009_till_2009_testImage20090912_largestDrop_20201210'
# set2 <- 'Suriname_229_56_2009_till_2009_testImage20090912_relativeDrop_20201210'
# set3 <- 'Suriname_229_56_2009_till_2009_testImage20090912_slopeDrop_20201210'
set3 <- '/Suriname_229_56_2009_till_2009_testImage20090912_extraMask_largestDrop'
set2 <- 'Suriname_229_56_2009_till_2009_testImage20090912_extraMask_V20201207'
csv1 = as.matrix(read.csv2(as.character(df[grep(set1, folderSelect, ignore.case = T),1]),
header = T, sep = ',', na.strings=c("","NA"))) # rewrite as matrix to read columns as numeric values
csv2 = as.matrix(read.csv2(as.character(df[grep(set2, folderSelect, ignore.case = T),1]),
header = T, sep = ',', na.strings=c("","NA"))) # rewrite as matrix to read columns as numeric values
csv3 = as.matrix(read.csv2(as.character(df[grep(set3, folderSelect, ignore.case = T),1]),
header = T, sep = ',', na.strings=c("","NA"))) # rewrite as matrix to read columns as numeric values
.# mydata <- sapply(list.files(paste0(dataFolder, '/GEE_exports/testImages'), full.names = T), read.csv)
points1<- reshape_csvPoints(csv1, 'peakCoordX', 'peakCoordY')
pointsLand1 <- reshape_csvPoints(csv1, 'coastX', 'coastY')
points2<- reshape_csvPoints(csv2, 'peakCoordX', 'peakCoordY')
pointsLand2 <- reshape_csvPoints(csv2, 'coastX', 'coastY')
points3<- reshape_csvPoints(csv3, 'peakCoordX', 'peakCoordY')
pointsLand3 <- reshape_csvPoints(csv3, 'coastX', 'coastY')
lines1 <- reshape_csvLines(csv1)
# change format of lines
lines_sf <- st_as_sf(lines1)
test1 <- Map$addLayer(image20090912, vizParams, "Landsat 8 False color")
test1 +
mapview(pointsLand2,col.regions = c("blue")) +
mapview(points1, col.regions = c("red"), layer.name = c("set1")) +
mapview(points2, col.regions = c("green"), layer.name = c("set2")) +
mapview(points3, col.regions = c("yellow"), layer.name = c("set3")) +
mapview(lines_sf,xcol = "x", ycol = "y")
rm(list = ls())
#' set working directory for Mac and PC
wd<-getwd()
options(scipen = 6, digits = 4) # I prefer to view outputs in non-scientific notation
memory.limit(30000000)     # this is needed on some PCs to increase memory allowance, but has no impact on macs.
#' load up the packages
source("./src/packages.R")       # loads up all the packages we need
mapviewOptions(basemaps = c( "Esri.WorldImagery","Esri.WorldShadedRelief", "OpenStreetMap.DE"))
dataFolder <- './data/raw'
years <- c('2018', '2019')
# select folders
folderSelect <- as.matrix(list.files(paste0(dataFolder, '/GEE_exports'), full.names = T))
df <- rewrite(folderSelect);
# only csv's
df <- df[grep('.csv', folderSelect, ignore.case = T),]
## ---------------------------
source("./src/functions.R")
mapviewOptions(basemaps = c( "Esri.WorldImagery","Esri.WorldShadedRelief", "OpenStreetMap.DE"))
dataFolder <- './data/raw'
years <- c('2018', '2019')
# select folders
folderSelect <- as.matrix(list.files(paste0(dataFolder, '/GEE_exports'), full.names = T))
df <- rewrite(folderSelect);
# only csv's
df <- df[grep('.csv', folderSelect, ignore.case = T),]
filtered <- vector('list', 100)
for (q in seq_along(years)) {
# q <- 1
year = years[q]
filters = c(year)
filtered = rbind(filtered, df %>%
dplyr::filter(
filters %>%
# apply the filter of all the text rows for each pattern
# you'll get one list of logical by pattern ignored_string
purrr::map(~ to_keep(.x, text = text)) %>%
# get a logical vector of rows to keep
purrr::pmap_lgl(all)
))
}
filtered <- unique(filtered)[1:2,]
allFiles <- do.call(rbind, lapply(as.matrix(filtered)[,1], function(x) read.csv(x, stringsAsFactors = FALSE,
sep = ',', na.strings=c("","NA")
)))
dates <- col_of_interest(allFiles, 'DATE_ACQUIRED$')
coastDist <- col_of_interest(allFiles, 'coastDist$')
# all unique dates
uniqueDates <- unique(allFiles[,dates]);
# all unique transect (id's)
pos <- unique(allFiles[, col_of_interest(allFiles, 'pos$')]);
uniqueX<- unique(allFiles[, col_of_interest(allFiles, 'originX$')]);
uniqueY<- unique(allFiles[, col_of_interest(allFiles, 'originY$')]);
geo<- unique(allFiles[, col_of_interest(allFiles, '.geo')]);
# test simple 2d plot coastline dist
pos_to_test <- c('199000')
testPos <- subset(allFiles, allFiles[,col_of_interest(allFiles, 'pos')] == pos_to_test
& allFiles[,col_of_interest(allFiles, 'coastDist$')] >= 0 )
testPos <- testPos[order(testPos$DATE_ACQUIRED),] #order by date
# plot date & coastline Distance
plot(as.Date(testPos$DATE_ACQUIRED),testPos$coastDist)
# https://www.statsandr.com/blog/outliers-detection-in-r/#:~:text=An%20outlier%20is%20a%20value,significantly%20from%20other%20data%20points.
Rtest <- rosnerTest(testPos$coastDist,
k = 10
# k = 10 or if length < 10 it should be
# this value makes a difference.... apply to blocks of 3 years ==> so outlier size depends on amount of images in those 3 years?
)
indices <- Rtest$all.stats$Obs.Num[which(Rtest$all.stats$Outlier)]
# if outlier give 1 in a new column
testPos$outlier <- 0 # TRUE
testPos$outlier[indices] <- 1 # FALSE
# new<- testPos %>%
#   filter(!row_number() %in% indices) # remove indices that correspond to outliers from rosnerTest
plot(as.Date(testPos$DATE_ACQUIRED[testPos$outlier == 0]),testPos$coastDist[testPos$outlier == 0])
testPos$coastDist[testPos$outlier == 0]
length(testPos$coastDist[testPos$outlier == 0])
length(testPos$coastDist)
Rtest
indices
testPos
# cut in block of so many months?
testZoo <- as.POSIXct(cut(date(testPos$DATE_ACQUIRED), "3 months"))
testPos$DATE_ACQUIRED
# cut in block of so many months?
testZoo <- as.POSIXct(cut(date(testPos$DATE_ACQUIRED), "3 months"))
date(testPos$DATE_ACQUIRED), "3 months")
date(testPos$DATE_ACQUIRED)
testPos$DATE_ACQUIRED
?date
date(testPos$DATE_ACQUIRED)
base:date(testPos$DATE_ACQUIRED)
# library(tidyverse)
# library(dplyr)
# library(reshape2)
library(stringr)
library(sp)
library(rgdal)  # for reading/creating shapefiles
library(raster) # for stack & reading raster
library(qdapRegex)
library(sf)
library(jsonlite) # required for mapView
library(zoo)
library(EnvStats) # for rosnerTest
?date
date(testPos$DATE_ACQUIRED)
as.Date(testPos$DATE_ACQUIRED)
# cut in block of so many months?
testZoo <- as.POSIXct(cut(as.Date(testPos$DATE_ACQUIRED), "3 months"))
testZoo
# how to exclude outliers from the aggregate??
# https://datascienceplus.com/aggregate-data-frame-r/
testpos2<-merge(testPos, aggregate(testPos$coastDist, list(testZoo), median), suffixes = c("dateGroup", ".mean"))# https://stackoverflow.com/questions/38380938/aggregate-conditional-statements
# plot per group after removing outliers
testPos <- merge(testPos, aggregate(testPos$coastDist, list(testZoo), median),suffixes = c("dateGroup", ".mean"))
plot(testPos$Group.1, testPos$x)
# how to exclude outliers from the aggregate??
# https://datascienceplus.com/aggregate-data-frame-r/
testpos2<-merge(testPos, aggregate(testPos$coastDist, list(testZoo), median), suffixes = c("dateGroup", ".mean"))# https://stackoverflow.com/questions/38380938/aggregate-conditional-statements
ist(testZoo)
list(testZoo)
# plot per group after removing outliers
testPos <- merge(testPos, aggregate(testPos$coastDist, list(testZoo), median),suffixes = c("dateGroup", ".mean"))
list(testZoo)
testPos$coastDist
aggregate(testPos$coastDist, list(testZoo), median)
list(testPos$DATE_ACQUIRED)
aggregate(testPos$coastDist, list(testPos$DATE_ACQUIRED), median)
list(testPos$Group.1)
# plot per group after removing outliers
testPos <- merge(testPos, aggregate(testPos$coastDist, list(testPos$Group.1), median),suffixes = c("dateGroup", ".mean"))
plot(testPos$Group.1, testPos$x)
list(testPos$Group.1)
testPos$coastDist
# how to exclude outliers from the aggregate??
# https://datascienceplus.com/aggregate-data-frame-r/
testpos2<-merge(testPos, aggregate(testPos$coastDist, list(testZoo), median), suffixes = c("dateGroup", ".mean"))# https://stackoverflow.com/questions/38380938/aggregate-conditional-statements
testPos$coastDist
list(testZoo)
testZoo
testPos$coastDist
## ---------------------------
#'
#' Script name: Plot offshore boundary results
#'
#' Short Description:
#'
#'
#' Author: Job de Vries
#'
#' Date Created: 2020-11-16
#'
#' Copyright (c) Job de Vries, 2020
#' Email: j.devries4@uu.nl
#'
## ---------------------------
#'
#' Description
#'
#'
#'
## ---------------------------
rm(list = ls())
#' set working directory for Mac and PC
wd<-getwd()
# setwd("I:/BackUp_D_mangroMud_202001/Research/Software/Projects/offshore_boundary")
## ---------------------------
options(scipen = 6, digits = 4) # I prefer to view outputs in non-scientific notation
memory.limit(30000000)     # this is needed on some PCs to increase memory allowance, but has no impact on macs.
#  Map view options:
# https://r-spatial.github.io/mapview/articles/articles/mapview_02-advanced.html
## ---------------------------
#' load up the packages
source("./src/packages.R")       # loads up all the packages we need
## ---------------------------
source("./src/functions.R")
## ---------------------------
dataFolder <- './data/raw'
# transect  <- readOGR(paste0(dataFolder, '/transects'), '2009_WnZ_transect')
# select folders
folderSelect <- as.matrix(list.files(paste0(dataFolder, '/GEE_exports/testImages'), full.names = T))
# metaMatrix <- as.matrix(list.files(folderSelect, pattern=".csv", full.names = T))
mapviewOptions(basemaps = c( "Esri.WorldImagery","Esri.WorldShadedRelief", "OpenStreetMap.DE"))
df <- rewrite(folderSelect);
# only csv's
df <- df[grep('.csv', folderSelect, ignore.case = T),]
# csv <- data.frame(matrix(NA, 0, 18),
#            stringsAsFactors=F)
#
# for (q in nrow(df)){
#   # q = 2
#   csv <- rbind(csv, as.matrix(read.csv2(as.character(df[q,1]),
#                       header = T, sep = ',', na.strings=c("","NA"))))
#
# }
# strings to compare
# set1 <- 'Suriname_229_56_2009_till_2009_testImage2009115'
# set2 <- 'Suriname_229_56_2009_till_2009_testImage2009115_extraMask'
# set1 <- 'Suriname_229_56_2009_till_2009_testImage20091115_extraMask_V20201207'
# set2 <- 'Suriname_229_56_2009_till_2009_testImage20091115_extraMask_largestDrop'
# largest, relative and slope drop for 20091115 image
# set1 <- 'Suriname_229_56_2009_till_2009_testImage20091115_largestDrop_20201210'
# set2 <- 'Suriname_229_56_2009_till_2009_testImage20091115_relativeDrop_20201210'
# set3 <- 'Suriname_229_56_2009_till_2009_testImage20091115_slopeDrop_20201210'
# largest, relative and slope drop for 20091115 image
set1 <- 'Suriname_229_56_2009_till_2009_testImage20090912_largestDrop_20201210'
# set2 <- 'Suriname_229_56_2009_till_2009_testImage20090912_relativeDrop_20201210'
# set3 <- 'Suriname_229_56_2009_till_2009_testImage20090912_slopeDrop_20201210'
set3 <- '/Suriname_229_56_2009_till_2009_testImage20090912_extraMask_largestDrop'
set2 <- 'Suriname_229_56_2009_till_2009_testImage20090912_extraMask_V20201207'
csv1 = as.matrix(read.csv2(as.character(df[grep(set1, folderSelect, ignore.case = T),1]),
header = T, sep = ',', na.strings=c("","NA"))) # rewrite as matrix to read columns as numeric values
csv2 = as.matrix(read.csv2(as.character(df[grep(set2, folderSelect, ignore.case = T),1]),
header = T, sep = ',', na.strings=c("","NA"))) # rewrite as matrix to read columns as numeric values
csv3 = as.matrix(read.csv2(as.character(df[grep(set3, folderSelect, ignore.case = T),1]),
header = T, sep = ',', na.strings=c("","NA"))) # rewrite as matrix to read columns as numeric values
# mydata <- sapply(list.files(paste0(dataFolder, '/GEE_exports/testImages'), full.names = T), read.csv)
points1<- reshape_csvPoints(csv1, 'peakCoordX', 'peakCoordY')
pointsLand1 <- reshape_csvPoints(csv1, 'coastX', 'coastY')
points2<- reshape_csvPoints(csv2, 'peakCoordX', 'peakCoordY')
pointsLand2 <- reshape_csvPoints(csv2, 'coastX', 'coastY')
points3<- reshape_csvPoints(csv3, 'peakCoordX', 'peakCoordY')
pointsLand3 <- reshape_csvPoints(csv3, 'coastX', 'coastY')
# filter -1?
lines1 <- reshape_csvLines(csv1)
# change format of lines
lines_sf <- st_as_sf(lines1)
ee_Initialize()
# Load an image.
image20090912 <- ee$Image("LANDSAT/LT05/C01/T1_TOA/LT05_229056_20090912")
image20091115 <- ee$Image("LANDSAT/LT05/C01/T1_TOA/LT05_229056_20091115")
vizParams <- list(
bands = c("B5", "B4", "B3"),
min = 0.05, max = 0.4, gamma = 1.4
)
test1 <- Map$addLayer(image20090912, vizParams, "Landsat 8 False color")
test1 +
mapview(pointsLand2,col.regions = c("blue")) +
mapview(points1, col.regions = c("red"), layer.name = c("set1")) +
mapview(points2, col.regions = c("green"), layer.name = c("set2")) +
mapview(points3, col.regions = c("yellow"), layer.name = c("set3")) +
mapview(lines_sf,xcol = "x", ycol = "y")
# overlay with the image of interest?
# remotes::install_github("r-spatial/rgee")
#  cannot remove jsonlite package (remove.packages("jsonlite"))
#2D plotting
# order on column names
df_coastDist <- df_coastDist[,order(names(df_coastDist))]
plot(as.Date(colnames(df_coastDist)[1:ncol(df_coastDist)-1]), c(1:length(2:ncol(df_coastDist))))
plot(as.Date(colnames(df_coastDist)[1:ncol(df_coastDist)-1]), df_coastDist[1,1:ncol(df_coastDist)-1])
clicked <- identify(as.Date(colnames(df_coastDist)[1:ncol(df_coastDist)-1]),
df_coastDist[1,1:ncol(df_coastDist)-1],
n=1, labels=colnames(df_coastDist)[1:ncol(df_coastDist)-1])
#2D plotting
# order on column names
df_coastDist <- df_coastDist[,order(names(df_coastDist))]
test1 <- Map$addLayer(image20090912, vizParams, "Landsat 8 False color")
# change format of lines
lines_sf <- st_as_sf(lines1)
ee_Initialize()
ee_install()
ee_clean_pyenv()
## ---------------------------
#'
#' Script name: Plot offshore boundary results
#'
#' Short Description:
#'
#'
#' Author: Job de Vries
#'
#' Date Created: 2020-11-16
#'
#' Copyright (c) Job de Vries, 2020
#' Email: j.devries4@uu.nl
#'
## ---------------------------
#'
#' Description
#'
#'
#'
## ---------------------------
rm(list = ls())
#' set working directory for Mac and PC
wd<-getwd()
# setwd("I:/BackUp_D_mangroMud_202001/Research/Software/Projects/offshore_boundary")
## ---------------------------
options(scipen = 6, digits = 4) # I prefer to view outputs in non-scientific notation
memory.limit(30000000)     # this is needed on some PCs to increase memory allowance, but has no impact on macs.
#  Map view options:
# https://r-spatial.github.io/mapview/articles/articles/mapview_02-advanced.html
## ---------------------------
#' load up the packages
source("./src/packages.R")       # loads up all the packages we need
## ---------------------------
source("./src/functions.R")
## ---------------------------
dataFolder <- './data/raw'
# transect  <- readOGR(paste0(dataFolder, '/transects'), '2009_WnZ_transect')
# select folders
folderSelect <- as.matrix(list.files(paste0(dataFolder, '/GEE_exports/testImages'), full.names = T))
# metaMatrix <- as.matrix(list.files(folderSelect, pattern=".csv", full.names = T))
mapviewOptions(basemaps = c( "Esri.WorldImagery","Esri.WorldShadedRelief", "OpenStreetMap.DE"))
df <- rewrite(folderSelect);
# only csv's
df <- df[grep('.csv', folderSelect, ignore.case = T),]
# csv <- data.frame(matrix(NA, 0, 18),
#            stringsAsFactors=F)
#
# for (q in nrow(df)){
#   # q = 2
#   csv <- rbind(csv, as.matrix(read.csv2(as.character(df[q,1]),
#                       header = T, sep = ',', na.strings=c("","NA"))))
#
# }
# strings to compare
# set1 <- 'Suriname_229_56_2009_till_2009_testImage2009115'
# set2 <- 'Suriname_229_56_2009_till_2009_testImage2009115_extraMask'
# set1 <- 'Suriname_229_56_2009_till_2009_testImage20091115_extraMask_V20201207'
# set2 <- 'Suriname_229_56_2009_till_2009_testImage20091115_extraMask_largestDrop'
# largest, relative and slope drop for 20091115 image
# set1 <- 'Suriname_229_56_2009_till_2009_testImage20091115_largestDrop_20201210'
# set2 <- 'Suriname_229_56_2009_till_2009_testImage20091115_relativeDrop_20201210'
# set3 <- 'Suriname_229_56_2009_till_2009_testImage20091115_slopeDrop_20201210'
# largest, relative and slope drop for 20091115 image
set1 <- 'Suriname_229_56_2009_till_2009_testImage20090912_largestDrop_20201210'
# set2 <- 'Suriname_229_56_2009_till_2009_testImage20090912_relativeDrop_20201210'
# set3 <- 'Suriname_229_56_2009_till_2009_testImage20090912_slopeDrop_20201210'
set3 <- '/Suriname_229_56_2009_till_2009_testImage20090912_extraMask_largestDrop'
set2 <- 'Suriname_229_56_2009_till_2009_testImage20090912_extraMask_V20201207'
csv1 = as.matrix(read.csv2(as.character(df[grep(set1, folderSelect, ignore.case = T),1]),
header = T, sep = ',', na.strings=c("","NA"))) # rewrite as matrix to read columns as numeric values
csv2 = as.matrix(read.csv2(as.character(df[grep(set2, folderSelect, ignore.case = T),1]),
header = T, sep = ',', na.strings=c("","NA"))) # rewrite as matrix to read columns as numeric values
csv3 = as.matrix(read.csv2(as.character(df[grep(set3, folderSelect, ignore.case = T),1]),
header = T, sep = ',', na.strings=c("","NA"))) # rewrite as matrix to read columns as numeric values
# mydata <- sapply(list.files(paste0(dataFolder, '/GEE_exports/testImages'), full.names = T), read.csv)
points1<- reshape_csvPoints(csv1, 'peakCoordX', 'peakCoordY')
pointsLand1 <- reshape_csvPoints(csv1, 'coastX', 'coastY')
points2<- reshape_csvPoints(csv2, 'peakCoordX', 'peakCoordY')
pointsLand2 <- reshape_csvPoints(csv2, 'coastX', 'coastY')
points3<- reshape_csvPoints(csv3, 'peakCoordX', 'peakCoordY')
pointsLand3 <- reshape_csvPoints(csv3, 'coastX', 'coastY')
# filter -1?
lines1 <- reshape_csvLines(csv1)
# change format of lines
lines_sf <- st_as_sf(lines1)
# ee_clean_pyenv()
ee_Initialize()
# ee_clean_pyenv()
ee_install()
ee_check()
# ee_clean_pyenv()
# ee_install()
ee_Initialize()
ee_install()
ee_clean_pyenv()
## ---------------------------
#'
#' Script name: Plot offshore boundary results
#'
#' Short Description:
#'
#'
#' Author: Job de Vries
#'
#' Date Created: 2020-11-16
#'
#' Copyright (c) Job de Vries, 2020
#' Email: j.devries4@uu.nl
#'
## ---------------------------
#'
#' Description
#'
#'
#'
## ---------------------------
rm(list = ls())
#' set working directory for Mac and PC
wd<-getwd()
# setwd("I:/BackUp_D_mangroMud_202001/Research/Software/Projects/offshore_boundary")
## ---------------------------
options(scipen = 6, digits = 4) # I prefer to view outputs in non-scientific notation
memory.limit(30000000)     # this is needed on some PCs to increase memory allowance, but has no impact on macs.
#  Map view options:
# https://r-spatial.github.io/mapview/articles/articles/mapview_02-advanced.html
## ---------------------------
#' load up the packages
source("./src/packages.R")       # loads up all the packages we need
## ---------------------------
source("./src/functions.R")
## ---------------------------
dataFolder <- './data/raw'
# transect  <- readOGR(paste0(dataFolder, '/transects'), '2009_WnZ_transect')
# select folders
folderSelect <- as.matrix(list.files(paste0(dataFolder, '/GEE_exports/testImages'), full.names = T))
# metaMatrix <- as.matrix(list.files(folderSelect, pattern=".csv", full.names = T))
mapviewOptions(basemaps = c( "Esri.WorldImagery","Esri.WorldShadedRelief", "OpenStreetMap.DE"))
df <- rewrite(folderSelect);
# only csv's
df <- df[grep('.csv', folderSelect, ignore.case = T),]
# csv <- data.frame(matrix(NA, 0, 18),
#            stringsAsFactors=F)
#
# for (q in nrow(df)){
#   # q = 2
#   csv <- rbind(csv, as.matrix(read.csv2(as.character(df[q,1]),
#                       header = T, sep = ',', na.strings=c("","NA"))))
#
# }
# strings to compare
# set1 <- 'Suriname_229_56_2009_till_2009_testImage2009115'
# set2 <- 'Suriname_229_56_2009_till_2009_testImage2009115_extraMask'
# set1 <- 'Suriname_229_56_2009_till_2009_testImage20091115_extraMask_V20201207'
# set2 <- 'Suriname_229_56_2009_till_2009_testImage20091115_extraMask_largestDrop'
# largest, relative and slope drop for 20091115 image
# set1 <- 'Suriname_229_56_2009_till_2009_testImage20091115_largestDrop_20201210'
# set2 <- 'Suriname_229_56_2009_till_2009_testImage20091115_relativeDrop_20201210'
# set3 <- 'Suriname_229_56_2009_till_2009_testImage20091115_slopeDrop_20201210'
# largest, relative and slope drop for 20091115 image
set1 <- 'Suriname_229_56_2009_till_2009_testImage20090912_largestDrop_20201210'
# set2 <- 'Suriname_229_56_2009_till_2009_testImage20090912_relativeDrop_20201210'
# set3 <- 'Suriname_229_56_2009_till_2009_testImage20090912_slopeDrop_20201210'
set3 <- '/Suriname_229_56_2009_till_2009_testImage20090912_extraMask_largestDrop'
set2 <- 'Suriname_229_56_2009_till_2009_testImage20090912_extraMask_V20201207'
csv1 = as.matrix(read.csv2(as.character(df[grep(set1, folderSelect, ignore.case = T),1]),
header = T, sep = ',', na.strings=c("","NA"))) # rewrite as matrix to read columns as numeric values
csv2 = as.matrix(read.csv2(as.character(df[grep(set2, folderSelect, ignore.case = T),1]),
header = T, sep = ',', na.strings=c("","NA"))) # rewrite as matrix to read columns as numeric values
csv3 = as.matrix(read.csv2(as.character(df[grep(set3, folderSelect, ignore.case = T),1]),
header = T, sep = ',', na.strings=c("","NA"))) # rewrite as matrix to read columns as numeric values
# mydata <- sapply(list.files(paste0(dataFolder, '/GEE_exports/testImages'), full.names = T), read.csv)
points1<- reshape_csvPoints(csv1, 'peakCoordX', 'peakCoordY')
pointsLand1 <- reshape_csvPoints(csv1, 'coastX', 'coastY')
points2<- reshape_csvPoints(csv2, 'peakCoordX', 'peakCoordY')
pointsLand2 <- reshape_csvPoints(csv2, 'coastX', 'coastY')
points3<- reshape_csvPoints(csv3, 'peakCoordX', 'peakCoordY')
pointsLand3 <- reshape_csvPoints(csv3, 'coastX', 'coastY')
# filter -1?
lines1 <- reshape_csvLines(csv1)
# change format of lines
lines_sf <- st_as_sf(lines1)
mapview(pointsLand2,col.regions = c("blue"))
# ee_clean_pyenv()
# ee_install()
ee_Initialize()
# ee_clean_pyenv()
# ee_install()
ee_Initialize()
ee_clean_pyenv()
ee_install()
library(rgee)
# ee_clean_pyenv()
# ee_install()
ee_Initialize()
# Load an image.
image20090912 <- ee$Image("LANDSAT/LT05/C01/T1_TOA/LT05_229056_20090912")
image20091115 <- ee$Image("LANDSAT/LT05/C01/T1_TOA/LT05_229056_20091115")
vizParams <- list(
bands = c("B5", "B4", "B3"),
min = 0.05, max = 0.4, gamma = 1.4
)
test1 <- Map$addLayer(image20090912, vizParams, "Landsat 8 False color")
test1 +
mapview(pointsLand2,col.regions = c("blue")) +
mapview(points1, col.regions = c("red"), layer.name = c("set1")) +
mapview(points2, col.regions = c("green"), layer.name = c("set2")) +
mapview(points3, col.regions = c("yellow"), layer.name = c("set3")) +
mapview(lines_sf,xcol = "x", ycol = "y")
